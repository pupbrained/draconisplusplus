This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.clang-format
.clang-tidy
.claude/settings.local.json
.envrc
.gitattributes
.github/workflows/build.yml
.gitignore
.gitmodules
ATTRIBUTIONS.md
CLAUDE.md
config.example.hpp
Doxyfile
examples/glaze_http/main.cpp
examples/glaze_http/web/index.mustache
examples/glaze_http/web/style.css
examples/mcp_server/main.cpp
examples/meson.build
examples/switch_app/main.cpp
examples/vulkan_app/main.cpp
flake.lock
flake.nix
include/Drac++/Core/System.hpp
include/Drac++/Services/Packages.hpp
include/Drac++/Services/Weather.hpp
include/Drac++/Utils/ArgumentParser.hpp
include/Drac++/Utils/CacheManager.hpp
include/Drac++/Utils/DataTypes.hpp
include/Drac++/Utils/Env.hpp
include/Drac++/Utils/Error.hpp
include/Drac++/Utils/Logging.hpp
include/Drac++/Utils/Types.hpp
LICENSE
meson.build
meson.options
nix/default.nix
nix/module.nix
nix/musl.nix
nix/package.nix
src/CLI/Config/Config.cpp
src/CLI/Config/Config.hpp
src/CLI/Core/SystemInfo.cpp
src/CLI/Core/SystemInfo.hpp
src/CLI/main.cpp
src/CLI/meson.build
src/CLI/UI/AsciiArt.hpp
src/CLI/UI/UI.cpp
src/CLI/UI/UI.hpp
src/Lib/meson.build
src/Lib/OS/BSD.cpp
src/Lib/OS/Haiku.cpp
src/Lib/OS/Linux.cpp
src/Lib/OS/macOS.cpp
src/Lib/OS/macOS/Bridge.hpp
src/Lib/OS/macOS/Bridge.mm
src/Lib/OS/Serenity.cpp
src/Lib/OS/Switch.cpp
src/Lib/OS/Windows.cpp
src/Lib/Services/Packages.cpp
src/Lib/Services/Weather/DataTransferObjects.hpp
src/Lib/Services/Weather/MetNoService.cpp
src/Lib/Services/Weather/MetNoService.hpp
src/Lib/Services/Weather/OpenMeteoService.cpp
src/Lib/Services/Weather/OpenMeteoService.hpp
src/Lib/Services/Weather/OpenWeatherMapService.cpp
src/Lib/Services/Weather/OpenWeatherMapService.hpp
src/Lib/Services/Weather/WeatherFactory.cpp
src/Lib/Services/Weather/WeatherUtils.cpp
src/Lib/Services/Weather/WeatherUtils.hpp
src/Lib/Tests/.clang-tidy
src/Lib/Tests/CacheManagerTest.cpp
src/Lib/Tests/CoreTypesTest.cpp
src/Lib/Tests/LoggingUtilsTest.cpp
src/Lib/Tests/meson.build
src/Lib/Tests/PackageCountingIntegrationTest.cpp
src/Lib/Tests/PackageCountingMockTest.cpp
src/Lib/Tests/WeatherServiceTest.cpp
src/Lib/Wrappers/Curl.hpp
src/Lib/Wrappers/DBus.hpp
src/Lib/Wrappers/Wayland.hpp
src/Lib/Wrappers/XCB.hpp
subprojects/asio.wrap
subprojects/curl.wrap
subprojects/glaze.wrap
subprojects/glfw.wrap
subprojects/gtest.wrap
subprojects/imgui.wrap
subprojects/magic_enum.wrap
subprojects/openssl.wrap
subprojects/pugixml.wrap
subprojects/sqlitecpp.wrap
subprojects/tomlplusplus.wrap
third_party/matchit.hpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "mcp__draconisplusplus__now_playing"
    ],
    "deny": []
  }
}
</file>

<file path=".gitattributes">
* text eol=lf
</file>

<file path=".gitmodules">
[submodule "subprojects/glaze"]
	path = subprojects/glaze
	url = https://github.com/stephenberry/glaze
[submodule "subprojects/dbus_cxx"]
	path = subprojects/dbus_cxx
	url = https://github.com/dbus-cxx/dbus-cxx
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build Commands

This project uses Meson build system. A Nix development environment is available but not required.

### Core Commands
- **Build**: `meson compile -C build`
- **Configure**: `meson setup build --wipe`
- **Run**: `meson compile -C build && build/draconis++`
- **Tests**: Enable with `-Dbuild_tests=true` during setup, then run tests from build directory

### Development Setup (Optional)
A Nix shell provides dependencies and helper scripts:
```bash
nix develop
# Then use: build, clean, run scripts
```

### Available Options
Key meson options:
- `-Dprecompiled_config=true/false` - Use precompiled config vs runtime TOML parsing
- `-Dbuild_tests=true/false` - Build test suite
- `-Dbuild_examples=true/false` - Build example applications
- `-Dweather=enabled/disabled` - Weather service support
- `-Dpackagecount=enabled/disabled` - Package counting features
- `-Dnowplaying=enabled/disabled` - Media player integration

## Architecture

Draconis++ is a cross-platform system information utility written in modern C++26.

### Core Structure
- **`src/CLI/`** - Main CLI application and UI components
- **`src/Lib/`** - Core library with platform abstractions
- **`include/Drac++/`** - Public API headers
- **`examples/`** - Example applications (MCP server, Vulkan app, etc.)

### Key Components
1. **Core System (`include/Drac++/Core/System.hpp`)** - Cross-platform system info interface
2. **Services** - Weather APIs, package managers, media player integration
3. **Platform Abstractions (`src/Lib/OS/`)** - OS-specific implementations (Windows, macOS, Linux, BSD, Haiku, SerenityOS)
4. **Wrappers (`src/Lib/Wrappers/`)** - C++ wrappers for system APIs (Curl, DBus, Wayland, XCB)

### Type System
Uses custom type aliases in `Drac++/Utils/Types.hpp`:
- `String`, `Vec<T>`, `Option<T>`, `Result<T>` 
- Platform detection macros: `DRAC_ARCH_*`, `DRAC_ENABLE_*`
- `fn` macro for `auto` function return types

### Dependencies
- **Magic Enum** - Enum reflection
- **TOML++** - Configuration parsing (runtime mode only)
- **Glaze** - JSON/BEVE serialization  
- **libcurl** - HTTP requests for weather services
- **Platform-specific**: DBus, XCB/Wayland (Linux), Windows APIs, macOS frameworks

### Configuration
Two modes:
1. **Runtime TOML parsing** - Reads TOML file from user's configuration directory
2. **Precompiled configuration** - Uses `config.hpp` with compile-time constants (based on `config.example.hpp`)

For precompiled mode, copy `config.example.hpp` to `config.hpp` and customize.

## Testing

Test files are in `src/Lib/Tests/`:
- Unit tests for core utilities
- Integration tests for package counting
- Mock tests for external services

## Platform Support

Supports Windows, macOS, Linux, *BSD, Haiku, and SerenityOS with platform-specific optimizations and feature detection.
</file>

<file path="Doxyfile">
PROJECT_NAME           = Draconis++
PROJECT_NUMBER         = 0.1.0
PROJECT_BRIEF          = "A modern, cross-platform system information tool with a focus on speed"
OUTPUT_DIRECTORY       = docs
ALLOW_UNICODE_NAMES    = YES
INLINE_INHERITED_MEMB  = YES
RECURSIVE              = YES
EXTRACT_ALL            = YES
ENABLE_PREPROCESSING   = YES
MACRO_EXPANSION        = YES
EXCLUDE_PATTERNS       = */build/* \
                         */tests/* \
                         */subprojects/* \
                         */third_party/* \
                         */examples/*
</file>

<file path="src/Lib/Tests/.clang-tidy">
Checks: >
  *,
  -abseil-*,
  -altera-*,
  -boost-*,
  -bugprone-easily-swappable-parameters,
  -bugprone-implicit-widening-of-multiplication-result,
  -cert-env33-c,
  -concurrency-mt-unsafe,
  -cppcoreguidelines-avoid-magic-numbers,
  -cppcoreguidelines-macro-usage,
  -cppcoreguidelines-owning-memory,
  -cppcoreguidelines-pro-bounds-array-to-pointer-decay,
  -cppcoreguidelines-pro-type-member-init,
  -cppcoreguidelines-pro-type-vararg,
  -ctad-maybe-unsupported,
  -fuchsia-*,
  -google-*,
  -hicpp-*,
  -llvm-include-order,
  -llvm-namespace-comment,
  -llvmlibc-*,
  -misc-non-private-member-variables-in-classes,
  -readability-avoid-nested-conditional-operator,
  -readability-braces-around-statements,
  -readability-function-cognitive-complexity,
  -readability-implicit-bool-conversion,
  -readability-isolate-declaration,
  -readability-magic-numbers,
  -modernize-use-trailing-return-type,
  -cert-err58-cpp
CheckOptions:
  cppcoreguidelines-avoid-do-while.IgnoreMacros: true
  readability-else-after-return.WarnOnUnfixable: false
  readability-identifier-naming.ClassCase: CamelCase
  readability-identifier-naming.EnumCase: CamelCase
  readability-identifier-naming.LocalConstantCase: camelBack
  readability-identifier-naming.LocalVariableCase: camelBack
  readability-identifier-naming.GlobalFunctionCase: CamelCase
  readability-identifier-naming.MemberCase: camelBack
  readability-identifier-naming.MethodCase: camelBack
  readability-identifier-naming.MethodIgnoredRegexp: ((to|from)_class)
  readability-identifier-naming.ParameterPackCase: lower_case
  readability-identifier-naming.PrivateMemberCase: camelBack
  readability-identifier-naming.PrivateMemberPrefix: 'm_'
  readability-identifier-naming.PrivateMethodCase: camelBack
  readability-identifier-naming.PrivateMethodPrefix: ''
  readability-identifier-naming.ProtectedMemberPrefix: 'm_'
  readability-identifier-naming.ProtectedMethodPrefix: ''
  readability-identifier-naming.PublicMemberCase: camelBack
  readability-identifier-naming.StaticConstantCase: UPPER_CASE
  readability-identifier-naming.StaticVariableCase: CamelCase
  readability-identifier-naming.StructCase: CamelCase
  readability-identifier-naming.TemplateParameterCase: lower_case
  readability-identifier-naming.TemplateTemplateParameterCase: CamelCase
  readability-identifier-naming.TypeTemplateParameterCase: CamelCase
  readability-identifier-naming.TypedefCase: CamelCase
  readability-identifier-naming.UnionCase: CamelCase
</file>

<file path="subprojects/asio.wrap">
[wrap-file]
directory = asio-1.30.2
source_url = https://sourceforge.net/projects/asio/files/asio/1.30.2%20%28Stable%29/asio-1.30.2.tar.gz/download
source_filename = asio-1.30.2.tar.gz
source_hash = 12e7bb4dada8bc1191de9d550a59ee658ce4e645ffc97c911c099ab4e8699d55
patch_filename = asio_1.30.2-2_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/asio_1.30.2-2/get_patch
patch_hash = 8bed3693016874b097e4d902c4ca8daf1b6abf1b5a56b0c5c02827d4e0747ddb
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/asio_1.30.2-2/asio-1.30.2.tar.gz
wrapdb_version = 1.30.2-2

[provide]
asio = asio_dep
</file>

<file path="subprojects/curl.wrap">
[wrap-file]
directory = curl-8.10.1
source_url = https://github.com/curl/curl/releases/download/curl-8_10_1/curl-8.10.1.tar.xz
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/curl_8.10.1-1/curl-8.10.1.tar.xz
source_filename = curl-8.10.1.tar.xz
source_hash = 73a4b0e99596a09fa5924a4fb7e4b995a85fda0d18a2c02ab9cf134bebce04ee
patch_filename = curl_8.10.1-1_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/curl_8.10.1-1/get_patch
patch_hash = 707c28f35fc9b0e8d68c0c2800712007612f922a31da9637ce706a2159f3ddd8
wrapdb_version = 8.10.1-1

[provide]
dependency_names = libcurl
</file>

<file path="subprojects/glfw.wrap">
[wrap-file]
directory = glfw-3.4
source_url = https://github.com/glfw/glfw/archive/refs/tags/3.4.tar.gz
source_filename = glfw-3.4.tar.gz
source_hash = c038d34200234d071fae9345bc455e4a8f2f544ab60150765d7704e08f3dac01
patch_filename = glfw_3.4-1_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/glfw_3.4-1/get_patch
patch_hash = 58a6a6cdb28195d7f7e6f5de85dff7044d378e49b46bf1d4a9b04c97ed93e6b0
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/glfw_3.4-1/glfw-3.4.tar.gz
wrapdb_version = 3.4-1

[provide]
glfw3 = glfw_dep
</file>

<file path="subprojects/gtest.wrap">
[wrap-file]
directory = googletest-1.17.0
source_url = https://github.com/google/googletest/archive/refs/tags/v1.17.0.tar.gz
source_filename = googletest-1.17.0.tar.gz
source_hash = 65fab701d9829d38cb77c14acdc431d2108bfdbf8979e40eb8ae567edf10b27c
patch_filename = gtest_1.17.0-3_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/gtest_1.17.0-3/get_patch
patch_hash = 3e2799683f27c6dce138b7bae823416581c467ddde755c9a516c0863225f0ceb
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/gtest_1.17.0-3/googletest-1.17.0.tar.gz
wrapdb_version = 1.17.0-3

[provide]
gtest = gtest_dep
gtest_main = gtest_main_dep
gmock = gmock_dep
gmock_main = gmock_main_dep
</file>

<file path="subprojects/imgui.wrap">
[wrap-file]
directory = imgui-1.91.6
source_url = https://github.com/ocornut/imgui/archive/refs/tags/v1.91.6.tar.gz
source_filename = imgui-1.91.6.tar.gz
source_hash = c5fbc5dcab1d46064001c3b84d7a88812985cde7e0e9ced03f5677bec1ba502a
patch_filename = imgui_1.91.6-2_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/imgui_1.91.6-2/get_patch
patch_hash = 515e31b18e3928aafce2c62c94fa6d8426f5132e9c3f2d9951b7e96b6381f33a
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/imgui_1.91.6-2/imgui-1.91.6.tar.gz
wrapdb_version = 1.91.6-2

[provide]
imgui = imgui_dep
</file>

<file path="subprojects/openssl.wrap">
[wrap-file]
directory = openssl-3.0.8
source_url = https://www.openssl.org/source/openssl-3.0.8.tar.gz
source_filename = openssl-3.0.8.tar.gz
source_hash = 6c13d2bf38fdf31eac3ce2a347073673f5d63263398f1f69d0df4a41253e4b3e
patch_filename = openssl_3.0.8-3_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/openssl_3.0.8-3/get_patch
patch_hash = 300da189e106942347d61a4a4295aa2edbcf06184f8d13b4cee0bed9fb936963
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/openssl_3.0.8-3/openssl-3.0.8.tar.gz
wrapdb_version = 3.0.8-3

[provide]
libcrypto = libcrypto_dep
libssl = libssl_dep
openssl = openssl_dep
</file>

<file path="subprojects/pugixml.wrap">
[wrap-file]
directory = pugixml-1.15
source_url = https://github.com/zeux/pugixml/archive/v1.15.tar.gz
source_filename = pugixml-1.15.tar.gz
source_hash = b39647064d9e28297a34278bfb897092bf33b7c487906ddfc094c9e8868bddcb
patch_filename = pugixml_1.15-1_patch.zip
patch_url = https://wrapdb.mesonbuild.com/v2/pugixml_1.15-1/get_patch
patch_hash = 71283431485c5e014c1e360033e84c56fda04171f9ba3bb48f37dd30c48e1d57
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/pugixml_1.15-1/pugixml-1.15.tar.gz
wrapdb_version = 1.15-1

[provide]
pugixml = pugixml_dep
</file>

<file path="subprojects/sqlitecpp.wrap">
[wrap-file]
directory = SQLiteCpp-3.3.2
source_url = https://github.com/SRombauts/SQLiteCpp/archive/refs/tags/3.3.2.zip
source_filename = sqlitecpp-3.3.2.zip
source_hash = 1f41ef7322da573fdfca95655bd1329282638b4d9d3dc16a48f4bad16008eda8
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/sqlitecpp_3.3.2-1/sqlitecpp-3.3.2.zip
wrapdb_version = 3.3.2-1

[provide]
sqlitecpp = sqlitecpp_dep
</file>

<file path="subprojects/tomlplusplus.wrap">
[wrap-file]
directory = tomlplusplus-3.4.0
source_url = https://github.com/marzer/tomlplusplus/archive/v3.4.0.tar.gz
source_filename = tomlplusplus-3.4.0.tar.gz
source_hash = 8517f65938a4faae9ccf8ebb36631a38c1cadfb5efa85d9a72e15b9e97d25155
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/tomlplusplus_3.4.0-1/tomlplusplus-3.4.0.tar.gz
wrapdb_version = 3.4.0-1

[provide]
dependency_names = tomlplusplus
</file>

<file path=".clang-format">
BasedOnStyle: Chromium
AlignAfterOpenBracket: BlockIndent
AlignArrayOfStructures: Right
AlignConsecutiveAssignments:
  Enabled: true
AlignConsecutiveDeclarations:
  Enabled: true
  PadOperators: true
AlignConsecutiveMacros:
  Enabled: true
AlignConsecutiveShortCaseStatements:
  Enabled: true
AlignOperands: DontAlign
AllowShortBlocksOnASingleLine: Always
AllowShortCaseLabelsOnASingleLine: true
AllowShortFunctionsOnASingleLine: Empty
AllowShortLoopsOnASingleLine: true
BinPackArguments: false
BreakBeforeBraces: Attach
ColumnLimit: 0
ConstructorInitializerIndentWidth: 2
ContinuationIndentWidth: 2
Cpp11BracedListStyle: false
IncludeBlocks: Regroup
IncludeCategories:
  - Regex: '^(<|")Drac\+\+/Utils/.*'
    Priority: 3
  - Regex: '^(<|")Drac\+\+/.*'
    Priority: 2
  - Regex: '".*"'
    Priority: 4
  - Regex: '<.*>'
    Priority: 1
IndentExternBlock: Indent
IndentPPDirectives: BeforeHash
NamespaceIndentation: All
QualifierAlignment: Left
SpaceBeforeCpp11BracedList: true
SpacesBeforeTrailingComments: 1
</file>

<file path=".github/workflows/build.yml">
name: Build
on:
  workflow_dispatch:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  linux:
    name: Linux
    runs-on: native-linux
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Add custom tools to PATH
        run: echo "/run/current-system/sw/bin:/nix/var/nix/profiles/default/bin:$PATH" >> $GITHUB_PATH

      - name: Build and test package
        id: build
        run: echo "path=$(nix build .#musl-generic --no-link --print-out-paths)" >> $GITHUB_OUTPUT

      - name: Check build
        run: nix flake check --impure

      - name: Push to Cachix
        run: cachix push pupbrained ${{ steps.build.outputs.path }}
        env:
          CACHIX_AUTH_TOKEN: ${{ secrets.CACHIX_AUTH_TOKEN }}
          CACHIX_SIGNING_KEY: ${{ secrets.CACHIX_SIGNING_KEY }}

      - name: Upload Nix musl-generic Artifact
        uses: actions/upload-artifact@v3
        with:
          name: linux-build
          path: ${{ steps.build.outputs.path }}/bin/draconis++
  # windows:
  #   name: Windows
  #   runs-on: [native]
  #   steps:
  #     - name: Define Persistent Paths and Ensure Directories Exist
  #       id: paths
  #       run: |
  #         $repoName = "${{ github.event.repository.name }}"
  #         $persistentSourcePath = "C:\persistent_checkout\$repoName"
  #         $persistentBuildPath = "C:\persistent_builds\$repoName"
  #
  #         Write-Host "Persistent Source Directory: $persistentSourcePath"
  #         Write-Host "Persistent Build Directory: $persistentBuildPath"
  #
  #         echo "source_dir=$persistentSourcePath" | Add-Content -Path $env:GITHUB_OUTPUT
  #         echo "build_dir=$persistentBuildPath" | Add-Content -Path $env:GITHUB_OUTPUT
  #
  #         New-Item -ItemType Directory -Force -Path $persistentSourcePath | Out-Null
  #         New-Item -ItemType Directory -Force -Path $persistentBuildPath | Out-Null
  #       shell: powershell
  #
  #     - name: Manually Clone or Update Code in Persistent Source Directory
  #       env:
  #         GIT_AUTH_HEADER: "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}"
  #         PERSISTENT_SOURCE_DIR: ${{ steps.paths.outputs.source_dir }}
  #         GIT_REPOSITORY_URL: "https://github.com/${{ github.repository }}.git"
  #         GIT_SHA: ${{ github.sha }}
  #       run: |
  #         Write-Host "Ensuring source code at commit '$env:GIT_SHA' is in '$env:PERSISTENT_SOURCE_DIR'"
  #
  #         if (-not (Test-Path (Join-Path $env:PERSISTENT_SOURCE_DIR ".git"))) {
  #           if ($LASTEXITCODE -ne 0) { throw "Git clone failed." }
  #           cd $env:PERSISTENT_SOURCE_DIR
  #         } else {
  #           Write-Host "Existing .git directory found. Fetching and setting up..."
  #           cd $env:PERSISTENT_SOURCE_DIR
  #           git remote set-url origin $env:GIT_REPOSITORY_URL
  #           git fetch --all --prune --tags
  #           if ($LASTEXITCODE -ne 0) { throw "Git fetch failed." }
  #         }
  #
  #         Write-Host "Checking out SHA: $env:GIT_SHA"
  #         git checkout --force $env:GIT_SHA
  #         if ($LASTEXITCODE -ne 0) { throw "Git checkout to SHA [$env:GIT_SHA] failed." }
  #
  #         git clean -fdx
  #
  #         Write-Host "Updating submodules..."
  #         git submodule sync --recursive
  #         git submodule update --init --force --recursive
  #
  #         Write-Host "Successfully prepared source directory. Current commit:"
  #         git log -1 --oneline
  #       shell: powershell
  #
  #     - name: Setup Build
  #       run: >
  #         meson setup "${{ steps.paths.outputs.build_dir }}" "${{ steps.paths.outputs.source_dir }}" --buildtype=release
  #         -Dc_args="-fuse-ld=lld"
  #         -Dcpp_args="-fuse-ld=lld"
  #         -Dc_link_args="-fuse-ld=lld"
  #         -Dcpp_link_args="-fuse-ld=lld"
  #       shell: powershell
  #
  #     - name: Compile
  #       run: meson compile -C "${{ steps.paths.outputs.build_dir }}"
  #       shell: powershell
  #
  #     - name: Run tests
  #       run: meson test -C "${{ steps.paths.outputs.build_dir }}" --print-errorlogs
  #       shell: powershell
  #
  #     - name: Upload Build Artifacts
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: windows-build
  #         path: "${{ steps.paths.outputs.build_dir }}\\draconis++.exe"
</file>

<file path=".gitignore">
.cache/
.cmake/
.direnv/
.idea/
.vs/
.vscode/
.xmake/
.DS_Store

bin/
build/
cmake-build-debug/
CMakeFiles/
out/
Testing/
docs/

build.ninja
CMakeCache.txt
cmake_install.cmake
CMakeSettings.json
compile_commands.json
config.toml
draconis++
Makefile
result
imgui.ini
subprojects/*
!subprojects/*.wrap
subprojects/sqlite3.wrap
dev_profile*

/config.hpp
pci_ids.o
</file>

<file path="config.example.hpp">
/**
 * @file config.example.hpp
 * @brief Example configuration file for the application.
 *
 * @details This file serves as a template for `config.hpp`.
 * Users should copy this file to `config.hpp` and customize the
 * settings according to their preferences.
 *
 * To enable these precompiled settings, `DRAC_PRECOMPILED_CONFIG` must be defined
 * in your build system or `meson.options`.
 */
#pragma once

#if DRAC_PRECOMPILED_CONFIG

  #if DRAC_ENABLE_WEATHER || DRAC_ENABLE_PACKAGECOUNT
    #include "Config/Config.hpp" // Location

    #include "Services/Weather.hpp" // Coords

    #include "Util/ConfigData.hpp" // PackageManager, WeatherProvider, WeatherUnit
  #endif

namespace config {
  /**
   * @brief The username to display.
   * @details Used for the greeting message.
   */
  constexpr const char* DRAC_USERNAME = "User";

  #if DRAC_ENABLE_WEATHER
  /**
   * @brief Selects the weather service provider.
   *
   * @details
   * - `WeatherProvider::OPENWEATHERMAP`: Uses OpenWeatherMap API (requires `DRAC_API_KEY`).
   * - `WeatherProvider::OPENMETEO`:      Uses OpenMeteo API (no API key needed).
   * - `WeatherProvider::METNO`:          Uses Met.no API (no API key needed).
   *
   * @see DRAC_API_KEY
   * @see WeatherProvider
   */
  constexpr WeatherProvider DRAC_WEATHER_PROVIDER = WeatherProvider::OPENMETEO;

  /**
   * @brief Specifies the unit system for displaying weather information.
   *
   * @details
   * - `WeatherUnit::IMPERIAL`: Uses imperial units (e.g., Fahrenheit, mph).
   * - `WeatherUnit::METRIC`:   Uses metric units (e.g., Celsius, kph).
   *
   * @see WeatherUnit
   */
  constexpr WeatherUnit DRAC_WEATHER_UNIT = WeatherUnit::METRIC;

  /**
   * @brief Determines whether to display the town name in the weather output.
   *
   * @note If set to `true`, the weather condition/description might be hidden
   *       to save space, depending on the UI implementation.
   *
   * @details
   * - `true`:  Show the town name.
   * - `false`: Do not show the town name (default, may show condition instead).
   */
  constexpr bool DRAC_SHOW_TOWN_NAME = false;

  /**
   * @brief API key for the OpenWeatherMap service.
   *
   * @details
   * - This key is **only** required if `DRAC_WEATHER_PROVIDER` is set to `WeatherProvider::OPENWEATHERMAP`.
   * - Met.no and OpenMeteo providers do not require an API key; for these, this value can be `std::nullopt`.
   * - Obtain an API key from [OpenWeatherMap](https://openweathermap.org/api).
   *
   * @see DRAC_WEATHER_PROVIDER
   */
  constexpr std::optional<std::string> DRAC_API_KEY = std::nullopt;

  /**
   * @brief Specifies the location for weather forecasts.
   *
   * For `WeatherProvider::OPENWEATHERMAP`, this can be a city name (e.g., `"London,UK"`) or
   * `weather::Coords` for latitude/longitude.
   *
   * For `WeatherProvider::OPENMETEO` and `WeatherProvider::METNO`, this **must** be
   * `weather::Coords` (latitude and longitude).
   *
   * For New York City using coordinates:
   * @code{.cpp}
   * constexpr Location DRAC_LOCATION = weather::Coords { .lat = 40.730610, .lon = -73.935242 };
   * @endcode
   *
   * For New York City using a city name (OpenWeatherMap only):
   * @code{.cpp}
   * constexpr Location DRAC_LOCATION = "New York,US";
   * @endcode
   *
   * @see Location
   * @see weather::Coords
   * @see DRAC_WEATHER_PROVIDER
   *
   */
  constexpr Location DRAC_LOCATION = weather::Coords { .lat = 40.730610, .lon = -73.935242 };
  #endif

  #if DRAC_ENABLE_PACKAGECOUNT
  /**
   * @brief Configures which package managers' counts are displayed.
   *
   * This is a bitmask field. Combine multiple `PackageManager` enum values
   * using the bitwise OR operator (`|`).
   * The available `PackageManager` enum values are defined in `Util/ConfigData.hpp`
   * and may vary based on the operating system.
   *
   * @see PackageManager
   * @see HasPackageManager
   * @see Util/ConfigData.hpp
   *
   * To enable CARGO, PACMAN, and NIX package managers:
   * @code{.cpp}
   * constexpr PackageManager DRAC_ENABLED_PACKAGE_MANAGERS = PackageManager::CARGO | PackageManager::PACMAN | PackageManager::NIX;
   * @endcode
   *
   * To enable only CARGO:
   * @code{.cpp}
   * constexpr PackageManager DRAC_ENABLED_PACKAGE_MANAGERS = PackageManager::CARGO;
   * @endcode
   */
  constexpr PackageManager DRAC_ENABLED_PACKAGE_MANAGERS = PackageManager::CARGO;
  #endif
} // namespace config

#endif // DRAC_PRECOMPILED_CONFIG
</file>

<file path="examples/glaze_http/web/style.css">
:root {
  --bg-color: #f0f2f5;
  --text-color: #1c1e21;
  --container-bg: #fff;
  --container-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 8px 16px rgba(0, 0, 0, 0.1);
  --header-color: #1877f2;
  --border-color: #dddfe2;
  --table-header-bg: #e9ebee;
  --table-header-text: #4b4f56;
  --table-row-alt-bg: #f7f8fa;
  --footer-text-color: #606770;
  --error-color: #fa383e;
  --property-name-color: #333;
  --mobile-td-border-bottom-color: #eee;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #121212;
    --text-color: #e0e0e0;
    --container-bg: #1e1e1e;
    --container-shadow: none;
    --header-color: #66b2ff;
    --border-color: #444;
    --table-header-bg: #333;
    --table-header-text: #e0e0e0;
    --table-row-alt-bg: #2a2a2a;
    --footer-text-color: #888;
    --error-color: #ff6b6b;
    --property-name-color: #e0e0e0;
    --mobile-td-border-bottom-color: #444;
  }
}

.container {
  max-width: 800px;
  margin: 20px auto;
  background-color: var(--container-bg);
  padding: 20px;
  border-radius: 8px;
  box-shadow: var(--container-shadow);
}

.error {
  color: var(--error-color);
  font-style: italic;
}

.property-name {
  font-weight: 500;
  color: var(--property-name-color);
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background-color: var(--bg-color);
  color: var(--text-color);
}

footer {
  text-align: center;
  margin-top: 30px;
  padding-top: 15px;
  border-top: 1px solid var(--border-color);
  font-size: 0.9em;
  color: var(--footer-text-color);
}

h1 {
  color: var(--header-color);
  border-bottom: 2px solid var(--header-color);
  padding-bottom: 10px;
  margin-bottom: 20px;
  text-align: center;
}

table {
  border-collapse: collapse;
  width: 100%;
}

th {
  background-color: var(--table-header-bg);
  color: var(--table-header-text);
  font-weight: 600;
}

th,
td {
  border: 1px solid var(--border-color);
  padding: 12px 15px;
  text-align: left;
}

tr:nth-child(even) {
  background-color: var(--table-row-alt-bg);
}

@media (max-width: 600px) {
  .container {
    margin: 0;
    padding: 10px;
    width: 100%;
    box-shadow: none;
    border-radius: 0;
  }

  body {
    padding: 0;
  }

  h1 {
    font-size: 1.75em;
  }

  tr:first-of-type {
    display: none;
  }

  table thead tr {
    position: absolute;
    top: -9999px;
    left: -9999px;
  }

  table,
  thead,
  tbody,
  th,
  td,
  tr {
    display: block;
  }

  td {
    border: none;
    border-bottom: 1px solid var(--mobile-td-border-bottom-color);
    position: relative;
    padding-left: 5px;
  }

  td.property-name {
    background-color: var(--table-row-alt-bg);
    font-weight: 600;
  }

  tr {
    border: 1px solid var(--border-color);
    margin-bottom: 10px;
  }

  tr:nth-child(even) {
    background-color: var(--container-bg);
  }
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 pupbrained and other contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/Lib/OS/Switch.cpp">
#ifdef __SWITCH__

  #include <bit>
  #include <chrono>
  #include <format>
  #include <switch.h>
  #include <switch/kernel/detect.h>
  #include <switch/services/psm.h>
  #include <switch/services/set.h>
  #include <switch/services/spl.h>

  #include <Drac++/Core/System.hpp>

  #include <Drac++/Utils/CacheManager.hpp>
  #include <Drac++/Utils/Error.hpp>
  #include <Drac++/Utils/Types.hpp>

namespace draconis::core::system {
  using namespace draconis::utils::types;
  using draconis::utils::error::DracError;
  using enum draconis::utils::error::DracErrorCode;

  // Helper macro to quickly stub a function
  #define DRAC_SWITCH_STUB(func_name) \
    ERR(NotSupported, std::format("{} not implemented on Nintendo Switch", #func_name))

  fn GetMemInfo(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    u64 total = 0;
    u64 used  = 0;

    u32 rcTot = svcGetInfo(&total, InfoType_TotalMemorySize, CUR_PROCESS_HANDLE, 0);
    if (R_FAILED(rcTot))
      ERR(ApiUnavailable, std::format("svcGetInfo TotalMemorySize failed: 0x{:08X}", rcTot));

    u32 rcUsed = svcGetInfo(&used, InfoType_UsedMemorySize, CUR_PROCESS_HANDLE, 0);
    if (R_FAILED(rcUsed))
      ERR(ApiUnavailable, std::format("svcGetInfo UsedMemorySize failed: 0x{:08X}", rcUsed));

    return ResourceUsage { .usedBytes = used, .totalBytes = total };
  }

  fn GetNowPlaying() -> Result<MediaInfo> {
    DRAC_SWITCH_STUB(GetNowPlaying);
  }

  fn GetOSVersion(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("switch_os_version", []() -> Result<String> {
      SetSysFirmwareVersion fw = {};

      if (u32 rc = setsysInitialize(); R_FAILED(rc))
        ERR(ApiUnavailable, std::format("setsysInitialize failed: 0x{:08X}", rc));

      u32 rc = setsysGetFirmwareVersion(&fw);
      setsysExit();

      if (R_FAILED(rc))
        ERR(ApiUnavailable, std::format("setsysGetFirmwareVersion failed: 0x{:08X}", rc));

      return String(fw.display_version);
    });
  }

  fn GetDesktopEnvironment(CacheManager& /*cache*/) -> Result<String> {
    DRAC_SWITCH_STUB(GetDesktopEnvironment);
  }

  fn GetWindowManager(CacheManager& /*cache*/) -> Result<String> {
    DRAC_SWITCH_STUB(GetWindowManager);
  }

  fn GetShell(CacheManager& /*cache*/) -> Result<String> {
    DRAC_SWITCH_STUB(GetShell);
  }

  fn GetHost(CacheManager& /*cache*/) -> Result<String> {
    DRAC_SWITCH_STUB(GetHost);
  }

  fn GetCPUModel(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("switch_cpu_model", []() -> Result<String> {
      if (u32 rc = splInitialize(); R_FAILED(rc))
        ERR(ApiUnavailable, std::format("splInitialize failed: 0x{:08X}", rc));

      u64 hwType = 0;
      u32 rc     = splGetConfig(SplConfigItem_NewHardwareType, &hwType);
      splExit();

      if (R_FAILED(rc))
        ERR(ApiUnavailable, std::format("splGetConfig(NewHardwareType) failed: 0x{:08X}", rc));

      const char* modelName = "Unknown";
      switch (hwType) {
        case 0:
          modelName = "T210, Erista";
          break;
        case 2:
          modelName = "T210B01, Mariko";
          break;
        case 3:
          modelName = "T210B01, Aula";
          break;
        default:
          break;
      }

      return String(std::format("Tegra X1 ({})", modelName));
    });
  }

  fn GetCPUCores(CacheManager& cache) -> Result<CPUCores> {
    return cache.getOrSet<CPUCores>("switch_cpu_cores", []() -> Result<CPUCores> {
      u64 coreMask = 0;

      u32 rc = svcGetInfo(&coreMask, InfoType_CoreMask, CUR_PROCESS_HANDLE, 0);
      if (R_FAILED(rc))
        ERR(ApiUnavailable, std::format("svcGetInfo CoreMask failed: 0x{:08X}", rc));

      const usize cores = static_cast<usize>(std::popcount(coreMask));
      return CPUCores { cores, cores };
    });
  }

  fn GetGPUModel(CacheManager& /*cache*/) -> Result<String> {
    return "Tegra X1 - Hello from draconis++!";
  }

  fn GetKernelVersion(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("switch_kernel", []() -> Result<String> {
      const bool isMesosphere = detectMesosphere();

      return String(isMesosphere ? "Mesosphere" : "Horizon");
    });
  }

  fn GetDiskUsage(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    DRAC_SWITCH_STUB(GetDiskUsage);
  }

  fn GetUptime() -> Result<std::chrono::seconds> {
    const u64 ticks = armGetSystemTick();
    const u64 freq  = armGetSystemTickFreq(); // Hz, usually 19.2 MHz

    if (freq == 0)
      ERR(PlatformSpecific, "armGetSystemTickFreq returned 0");

    return std::chrono::seconds(ticks / freq);
  }

  fn GetOutputs(CacheManager& /*cache*/) -> Result<Vec<DisplayInfo>> {
    DRAC_SWITCH_STUB(GetOutputs);
  }

  fn GetPrimaryOutput(CacheManager& /*cache*/) -> Result<DisplayInfo> {
    DRAC_SWITCH_STUB(GetPrimaryOutput);
  }

  fn GetNetworkInterfaces(CacheManager& /*cache*/) -> Result<Vec<NetworkInterface>> {
    DRAC_SWITCH_STUB(GetNetworkInterfaces);
  }

  fn GetPrimaryNetworkInterface(CacheManager& /*cache*/) -> Result<NetworkInterface> {
    DRAC_SWITCH_STUB(GetPrimaryNetworkInterface);
  }

  fn GetBatteryInfo(CacheManager& /*cache*/) -> Result<Battery> {
    if (u32 rc = psmInitialize(); R_FAILED(rc))
      ERR(ApiUnavailable, std::format("psmInitialize failed: 0x{:08X}", rc));

    u32 percentage = 0;
    if (u32 rc = psmGetBatteryChargePercentage(&percentage); R_FAILED(rc)) {
      psmExit();
      ERR(ApiUnavailable, std::format("psmGetBatteryChargePercentage failed: 0x{:08X}", rc));
    }

    PsmChargerType chargerType = PsmChargerType_Unconnected;
    if (u32 rc = psmGetChargerType(&chargerType); R_FAILED(rc)) {
      psmExit();
      ERR(ApiUnavailable, std::format("psmGetChargerType failed: 0x{:08X}", rc));
    }

    Battery::Status status = Battery::Status::Unknown;
    switch (chargerType) {
      case PsmChargerType_Unconnected:
        status = Battery::Status::Discharging;
        break;
      case PsmChargerType_EnoughPower:
      case PsmChargerType_LowPower:
        status = (percentage >= 100) ? Battery::Status::Full : Battery::Status::Charging;
        break;
      case PsmChargerType_NotSupported:
      default:
        status = Battery::Status::Unknown;
        break;
    }

    Battery battery {
      status,
      Some(static_cast<u8>(percentage)),
      None // libnx/PSM does not expose time-remaining information
    };

    psmExit();

    return battery;
  }

  #undef DRAC_SWITCH_STUB
} // namespace draconis::core::system

#endif // __SWITCH__
</file>

<file path="subprojects/magic_enum.wrap">
[wrap-file]
directory = magic_enum-0.9.7
source_url = https://github.com/Neargye/magic_enum/archive/refs/tags/v0.9.7.tar.gz
source_filename = magic_enum-v0.9.7.tar.gz
source_hash = b403d3dad4ef542fdc3024fa37d3a6cedb4ad33c72e31b6d9bab89dcaf69edf7
source_fallback_url = https://github.com/mesonbuild/wrapdb/releases/download/magic_enum_0.9.7-1/magic_enum-v0.9.7.tar.gz
wrapdb_version = 0.9.7-1

[provide]
magic_enum = magic_enum_dep
</file>

<file path=".envrc">
NIXPKGS_ALLOW_UNFREE=1 NIXPKGS_ALLOW_UNSUPPORTED_SYSTEM=1 use_flake . --impure
</file>

<file path="ATTRIBUTIONS.md">
## Third-Party Software

This project incorporates materials from the following third-party software.

### match(it) (Apache License 2.0)

This project includes a modified version of the match(it) library. The original source can be found at https://github.com/BowenFu/matchit.cpp. Changes were made to integrate the library with this project's type system and error handling.

**Copyright (c) 2021-2022 Bowen Fu**

                              Apache License
                        Version 2.0, January 2004
                    http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

  "License" shall mean the terms and conditions for use, reproduction,
  and distribution as defined by Sections 1 through 9 of this document.

  "Licensor" shall mean the copyright owner or entity authorized by
  the copyright owner that is granting the License.

  "Legal Entity" shall mean the union of the acting entity and all
  other entities that control, are controlled by, or are under common
  control with that entity. For the purposes of this definition,
  "control" means (i) the power, direct or indirect, to cause the
  direction or management of such entity, whether by contract or
  otherwise, or (ii) ownership of fifty percent (50%) or more of the
  outstanding shares, or (iii) beneficial ownership of such entity.

  "You" (or "Your") shall mean an individual or Legal Entity
  exercising permissions granted by this License.

  "Source" form shall mean the preferred form for making modifications,
  including but not limited to software source code, documentation
  source, and configuration files.

  "Object" form shall mean any form resulting from mechanical
  transformation or translation of a Source form, including but
  not limited to compiled object code, generated documentation,
  and conversions to other media types.

  "Work" shall mean the work of authorship, whether in Source or
  Object form, made available under the License, as indicated by a
  copyright notice that is included in or attached to the work
  (an example is provided in the Appendix below).

  "Derivative Works" shall mean any work, whether in Source or Object
  form, that is based on (or derived from) the Work and for which the
  editorial revisions, annotations, elaborations, or other modifications
  represent, as a whole, an original work of authorship. For the purposes
  of this License, Derivative Works shall not include works that remain
  separable from, or merely link (or bind by name) to the interfaces of,
  the Work and Derivative Works thereof.

  "Contribution" shall mean any work of authorship, including
  the original version of the Work and any modifications or additions
  to that Work or Derivative Works thereof, that is intentionally
  submitted to Licensor for inclusion in the Work by the copyright owner
  or by an individual or Legal Entity authorized to submit on behalf of
  the copyright owner. For the purposes of this definition, "submitted"
  means any form of electronic, verbal, or written communication sent
  to the Licensor or its representatives, including but not limited to
  communication on electronic mailing lists, source code control systems,
  and issue tracking systems that are managed by, or on behalf of, the
  Licensor for the purpose of discussing and improving the Work, but
  excluding communication that is conspicuously marked or otherwise
  designated in writing by the copyright owner as "Not a Contribution."

  "Contributor" shall mean Licensor and any individual or Legal Entity
  on behalf of whom a Contribution has been received by Licensor and
  subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
  this License, each Contributor hereby grants to You a perpetual,
  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
  copyright license to reproduce, prepare Derivative Works of,
  publicly display, publicly perform, sublicense, and distribute the
  Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
  this License, each Contributor hereby grants to You a perpetual,
  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
  (except as stated in this section) patent license to make, have made,
  use, offer to sell, sell, import, and otherwise transfer the Work,
  where such license applies only to those patent claims licensable
  by such Contributor that are necessarily infringed by their
  Contribution(s) alone or by combination of their Contribution(s)
  with the Work to which such Contribution(s) was submitted. If You
  institute patent litigation against any entity (including a
  cross-claim or counterclaim in a lawsuit) alleging that the Work
  or a Contribution incorporated within the Work constitutes direct
  or contributory patent infringement, then any patent licenses
  granted to You under this License for that Work shall terminate
  as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
  Work or Derivative Works thereof in any medium, with or without
  modifications, and in Source or Object form, provided that You
  meet the following conditions:

  (a) You must give any other recipients of the Work or
      Derivative Works a copy of this License; and

  (b) You must cause any modified files to carry prominent notices
      stating that You changed the files; and

  (c) You must retain, in the Source form of any Derivative Works
      that You distribute, all copyright, patent, trademark, and
      attribution notices from the Source form of the Work,
      excluding those notices that do not pertain to any part of
      the Derivative Works; and

  (d) If the Work includes a "NOTICE" text file as part of its
      distribution, then any Derivative Works that You distribute must
      include a readable copy of the attribution notices contained
      within such NOTICE file, excluding those notices that do not
      pertain to any part of the Derivative Works, in at least one
      of the following places: within a NOTICE text file distributed
      as part of the Derivative Works; within the Source form or
      documentation, if provided along with the Derivative Works; or,
      within a display generated by the Derivative Works, if and
      wherever such third-party notices normally appear. The contents
      of the NOTICE file are for informational purposes only and
      do not modify the License. You may add Your own attribution
      notices within Derivative Works that You distribute, alongside
      or as an addendum to the NOTICE text from the Work, provided
      that such additional attribution notices cannot be construed
      as modifying the License.

  You may add Your own copyright statement to Your modifications and
  may provide additional or different license terms and conditions
  for use, reproduction, or distribution of Your modifications, or
  for any such Derivative Works as a whole, provided Your use,
  reproduction, and distribution of the Work otherwise complies with
  the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
  any Contribution intentionally submitted for inclusion in the Work
  by You to the Licensor shall be under the terms and conditions of
  this License, without any additional terms or conditions.
  Notwithstanding the above, nothing herein shall supersede or modify
  the terms of any separate license agreement you may have executed
  with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
  names, trademarks, service marks, or product names of the Licensor,
  except as required for reasonable and customary use in describing the
  origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
  agreed to in writing, Licensor provides the Work (and each
  Contributor provides its Contributions) on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
  implied, including, without limitation, any warranties or conditions
  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
  PARTICULAR PURPOSE. You are solely responsible for determining the
  appropriateness of using or redistributing the Work and assume any
  risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
  whether in tort (including negligence), contract, or otherwise,
  unless required by applicable law (such as deliberate and grossly
  negligent acts) or agreed to in writing, shall any Contributor be
  liable to You for damages, including any direct, indirect, special,
  incidental, or consequential damages of any character arising as a
  result of this License or out of the use or inability to use the
  Work (including but not limited to damages for loss of goodwill,
  work stoppage, computer failure or malfunction, or any and all
  other commercial damages or losses), even if such Contributor
  has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
  the Work or Derivative Works thereof, You may choose to offer,
  and charge a fee for, acceptance of support, warranty, indemnity,
  or other liability obligations and/or rights consistent with this
  License. However, in accepting such obligations, You may act only
  on Your own behalf and on Your sole responsibility, not on behalf
  of any other Contributor, and only if You agree to indemnify,
  defend, and hold each Contributor harmless for any liability
  incurred by, or claims asserted against, such Contributor by reason
  of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS
</file>

<file path="examples/glaze_http/web/index.mustache">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>System Information</title>
  <link rel="stylesheet" href="/style.css">
</head>

<body>
  <div class="container">
    <h1>Draconis++ System Information</h1>
    <table>
      <tr>
        <th>Property</th>
        <th>Value</th>
      </tr>
      {{#properties}}
      <tr>
        <td class="property-name">{{name}}</td>
        <td>
          {{^hasError}}{{value}}{{/hasError}}
          {{#hasError}}<span class="error">{{error}}</span>{{/hasError}}
        </td>
      </tr>
      {{/properties}}
    </table>
    <footer>Generated by Draconis++ v{{version}}</footer>
  </div>
 </body>

</html>
</file>

<file path="examples/mcp_server/main.cpp">
/**
 * @file main.cpp
 * @brief Draconis++ MCP server example
 *
 * This example demonstrates how to create an MCP server that exposes
 * Draconis++ library functionality via standard input/output, making it
 * compatible with stdio-based MCP clients.
 */

#include <chrono>
#include <cstdlib>
#include <glaze/core/meta.hpp>
#include <glaze/core/read.hpp>
#include <glaze/core/write.hpp>
#include <glaze/glaze.hpp>
#include <glaze/json/json_t.hpp>
#include <glaze/json/read.hpp>
#include <glaze/json/write.hpp>
#include <iostream>
#include <magic_enum/magic_enum.hpp>
#include <matchit.hpp>
#include <utility>

#include <Drac++/Core/System.hpp>
#include <Drac++/Services/Packages.hpp>
#include <Drac++/Services/Weather.hpp>

#include <Drac++/Utils/CacheManager.hpp>
#include <Drac++/Utils/DataTypes.hpp>
#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Types.hpp>

using namespace draconis::utils::types;
using namespace draconis::core::system;
using namespace draconis::services::weather;
using namespace draconis::services::packages;
using enum draconis::utils::error::DracErrorCode;

using GlzArray   = glz::json_t::array_t;
using GlzJson    = glz::json_t;
using GlzObject  = glz::json_t::object_t;
using GlzRawJson = glz::raw_json;
using GlzVal     = glz::json_t::val_t;

struct ToolResponse {
  GlzJson result;
  bool    isError = false;

  ToolResponse() = default;
  ToolResponse(GlzJson result) : result(std::move(result)) {}
  ToolResponse(GlzJson result, bool isError) : result(std::move(result)), isError(isError) {}
};

struct ToolParam {
  String name;
  String description;
  String type     = "string";
  bool   required = false;
};

struct Tool {
  String         name;
  String         description;
  Vec<ToolParam> parameters;

  Tool() = default;
  Tool(String name, String description, Vec<ToolParam> parameters)
    : name(std::move(name)), description(std::move(description)), parameters(std::move(parameters)) {}
  Tool(String name, String description)
    : name(std::move(name)), description(std::move(description)) {}
  Tool(String name, String description, ToolParam parameter)
    : name(std::move(name)), description(std::move(description)), parameters({ std::move(parameter) }) {}
};

struct SystemInfoResponse {
  Option<OSInfo>   operatingSystem;
  Option<String>   kernelVersion;
  Option<String>   host;
  Option<String>   shell;
  Option<String>   desktopEnv;
  Option<String>   windowMgr;
  Option<String>   cpuModel;
  Option<CPUCores> cpuCores;
};

struct HardwareInfoResponse {
  Option<String>        cpuModel;
  Option<CPUCores>      cpuCores;
  Option<String>        gpuModel;
  Option<ResourceUsage> memInfo;
  Option<ResourceUsage> diskUsage;
};

struct NetworkInfoResponse {
  Option<Vec<NetworkInterface>> interfaces;
  Option<NetworkInterface>      primaryInterface;
};

struct DisplayInfoResponse {
  Option<Vec<DisplayInfo>> displays;
  Option<DisplayInfo>      primaryDisplay;
};

struct UptimeInfoResponse {
  u32    seconds;
  String formatted;
};

struct ComprehensiveInfo {
  SystemInfoResponse       system;
  HardwareInfoResponse     hardware;
  NetworkInfoResponse      network;
  DisplayInfoResponse      display;
  UptimeInfoResponse       uptime;
  Option<Report>           weather;
  Option<Map<String, u64>> packages;
  Option<MediaInfo>        nowPlaying;
};

namespace glz {
  template <>
  struct meta<ToolResponse> {
    using T = ToolResponse;

    // clang-format off
    static constexpr detail::Object value = object(
      "result",  &T::result,
      "isError", &T::isError
    );
    // clang-format on
  };

  template <>
  struct meta<ToolParam> {
    using T = ToolParam;

    // clang-format off
    static constexpr detail::Object value = object(
      "name",        &T::name,
      "description", &T::description,
      "required",    &T::required,
      "type",        &T::type
    );
    // clang-format on
  };

  template <>
  struct meta<Tool> {
    using T = Tool;

    // clang-format off
    static constexpr detail::Object value = object(
      "name",        &T::name,
      "description", &T::description,
      "parameters",  &T::parameters
    );
    // clang-format on
  };

  template <>
  struct meta<SystemInfoResponse> {
    using T = SystemInfoResponse;

    // clang-format off
    static constexpr detail::Object value = object(
      "operatingSystem", &T::operatingSystem,
      "kernelVersion",   &T::kernelVersion,
      "host",            &T::host,
      "shell",           &T::shell,
      "desktopEnv",      &T::desktopEnv,
      "windowMgr",       &T::windowMgr,
      "cpuModel",        &T::cpuModel,
      "cpuCores",        &T::cpuCores
    );
    // clang-format on
  };

  template <>
  struct meta<HardwareInfoResponse> {
    using T = HardwareInfoResponse;

    // clang-format off
    static constexpr detail::Object value = object(
      "cpuModel",  &T::cpuModel,
      "cpuCores",  &T::cpuCores,
      "gpuModel",  &T::gpuModel,
      "memInfo",   &T::memInfo,
      "diskUsage", &T::diskUsage
    );
    // clang-format on
  };

  template <>
  struct meta<NetworkInfoResponse> {
    using T = NetworkInfoResponse;

    // clang-format off
    static constexpr detail::Object value = object(
      "interfaces",       &T::interfaces,
      "primaryInterface", &T::primaryInterface
    );
    // clang-format on
  };

  template <>
  struct meta<DisplayInfoResponse> {
    using T = DisplayInfoResponse;

    // clang-format off
    static constexpr detail::Object value = object(
      "displays",       &T::displays,
      "primaryDisplay", &T::primaryDisplay
    );
    // clang-format on
  };

  template <>
  struct meta<UptimeInfoResponse> {
    using T = UptimeInfoResponse;

    // clang-format off
    static constexpr detail::Object value = object(
      "seconds",   &T::seconds,
      "formatted", &T::formatted
    );
    // clang-format on
  };

  template <>
  struct meta<ComprehensiveInfo> {
    using T = ComprehensiveInfo;

    // clang-format off
    static constexpr detail::Object value = object(
      "system",     &T::system,
      "hardware",   &T::hardware,
      "network",    &T::network,
      "display",    &T::display,
      "uptime",     &T::uptime,
      "weather",    &T::weather,
      "packages",   &T::packages,
      "nowPlaying", &T::nowPlaying
    );
    // clang-format on
  };

  template <>
  struct meta<MediaInfo> {
    using T = MediaInfo;

    // clang-format off
    static constexpr detail::Object value = object(
      "title",  &T::title,
      "artist", &T::artist
    );
    // clang-format on
  };

  template <>
  struct meta<ResourceUsage> {
    using T = ResourceUsage;

    // clang-format off
    static constexpr detail::Object value = object(
      "usedBytes",  &T::usedBytes,
      "totalBytes", &T::totalBytes
    );
    // clang-format on
  };
} // namespace glz

namespace {
  using ToolHandler        = Fn<ToolResponse(const Map<String, String>&)>;
  using NoParamToolHandler = Fn<ToolResponse()>;

  fn GetCacheManager() -> CacheManager& {
    static CacheManager CacheManager;
    return CacheManager;
  }

  template <typename T>
  fn resultToJson(const Result<T>& result) -> GlzJson {
    if (result)
      return *result;

    return {
      { "error", result.error().message }
    };
  }

  template <typename T>
  fn serializeToJson(const T& obj) -> GlzJson {
    String jsonStr;

    if (glz::error_ctx errc = glz::write_json(obj, jsonStr); !errc) {
      GlzJson jsonVal;

      if (!glz::read_json(jsonVal, jsonStr))
        return jsonVal;
    }

    return {
      { "error", "Failed to serialize result" }
    };
  }

  fn makeErrorResult(StringView message, i32 code = -1) -> GlzJson {
    return {
      { "error", { { "message", String(message) }, { "code", code } } }
    };
  }

  template <typename T>
  fn makeSuccessResult(const T& data) -> GlzJson {
    return {
      { "data", serializeToJson(data) }
    };
  }

  fn SystemInfoHandler() -> ToolResponse {
    CacheManager& cacheManager = GetCacheManager();

    SystemInfoResponse info;

    if (Result res = GetOperatingSystem(cacheManager); res)
      info.operatingSystem = *res;
    if (Result res = GetKernelVersion(cacheManager); res)
      info.kernelVersion = *res;
    if (Result res = GetHost(cacheManager); res)
      info.host = *res;
    if (Result res = GetShell(cacheManager); res)
      info.shell = *res;
    if (Result res = GetDesktopEnvironment(cacheManager); res)
      info.desktopEnv = *res;
    if (Result res = GetWindowManager(cacheManager); res)
      info.windowMgr = *res;
    if (Result res = GetCPUModel(cacheManager); res)
      info.cpuModel = *res;
    if (Result res = GetCPUCores(cacheManager); res)
      info.cpuCores = *res;

    return { makeSuccessResult(info) };
  }

  fn HardwareInfoHandler() -> ToolResponse {
    CacheManager& cacheManager = GetCacheManager();

    HardwareInfoResponse info;

    if (Result res = GetCPUModel(cacheManager); res)
      info.cpuModel = *res;
    if (Result res = GetCPUCores(cacheManager); res)
      info.cpuCores = *res;
    if (Result res = GetGPUModel(cacheManager); res)
      info.gpuModel = *res;
    if (Result res = GetMemInfo(cacheManager); res)
      info.memInfo = *res;
    if (Result res = GetDiskUsage(cacheManager); res)
      info.diskUsage = *res;

    return { makeSuccessResult(info) };
  }

  fn WeatherHandler(const Map<String, String>& params) -> ToolResponse {
#if DRAC_ENABLE_WEATHER
    Result<Coords> coordsResult;
    String         location;

    auto iter = params.find("location");

    if (iter != params.end() && !iter->second.empty()) {
      location     = iter->second;
      coordsResult = Geocode(location);
      if (!coordsResult)
        return { makeErrorResult("Failed to geocode location '" + location + "': " + coordsResult.error().message), true };
    } else {
      Result locationInfoResult = GetCurrentLocationInfoFromIP();
      if (!locationInfoResult)
        return { makeErrorResult("Failed to get current location from IP: " + locationInfoResult.error().message), true };

      const IPLocationInfo& locationInfo = *locationInfoResult;
      coordsResult                       = locationInfo.coords;
      location                           = locationInfo.locationName;
    }

    UniquePointer<IWeatherService> weatherService = CreateWeatherService(
      Provider::MetNo, *coordsResult, UnitSystem::Imperial
    );

    if (!weatherService)
      return { makeErrorResult("Failed to create weather service"), true };

    String         weatherCacheKey = "weather_" + location;
    Result<Report> weatherResult   = GetCacheManager().getOrSet<Report>(
      weatherCacheKey, [&]() -> Result<Report> { return weatherService->getWeatherInfo(); }
    );

    if (!weatherResult)
      return { makeErrorResult("Failed to fetch weather data: " + weatherResult.error().message), true };

    return { makeSuccessResult(*weatherResult) };
#else
    return { makeErrorResult("Weather service not enabled in this build"), true };
#endif
  }

  fn PackageCountHandler(const Map<String, String>& params) -> ToolResponse {
#if DRAC_ENABLE_PACKAGECOUNT
    using enum Manager;

    Manager enabledManagers = NONE;

    static const UnorderedMap<String, Manager> MANAGER_MAP = {
      {  "cargo",  CARGO },
  #if defined(__linux__) || defined(__APPLE__)
      {    "nix",    NIX },
  #endif
  #ifdef __linux__
      {    "apk",    APK },
      {   "dpkg",   DPKG },
      {   "moss",   MOSS },
      { "pacman", PACMAN },
      {    "rpm",    RPM },
      {   "xbps",   XBPS },
  #elifdef __APPLE__
      { "homebrew", HOMEBREW },
      { "macports", MACPORTS },
  #elifdef _WIN32
      { "winget", WINGET },
      { "chocolatey", CHOCOLATEY },
      { "scoop", SCOOP },
  #elif defined(__FreeBSD__) || defined(__DragonFly__)
      { "pkgng", PKGNG },
  #elifdef __NetBSD__
      { "pkgsrc", PKGSRC },
  #elifdef __HAIKU__
      { "haikupkg", HAIKUPKG },
  #endif
    };

    auto mgrIter = params.find("managers");

    if (mgrIter != params.end() && !mgrIter->second.empty()) {
      String      managersStr = mgrIter->second;
      Vec<String> managersList;

      managersList.reserve(std::count(managersStr.begin(), managersStr.end(), ',') + 1);
      usize pos = 0;

      while ((pos = managersStr.find(',')) != String::npos) {
        managersList.emplace_back(managersStr.substr(0, pos));
        managersStr.erase(0, pos + 1);
      }

      managersList.emplace_back(managersStr);

      for (const String& mgr : managersList) {
        auto iter = MANAGER_MAP.find(mgr);

        if (iter != MANAGER_MAP.end())
          enabledManagers |= iter->second;
      }
    } else {
      for (const auto& [_, value] : MANAGER_MAP)
        enabledManagers |= value;
    }

    if (enabledManagers == NONE)
      return { makeErrorResult("No valid package managers specified or available"), true };

    Result<Map<String, u64>> countResult = GetIndividualCounts(GetCacheManager(), enabledManagers);
    if (!countResult)
      return { makeErrorResult("Failed to get package count: " + countResult.error().message), true };

    return { makeSuccessResult(*countResult) };
#else
    return { makeErrorResult("Package counting not enabled in this build"), true };
#endif
  }

  fn NetworkInfoHandler() -> ToolResponse {
    CacheManager& cacheManager = GetCacheManager();

    NetworkInfoResponse info;
    if (Result res = GetNetworkInterfaces(cacheManager); res)
      info.interfaces = *res;
    if (Result res = GetPrimaryNetworkInterface(cacheManager); res)
      info.primaryInterface = *res;

    return { makeSuccessResult(info) };
  }

  fn DisplayInfoHandler() -> ToolResponse {
    CacheManager& cacheManager = GetCacheManager();

    DisplayInfoResponse info;
    if (Result<Vec<DisplayInfo>> res = GetOutputs(cacheManager); res)
      info.displays = *res;
    if (Result<DisplayInfo> res = GetPrimaryOutput(cacheManager); res)
      info.primaryDisplay = *res;

    if (info.displays->empty())
      return { makeErrorResult("No displays found"), true };

    return { makeSuccessResult(info) };
  }

  fn UptimeHandler() -> ToolResponse {
    Result<std::chrono::seconds> uptimeResult = GetUptime();
    if (!uptimeResult)
      return { makeErrorResult("Failed to get uptime: " + uptimeResult.error().message), true };

    u32 seconds          = uptimeResult->count();
    u32 hours            = seconds / 3600;
    u32 minutes          = (seconds % 3600) / 60;
    u32 remainingSeconds = seconds % 60;

    UptimeInfoResponse info { .seconds = seconds, .formatted = std::format("{}h {}m {}s", hours, minutes, remainingSeconds) };
    return { makeSuccessResult(info) };
  }

  fn NowPlayingHandler() -> ToolResponse {
#if DRAC_ENABLE_NOWPLAYING
    Result nowPlayingResult = GetNowPlaying();
    if (!nowPlayingResult)
      return { makeErrorResult("Failed to get now playing info: " + nowPlayingResult.error().message), true };

    return { makeSuccessResult(*nowPlayingResult) };
#else
    return { makeErrorResult("Now playing functionality not enabled in this build"), true };
#endif
  }

  fn ComprehensiveInfoHandler(const Map<String, String>& params) -> ToolResponse {
    CacheManager& cacheManager = GetCacheManager();

    ComprehensiveInfo info;

    if (Result res = GetOperatingSystem(cacheManager); res)
      info.system.operatingSystem = *res;
    if (Result res = GetKernelVersion(cacheManager); res)
      info.system.kernelVersion = *res;
    if (Result res = GetHost(cacheManager); res)
      info.system.host = *res;
    if (Result res = GetShell(cacheManager); res)
      info.system.shell = *res;
    if (Result res = GetDesktopEnvironment(cacheManager); res)
      info.system.desktopEnv = *res;
    if (Result res = GetWindowManager(cacheManager); res)
      info.system.windowMgr = *res;

    if (Result res = GetCPUModel(cacheManager); res)
      info.hardware.cpuModel = *res;
    if (Result res = GetCPUCores(cacheManager); res)
      info.hardware.cpuCores = *res;
    if (Result res = GetGPUModel(cacheManager); res)
      info.hardware.gpuModel = *res;
    if (Result res = GetMemInfo(cacheManager); res)
      info.hardware.memInfo = *res;
    if (Result res = GetDiskUsage(cacheManager); res)
      info.hardware.diskUsage = *res;

    if (Result res = GetNetworkInterfaces(cacheManager); res)
      info.network.interfaces = *res;
    if (Result res = GetPrimaryNetworkInterface(cacheManager); res)
      info.network.primaryInterface = *res;

    if (Result res = GetOutputs(cacheManager); res)
      info.display.displays = *res;
    if (Result res = GetPrimaryOutput(cacheManager); res)
      info.display.primaryDisplay = *res;

    if (Result res = GetUptime(); res) {
      u32 seconds          = res->count();
      u32 hours            = seconds / 3600;
      u32 minutes          = (seconds % 3600) / 60;
      u32 remainingSeconds = seconds % 60;
      info.uptime          = { .seconds = seconds, .formatted = std::format("{}h {}m {}s", hours, minutes, remainingSeconds) };
    }

#if DRAC_ENABLE_WEATHER
    auto locIter = params.find("location");
    if (locIter != params.end() && !locIter->second.empty()) {
      if (Result coords = Geocode(locIter->second); coords)
        if (UniquePointer<IWeatherService> weatherService = CreateWeatherService(Provider::MetNo, *coords, UnitSystem::Imperial)) {
          String weatherCacheKey = "weather_" + locIter->second;
          if (Result weather = cacheManager.getOrSet<Report>(weatherCacheKey, [&]() -> Result<Report> { return weatherService->getWeatherInfo(); }); weather)
            info.weather = *weather;
        }
    } else if (Result locationInfo = GetCurrentLocationInfoFromIP(); locationInfo)
      if (UniquePointer<IWeatherService> weatherService = CreateWeatherService(Provider::MetNo, locationInfo->coords, UnitSystem::Imperial)) {
        String weatherCacheKey = "weather_" + locationInfo->locationName;
        if (
          Result weather = cacheManager.getOrSet<Report>(
            weatherCacheKey,
            [&]() -> Result<Report> {
              return weatherService->getWeatherInfo();
            }
          );
          weather
        )
          info.weather = *weather;
      }
#endif

#if DRAC_ENABLE_PACKAGECOUNT
    using enum Manager;

    Manager enabledManagers = CARGO;
  #if defined(__linux__) || defined(__APPLE__)
    enabledManagers |= NIX;
  #endif
  #ifdef __linux__
    enabledManagers |= APK | DPKG | MOSS | PACMAN | RPM | XBPS;
  #elifdef __APPLE__
    enabledManagers |= HOMEBREW | MACPORTS;
  #elifdef _WIN32
    enabledManagers |= WINGET | CHOCOLATEY | SCOOP;
  #elif defined(__FreeBSD__) || defined(__DragonFly__)
    enabledManagers |= PKGNG;
  #elifdef __NetBSD__
    enabledManagers |= PKGSRC;
  #elifdef __HAIKU__
    enabledManagers |= HAIKUPKG;
  #endif
    if (Result packages = GetIndividualCounts(cacheManager, enabledManagers); packages)
      info.packages = *packages;
#endif

#if DRAC_ENABLE_NOWPLAYING
    if (Result nowPlaying = GetNowPlaying(); nowPlaying)
      info.nowPlaying = *nowPlaying;
#endif

    return { makeSuccessResult(info) };
  }

  fn CacheClearHandler() -> ToolResponse {
    return { makeSuccessResult(std::format("Removed {} files.", GetCacheManager().invalidateAll(false))) };
  }
} // namespace

class DracStdioServer {
 public:
  DracStdioServer(String name, String version)
    : m_name(std::move(name)), m_version(std::move(version)) {}

  fn setCapabilities(const GlzObject& capabilities) -> void {
    m_capabilities = capabilities;
  }

  fn registerTool(const Tool& tool, const ToolHandler& handler) -> void {
    m_tools[tool.name] = { tool, handler };
  }

  fn registerTool(const Tool& tool, const NoParamToolHandler& handler) -> void {
    m_tools[tool.name] = { tool, [handler](const Map<String, String>&) -> ToolResponse { return handler(); } };
  }

  fn run() -> Result<> {
    String line;

    while (std::getline(std::cin, line)) {
      if (line.empty())
        continue;

      GlzObject requestJson;

      glz::error_ctx errc = glz::read_json(requestJson, line);

      if (errc) {
        std::cerr << "Failed to parse input: " << glz::format_error(errc, line) << '\n';
        continue;
      }

      String method = requestJson.contains("method") ? requestJson["method"].get<String>() : "";

      GlzJson params = requestJson.contains("params") ? requestJson["params"] : GlzJson {};

      String jsonrpc = requestJson.contains("jsonrpc") ? requestJson["jsonrpc"].get<String>() : "2.0";

      try {
        Result result = processRequest(method, params);

        if (requestJson.contains("id")) {
          GlzJson idVal = requestJson["id"];

          GlzObject response;
          response["jsonrpc"] = jsonrpc;
          response["id"]      = idVal;

          if (result) {
            response["result"] = *result;
          } else {
            response["error"] = GlzObject {
              {    "code",                                              -32603 },
              { "message", "Internal error: " + String(result.error().message) }
            };
          }

          String responseStr;
          if (glz::error_ctx errc = glz::write_json(response, responseStr); errc)
            ERR_FMT(ParseError, "Failed to serialize response: {}", glz::format_error(errc, responseStr));

          std::cout << responseStr << '\n';
          std::cout.flush();
        }
      } catch (const Exception& e) {
        if (requestJson.contains("id")) {
          GlzJson idVal = requestJson["id"];

          GlzObject response;
          response["jsonrpc"] = jsonrpc;
          response["id"]      = idVal;
          response["error"]   = GlzObject {
              {    "code",                                -32603 },
              { "message", "Internal error: " + String(e.what()) }
          };

          String responseStr;
          if (glz::error_ctx errc = glz::write_json(response, responseStr); errc)
            ERR_FMT(ParseError, "Failed to serialize error response: {}", glz::format_error(errc, responseStr));

          std::cout << responseStr << '\n';
          std::cout.flush();
        } else {
          std::cerr << "Internal error: " << e.what() << '\n';
        }
      }
    }
    return {};
  }

 private:
  using Tools = Map<String, Pair<Tool, ToolHandler>>;

  String    m_name;
  String    m_version;
  GlzObject m_capabilities;
  Tools     m_tools;

  fn processRequest(const String& method, const GlzJson& params) -> Result<GlzJson> {
    if (method == "initialize") {
      return GlzObject {
        { "protocolVersion",                                               "2025-06-18" },
        {    "capabilities",                                             m_capabilities },
        {      "serverInfo", GlzObject { { "name", m_name }, { "version", m_version } } }
      };
    }

    if (method == "tools/list") {
      GlzArray toolsArray;
      toolsArray.reserve(m_tools.size());

      for (const auto& [_, toolPair] : m_tools) {
        GlzObject toolObj;
        toolObj["name"]        = toolPair.first.name;
        toolObj["description"] = toolPair.first.description;

        GlzObject inputSchema;
        inputSchema["type"] = "object";
        GlzObject inputProperties;
        GlzArray  inputRequired;

        for (const ToolParam& param : toolPair.first.parameters) {
          inputProperties[param.name] = GlzObject {
            { "title", param.name },
            {  "type", param.type },
          };

          if (param.required)
            inputRequired.emplace_back(param.name);
        }

        inputSchema["properties"] = inputProperties;
        inputSchema["required"]   = inputRequired;
        inputSchema["title"]      = toolPair.first.name + "Arguments";

        GlzObject outputSchema = {
          {       "type",                                                                                                                   "object" },
          { "properties", { { "data", { { "title", "Data" }, { "type", "object" } } }, { "error", { { "title", "Error" }, { "type", "object" } } } } },
          {      "title",                                                                                             toolPair.first.name + "Output" },
        };

        toolObj["inputSchema"]  = inputSchema;
        toolObj["outputSchema"] = outputSchema;
        toolsArray.emplace_back(toolObj);
      }

      return GlzObject {
        { "tools", toolsArray }
      };
    }

    if (method == "tools/call") {
      if (!params.contains("name"))
        ERR(InvalidArgument, "Missing tool name");

      String toolName = params["name"].get<String>();

      auto iter = m_tools.find(toolName);

      if (iter == m_tools.end())
        ERR_FMT(NotFound, "Tool not found: {}", toolName);

      Map<String, String> arguments;

      if (params.contains("arguments")) {
        const GlzJson& args = params["arguments"];

        if (args.is_object())
          for (const auto& [key, value] : args.get<GlzObject>()) {
            if (value.is_string())
              arguments[key] = value.get<String>();
            else
              ERR_FMT(InvalidArgument, "Argument '{}' must be a string", key);
          }
      }

      ToolResponse result = iter->second.second(arguments);

      GlzObject out {
        { "structuredContent", { { "result", result.result }, { "isError", result.isError } } }
      };

      String outStr;

      if (!result.result.is_string()) {
        if (glz::error_ctx errc = glz::write_json(result.result, outStr); errc)
          ERR_FMT(ParseError, "Failed to serialize result: {}", glz::format_error(errc, outStr));
      } else
        outStr = result.result.get<String>();

      GlzArray contentArr;

      contentArr.emplace_back(GlzObject {
        { "type", "text" },
        { "text", outStr },
      });

      out["content"] = contentArr;

      return out;
    }

    if (method == "resources/list")
      return GlzObject {
        { "resources", GlzArray() }
      };

    if (method == "prompts/list")
      return GlzObject {
        { "prompts", GlzArray() }
      };

    if (method == "ping" || method == "notifications/initialized")
      return GlzObject();

    ERR_FMT(NotSupported, "Unknown method: {}", method);
  }
};

fn main() -> i32 {
  DracStdioServer server("Draconis++ MCP Server", DRAC_VERSION);

  server.setCapabilities({
    { "tools", { { "listChanged", true } } }
  });

  Tool cacheClearTool("cache_clear", "Clear all cached data");
  Tool systemInfoTool("system_info", "Get system information (OS, kernel, host, shell, desktop environment, window manager)");
  Tool hardwareInfoTool("hardware_info", "Get hardware information (CPU, GPU, memory, disk, battery)");
  Tool networkInfoTool("network_info", "Get network interface information");
  Tool displayInfoTool("display_info", "Get display/monitor information");
  Tool uptimeTool("uptime", "Get system uptime");
  Tool nowPlayingTool("now_playing", "Get currently playing media information (title and artist)");

  Tool weatherTool(
    "weather",
    "Get current weather information. If no location is specified, automatically detects your current location from IP address.",
    ToolParam("location", "Location name (e.g., 'New York, NY', 'London, UK', 'Tokyo, Japan'). Omit this parameter to use your current location.")
  );

  Tool packageCountTool(
    "package_count",
    "Get individual package counts from available package managers",
    ToolParam("managers", "Comma-separated list of package managers to check (e.g., 'pacman,dpkg,cargo'). Omit this parameter to check all available package managers.")
  );

  Tool comprehensiveTool(
    "comprehensive_info",
    "Get all system information at once (system, hardware, network, display, uptime, weather, individual package counts)",
    ToolParam("location", "Location name for weather information (e.g., 'New York, NY', 'London, UK'). Omit this parameter to use your current location for weather.")
  );

  server.registerTool(cacheClearTool, CacheClearHandler);
  server.registerTool(systemInfoTool, SystemInfoHandler);
  server.registerTool(hardwareInfoTool, HardwareInfoHandler);
  server.registerTool(weatherTool, WeatherHandler);
  server.registerTool(packageCountTool, PackageCountHandler);
  server.registerTool(networkInfoTool, NetworkInfoHandler);
  server.registerTool(displayInfoTool, DisplayInfoHandler);
  server.registerTool(uptimeTool, UptimeHandler);
  server.registerTool(nowPlayingTool, NowPlayingHandler);
  server.registerTool(comprehensiveTool, ComprehensiveInfoHandler);

  Result res = server.run();

  if (res)
    return EXIT_SUCCESS;

  std::cerr << "Error: " << res.error().message << '\n';
  return EXIT_FAILURE;
}
</file>

<file path="examples/switch_app/main.cpp">
#ifdef __SWITCH__

  #include <switch.h>
  #include <switch/kernel/detect.h>
  #include <switch/services/nifm.h>
  #include <switch/services/set.h>
  #include <switch/services/spl.h>
  #include <switch/services/time.h>

  #include <Drac++/Core/System.hpp>
  #include <Drac++/Services/Weather.hpp>

  #include <Drac++/Utils/CacheManager.hpp>

auto main() -> s32 {
  consoleInit(nullptr);
  Result timeRes = timeInitialize();
  if (R_FAILED(timeRes))
    return static_cast<s32>(timeRes);

  // Initialize network for weather services
  #if DRAC_ENABLE_WEATHER
  Result nifmRes = nifmInitialize(NifmServiceType_User);
  if (R_FAILED(nifmRes)) {
    std::println("Failed to initialize network: 0x{:08X}", nifmRes);
    // Continue without network - weather will fail gracefully
  }
  #endif

  padConfigureInput(1, HidNpadStyleSet_NpadStandard);

  PadState pad;
  padInitializeDefault(&pad);

  draconis::utils::cache::CacheManager cache;

  // Initialize weather service (using MetNo provider, coordinates for Tokyo, metric units)
  draconis::services::weather::UniquePointer<draconis::services::weather::IWeatherService> weatherService;
  #if DRAC_ENABLE_WEATHER
  weatherService = draconis::services::weather::CreateWeatherService(
    draconis::services::weather::Provider::MetNo,
    draconis::services::weather::Coords(35.6762, 139.6503), // Tokyo coordinates
    draconis::services::weather::UnitSystem::Metric
  );
  #endif

  using draconis::core::system::GetBatteryInfo;
  using draconis::core::system::GetCPUCores;
  using draconis::core::system::GetCPUModel;
  using draconis::core::system::GetGPUModel;
  using draconis::core::system::GetKernelVersion;
  using draconis::core::system::GetOperatingSystem;

  if (auto osRes = GetOperatingSystem(cache); osRes)
    std::println("\x1b[1;0HFirmware: {} {}", osRes->name, osRes->version);
  else
    std::println("Failed to get firmware version: {}", osRes.error().message);

  if (auto cpuModel = GetCPUModel(cache); cpuModel)
    std::println("\x1b[2;0HCPU Model: {}", *cpuModel);
  else
    std::println("Failed to get CPU model: {}", cpuModel.error().message);

  if (auto cores = GetCPUCores(cache); cores)
    std::println("\x1b[3;0HCPU Cores available: {}", cores->logical);
  else
    std::println("Failed to get CPU cores: {}", cores.error().message);

  if (auto kernel = GetKernelVersion(cache); kernel)
    std::println("\x1b[4;0HKernel: {}", *kernel);
  else
    std::println("Failed to get kernel version: {}", kernel.error().message);

  if (auto gpu = GetGPUModel(cache); gpu)
    std::println("\x1b[5;0HGPU: {}", *gpu);
  else
    std::println("Failed to get GPU model: {}", gpu.error().message);

  u64       frameCounter      = 0;
  const u64 FRAMES_PER_UPDATE = 60;

  // Weather cache variables
  std::optional<draconis::services::weather::Report> cachedWeather;
  u64                                                lastWeatherCheck        = 0;
  const u64                                          WEATHER_UPDATE_INTERVAL = 600; // Update weather every 10 seconds (600 frames at 60fps)

  while (appletMainLoop()) {
    padUpdate(&pad);

    u64 kDown = padGetButtonsDown(&pad);

    if ((kDown & HidNpadButton_Plus) != 0)
      break;

    if (frameCounter % FRAMES_PER_UPDATE == 0) {
      u64 currentTime = 0;
      if (R_SUCCEEDED(timeGetCurrentTime(TimeType_UserSystemClock, &currentTime))) {
        TimeCalendarTime cal = {};
        if (R_SUCCEEDED(timeToCalendarTimeWithMyRule(currentTime, &cal, nullptr)))
          std::println("\x1b[11;0HDate/Time: {:04}-{:02}-{:02} {:02}:{:02}:{:02}", cal.year, cal.month, cal.day, cal.hour, cal.minute, cal.second);

        if (auto mem = draconis::core::system::GetMemInfo(cache); mem)
          std::println("\x1b[10;0HMemory usage: {:.2f} MiB", static_cast<double>(mem->usedBytes) / (1024.0 * 1024.0));

        if (auto bat = GetBatteryInfo(cache); bat) {
          using enum draconis::utils::types::Battery::Status;

          const char* statusStr = "Unknown";

          switch (bat->status) {
            case Charging:
              statusStr = "Charging";
              break;
            case Discharging:
              statusStr = "Discharging";
              break;
            case Full:
              statusStr = "Full";
              break;
            case NotPresent:
              statusStr = "N/A";
              break;
            default:
              break;
          }

          if (bat->percentage)
            std::println("\x1b[12;0HBattery: {}% ({})   ", *bat->percentage, statusStr);
          else
            std::println("\x1b[12;0HBattery: -- ({})   ", statusStr);
        } else
          std::println("\x1b[12;0HBattery: Error ({})   ", bat.error().message);

        // Weather display logic
  #if DRAC_ENABLE_WEATHER
        if (weatherService && (frameCounter - lastWeatherCheck >= WEATHER_UPDATE_INTERVAL || !cachedWeather)) {
          if (auto weatherResult = weatherService->getWeatherInfo(); weatherResult) {
            cachedWeather    = *weatherResult;
            lastWeatherCheck = frameCounter;
          }
        }

        if (cachedWeather) {
          std::println("\x1b[13;0HWeather: {:.1f}°C, {}", cachedWeather->temperature, cachedWeather->description);
        } else {
          std::println("\x1b[13;0HWeather: No data available");
        }
  #else
        std::println("\x1b[13;0HWeather: Not enabled");
  #endif
      }
    }

    frameCounter++;
    consoleUpdate(nullptr);
  }

  consoleExit(nullptr);
  timeExit();

  #if DRAC_ENABLE_WEATHER
  nifmExit();
  #endif

  return 0;
}

#endif
</file>

<file path="nix/default.nix">
{
  nixpkgs,
  self,
  system,
  lib,
  devkitNix ? null,
  ...
}: let
  pkgs = import nixpkgs {
    inherit system;
    overlays = lib.optional (devkitNix != null) devkitNix.overlays.default;
  };

  dracPackages = import ./package.nix {inherit pkgs self lib;};

  muslPackages =
    if pkgs.stdenv.isLinux
    then import ./musl.nix {inherit pkgs nixpkgs self lib;}
    else {};
in
  dracPackages
  // muslPackages
  // {default = dracPackages."generic";}
</file>

<file path="src/CLI/UI/AsciiArt.hpp">
#pragma once

#include <Drac++/Core/System.hpp>

#include <Drac++/Utils/CacheManager.hpp>
#include <Drac++/Utils/Types.hpp>

namespace draconis::ui::ascii {
  namespace {
    using utils::types::Array;
    using utils::types::Pair;
    using utils::types::Result;
    using utils::types::String;
    using utils::types::StringView;
    using utils::types::usize;
    using utils::types::Vec;
  } // namespace

  namespace logos {
    constexpr StringView NIXOS =
      "\033[1m\033[38;5;12m          ▗▄▄▄       \033[38;5;14m▗▄▄▄▄    ▄▄▄▖\n"
      "\033[1m\033[38;5;12m          ▜███▙       \033[38;5;14m▜███▙  ▟███▛\n"
      "\033[1m\033[38;5;12m           ▜███▙       \033[38;5;14m▜███▙▟███▛\n"
      "\033[1m\033[38;5;12m            ▜███▙       \033[38;5;14m▜██████▛\n"
      "\033[1m\033[38;5;12m     ▟█████████████████▙ \033[38;5;14m▜████▛     \033[38;5;12m▟▙\n"
      "\033[1m\033[38;5;12m    ▟███████████████████▙ \033[38;5;14m▜███▙    \033[38;5;12m▟██▙\n"
      "\033[1m\033[38;5;14m           ▄▄▄▄▖           ▜███▙  \033[38;5;12m▟███▛\n"
      "\033[1m\033[38;5;14m          ▟███▛             ▜██▛ \033[38;5;12m▟███▛\n"
      "\033[1m\033[38;5;14m         ▟███▛               ▜▛ \033[38;5;12m▟███▛\n"
      "\033[1m\033[38;5;14m▟███████████▛                  \033[38;5;12m▟██████████▙\n"
      "\033[1m\033[38;5;14m▜██████████▛                  \033[38;5;12m▟███████████▛\n"
      "\033[1m\033[38;5;14m      ▟███▛ \033[38;5;12m▟▙               ▟███▛\n"
      "\033[1m\033[38;5;14m     ▟███▛ \033[38;5;12m▟██▙             ▟███▛\n"
      "\033[1m\033[38;5;14m    ▟███▛  \033[38;5;12m▜███▙           ▝▀▀▀▀\n"
      "\033[1m\033[38;5;14m    ▜██▛    \033[38;5;12m▜███▙ \033[38;5;14m▜██████████████████▛\n"
      "\033[1m\033[38;5;14m     ▜▛     \033[38;5;12m▟████▙ \033[38;5;14m▜████████████████▛\n"
      "\033[1m\033[38;5;12m           ▟██████▙       \033[38;5;14m▜███▙\n"
      "\033[1m\033[38;5;12m          ▟███▛▜███▙       \033[38;5;14m▜███▙\n"
      "\033[1m\033[38;5;12m         ▟███▛  ▜███▙       \033[38;5;14m▜███▙\n"
      "\033[1m\033[38;5;12m         ▝▀▀▀    ▀▀▀▀▘       \033[38;5;14m▀▀▀▘\033[0m";

    constexpr StringView MACOS =
      "\033[1m\033[38;5;10m                     ..'\n"
      "\033[1m\033[38;5;10m                 ,xNMM.\n"
      "\033[1m\033[38;5;10m               .OMMMMo\n"
      "\033[1m\033[38;5;10m               lMM\"\n"
      "\033[1m\033[38;5;10m     .;loddo:.  .olloddol;.\n"
      "\033[1m\033[38;5;10m   cKMMMMMMMMMMNWMMMMMMMMMM0:\n"
      "\033[1m\033[38;5;11m .KMMMMMMMMMMMMMMMMMMMMMMMWd.\n"
      "\033[1m\033[38;5;11m XMMMMMMMMMMMMMMMMMMMMMMMX.\n"
      "\033[1m\033[38;5;9m;MMMMMMMMMMMMMMMMMMMMMMMM:\n"
      "\033[1m\033[38;5;9m:MMMMMMMMMMMMMMMMMMMMMMMM:\n"
      "\033[1m\033[38;5;9m.MMMMMMMMMMMMMMMMMMMMMMMMX.\n"
      "\033[1m\033[38;5;9m kMMMMMMMMMMMMMMMMMMMMMMMMWd.\n"
      "\033[1m\033[38;5;13m 'XMMMMMMMMMMMMMMMMMMMMMMMMMMk\n"
      "\033[1m\033[38;5;13m  'XMMMMMMMMMMMMMMMMMMMMMMMMK.\n"
      "\033[1m\033[38;5;12m    kMMMMMMMMMMMMMMMMMMMMMMd\n"
      "\033[1m\033[38;5;12m     ;KMMMMMMMWXXWMMMMMMMk.\n"
      "\033[1m\033[38;5;12m       \"cooc*\"    \"*coo'\"\033[0m";

    constexpr StringView UBUNTU =
      "\033[1m\033[38;5;9m                             ....\n"
      "\033[1m\033[38;5;9m              .',:clooo:  .:looooo:.\n"
      "\033[1m\033[38;5;9m           .;looooooooc  .oooooooooo'\n"
      "\033[1m\033[38;5;9m        .;looooool:,'''.  :ooooooooooc\n"
      "\033[1m\033[38;5;9m       ;looool;.         'oooooooooo,\n"
      "\033[1m\033[38;5;9m      ;clool'             .cooooooc.  ,,\n"
      "\033[1m\033[38;5;9m         ...                ......  .:oo,\n"
      "\033[1m\033[38;5;9m  .;clol:,.                        .loooo'\n"
      "\033[1m\033[38;5;9m :ooooooooo,                        'ooool\n"
      "\033[1m\033[38;5;9m'ooooooooooo.                        loooo.\n"
      "\033[1m\033[38;5;9m'ooooooooool                         coooo.\n"
      "\033[1m\033[38;5;9m ,loooooooc.                        .loooo.\n"
      "\033[1m\033[38;5;9m   .,;;;'.                          ;ooooc\n"
      "\033[1m\033[38;5;9m       ...                         ,ooool.\n"
      "\033[1m\033[38;5;9m    .cooooc.              ..',,'.  .cooo.\n"
      "\033[1m\033[38;5;9m      ;ooooo:.           ;oooooooc.  :l.\n"
      "\033[1m\033[38;5;9m       .coooooc,..      coooooooooo.\n"
      "\033[1m\033[38;5;9m         .:ooooooolc:. .ooooooooooo'\n"
      "\033[1m\033[38;5;9m           .':loooooo;  ,oooooooooc\n"
      "\033[1m\033[38;5;9m               ..';::c'  .;loooo:'\033[0m";

    constexpr StringView ARCH =
      "\033[1m\033[38;5;14m                  -`\n"
      "\033[1m\033[38;5;14m                 .o+`\n"
      "\033[1m\033[38;5;14m                `ooo/\n"
      "\033[1m\033[38;5;14m               `+oooo:\n"
      "\033[1m\033[38;5;14m              `+oooooo:\n"
      "\033[1m\033[38;5;14m              -+oooooo+:\n"
      "\033[1m\033[38;5;14m            `/:-:++oooo+:\n"
      "\033[1m\033[38;5;14m           `/++++/+++++++:\n"
      "\033[1m\033[38;5;14m          `/++++++++++++++:\n"
      "\033[1m\033[38;5;14m         `/+++oooooooooooooo/`\n"
      "\033[1m\033[38;5;14m        ./ooosssso++osssssso+`\n"
      "\033[1m\033[38;5;14m       .oossssso-````/ossssss+`\n"
      "\033[1m\033[38;5;14m      -osssssso.      :ssssssso.\n"
      "\033[1m\033[38;5;14m     :osssssss/        osssso+++.\n"
      "\033[1m\033[38;5;14m    /ossssssss/        +ssssooo/-.\n"
      "\033[1m\033[38;5;14m  `/ossssso+/:-        -:/+osssso+-\n"
      "\033[1m\033[38;5;14m `+sso+:-`                 `.-/+oso:\n"
      "\033[1m\033[38;5;14m`++:.                           `-/+/\n"
      "\033[1m\033[38;5;14m.`                                 `/`\033[0m";

    constexpr StringView DEBIAN =
      "\033[1m\033[38;5;15m       _,met$$$$$gg.\n"
      "\033[1m\033[38;5;15m    ,g$$$$$$$$$$$$$$$P.\n"
      "\033[1m\033[38;5;15m  ,g$$P\"        \"\"\"Y$$.\".\n"
      "\033[1m\033[38;5;15m ,$$P'              `$$$.\n"
      "\033[1m\033[38;5;15m',$$P       ,ggs.     `$$b:\n"
      "\033[1m\033[38;5;15m`d$$'     ,$P\"'   \033[38;5;9m.\033[38;5;15m    $$$\n"
      "\033[1m\033[38;5;15m $$P      d$'     \033[38;5;9m,\033[38;5;15m    $$P\n"
      "\033[1m\033[38;5;15m $$:      $$.   \033[38;5;9m-\033[38;5;15m    ,d$$'\n"
      "\033[1m\033[38;5;15m $$;      Y$b._   _,d$P'\n"
      "\033[1m\033[38;5;15m Y$$.    \033[38;5;9m`.\033[38;5;15m`\"Y$$$$P\"'\n"
      "\033[1m\033[38;5;15m `$$b      \033[38;5;9m\"-.__\n"
      "\033[1m\033[38;5;15m  `Y$$\n"
      "\033[1m\033[38;5;15m   `Y$$.\n"
      "\033[1m\033[38;5;15m     `$$b.\n"
      "\033[1m\033[38;5;15m       `Y$$b.\n"
      "\033[1m\033[38;5;15m          `\"Y$b._\n"
      "\033[1m\033[38;5;15m              `\"\"\"\033[0m";

    constexpr StringView FEDORA =
      "\033[1m\033[38;5;12m             .',;::::;,'.\n"
      "\033[1m\033[38;5;12m         .';:cccccccccccc:;,.\n"
      "\033[1m\033[38;5;12m      .;cccccccccccccccccccccc;.\n"
      "\033[1m\033[38;5;12m    .:cccccccccccccccccccccccccc:.\n"
      "\033[1m\033[38;5;12m  .;ccccccccccccc;\033[38;5;15m.:dddl:.\033[38;5;12m;ccccccc;.\n"
      "\033[1m\033[38;5;12m .:ccccccccccccc;\033[38;5;15mOWMKOOXMWd\033[38;5;12m;ccccccc:.\n"
      "\033[1m\033[38;5;12m.:ccccccccccccc;\033[38;5;15mKMMc\033[38;5;12m;cc;\033[38;5;15mxMMc\033[38;5;12m;ccccccc:.\n"
      "\033[1m\033[38;5;12m,cccccccccccccc;\033[38;5;15mMMM.\033[38;5;12m;cc;\033[38;5;15m;WW:\033[38;5;12m;cccccccc,\n"
      "\033[1m\033[38;5;12m:cccccccccccccc;\033[38;5;15mMMM.\033[38;5;12m;cccccccccccccccc:\n"
      "\033[1m\033[38;5;12m:ccccccc;\033[38;5;15moxOOOo\033[38;5;12m;\033[38;5;15mMMM000k.\033[38;5;12m;cccccccccccc:\n"
      "\033[1m\033[38;5;12mcccccc;\033[38;5;15m0MMKxdd:\033[38;5;12m;\033[38;5;15mMMMkddc.\033[38;5;12m;cccccccccccc;\n"
      "\033[1m\033[38;5;12mccccc;\033[38;5;15mXMO'\033[38;5;12m;cccc;\033[38;5;15mMMM.\033[38;5;12m;cccccccccccccccc'\n"
      "\033[1m\033[38;5;12mccccc;\033[38;5;15mMMo\033[38;5;12m;ccccc;\033[38;5;15mMMW.\033[38;5;12m;ccccccccccccccc;\n"
      "\033[1m\033[38;5;12mccccc;\033[38;5;15m0MNc.\033[38;5;12mccc\033[38;5;15m.xMMd\033[38;5;12m;ccccccccccccccc;\n"
      "\033[1m\033[38;5;12mcccccc;\033[38;5;15mdNMWXXXWM0:\033[38;5;12m;cccccccccccccc:,\n"
      "\033[1m\033[38;5;12mcccccccc;\033[38;5;15m.:odl:.\033[38;5;12m;cccccccccccccc:,.\n"
      "\033[1m\033[38;5;12mccccccccccccccccccccccccccccc:'.\n"
      "\033[1m\033[38;5;12m:ccccccccccccccccccccccc:;,..\n"
      "\033[1m\033[38;5;12m ':cccccccccccccccc::;,.\033[0m";

    constexpr StringView WINDOWS =
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\n"
      "\033[1m\033[38;5;12m/////////////////  \033[38;5;12m/////////////////\033[0m";
  } // namespace logos

  constexpr fn GetAsciiArt(StringView operatingSystem) -> Vec<StringView> {
    using namespace logos;

    // clang-format off
    static constexpr Array<Pair<StringView, StringView>, 7> LOGOS = {{
       {   "nixos",   NIXOS },
       {   "macos",   MACOS },
       {  "ubuntu",  UBUNTU },
       {    "arch",    ARCH },
       {  "debian",  DEBIAN },
       {  "fedora",  FEDORA },
       { "windows", WINDOWS },
    }};
    // clang-format on

    StringView asciiArt;

    for (const auto& [key, art] : LOGOS)
      if (operatingSystem.find(key) != String::npos) {
        asciiArt = art;
        break;
      }

    if (asciiArt.empty())
      return {};

    Vec<StringView> lines;
    usize           pos   = 0;
    usize           start = 0;

    while (pos < asciiArt.size()) {
      if (asciiArt[pos] == '\n') {
        lines.push_back(asciiArt.substr(start, pos - start));
        start = pos + 1;
      }

      pos++;
    }

    if (start < asciiArt.size())
      lines.push_back(asciiArt.substr(start));

    return lines;
  }
} // namespace draconis::ui::ascii
</file>

<file path="src/Lib/OS/Haiku.cpp">
#ifdef __HAIKU__

// clang-format off
#include <AppFileInfo.h>               // For BAppFileInfo and version_info
#include <Errors.h>                    // B_OK, strerror, status_t
#include <File.h>                      // For BFile
#include <OS.h>                        // get_system_info, system_info
#include <climits>                     // PATH_MAX
#include <cstring>                     // std::strlen
#include <os/package/PackageDefs.h>    // BPackageKit::BPackageInfoSet
#include <os/package/PackageInfoSet.h> // BPackageKit::BPackageInfo
#include <os/package/PackageRoster.h>  // BPackageKit::BPackageRoster
#include <sys/socket.h>                // ucred, getsockopt, SOL_SOCKET, SO_PEERCRED
#include <sys/statvfs.h>               // statvfs
#include <utility>                     // std::move

#include "Services/PackageCounting.hpp"
#include "Util/Error.hpp"
#include "Util/Env.hpp"
#include "Util/Logging.hpp"
#include "Util/Types.hpp"
#include "Util/Caching.hpp"
#include "Util/CacheManager.hpp"

#include "OperatingSystem.hpp"
// clang-format on

using namespace draconis::utils::types;
using draconis::utils::env::GetEnv;
using draconis::utils::error::DracError, draconis::utils::error::DracErrorCode;

namespace draconis::core::system {
  fn GetOSVersion(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("haiku_os_version", []() -> Result<String> {
      BFile    file;
      status_t status = file.SetTo("/boot/system/lib/libbe.so", B_READ_ONLY);

      if (status != B_OK)
        return Err(DracError(DracErrorCode::InternalError, "Error opening /boot/system/lib/libbe.so"));

      BAppFileInfo appInfo;
      status = appInfo.SetTo(&file);

      if (status != B_OK)
        return Err(DracError(DracErrorCode::InternalError, "Error initializing BAppFileInfo"));

      version_info versionInfo;
      status = appInfo.GetVersionInfo(&versionInfo, B_APP_VERSION_KIND);

      if (status != B_OK)
        return Err(DracError(DracErrorCode::InternalError, "Error reading version info attribute"));

      String versionShortString = versionInfo.short_info;

      if (versionShortString.empty())
        return Err(DracError(DracErrorCode::InternalError, "Version info short_info is empty"));

      return String(versionShortString.c_str());
    });
  }

  fn GetMemInfo() -> Result<u64> {
    system_info    sysinfo;
    const status_t status = get_system_info(&sysinfo);

    if (status != B_OK)
      return Err(DracError(DracErrorCode::InternalError, std::format("get_system_info failed: {}", strerror(status))));

    return static_cast<u64>(sysinfo.max_pages) * B_PAGE_SIZE;
  }

  fn GetNowPlaying() -> Result<MediaInfo> {
    return Err(DracError(DracErrorCode::NotSupported, "Now playing is not supported on Haiku"));
  }

  fn GetWindowManager(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("haiku_wm", []() -> Result<String> {
      return "app_server";
    });
  }

  fn GetDesktopEnvironment(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("haiku_desktop_environment", []() -> Result<String> {
      return "Haiku Desktop Environment";
    });
  }

  fn GetShell(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("haiku_shell", []() -> Result<String> {
      if (const Result<String> shellPath = GetEnv("SHELL")) {
        // clang-format off
            constexpr Array<Pair<StringView, StringView>, 5> shellMap {{
                { "bash",    "Bash" },
                {  "zsh",     "Zsh" },
                { "fish",    "Fish" },
                {   "nu", "Nushell" },
                {   "sh",      "SH" }, // sh last because other shells contain "sh"
            }};
        // clang-format on

        for (const auto& [exe, name] : shellMap)
          if (shellPath->contains(exe))
            return String(name.c_str());

        return *shellPath; // fallback to the raw shell path
      }

      return Err(DracError(DracErrorCode::NotFound, "Could not find SHELL environment variable"));
    });
  }

  fn GetHost(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("haiku_host", []() -> Result<String> {
      Array<char, HOST_NAME_MAX + 1> hostnameBuffer {};

      if (gethostname(hostnameBuffer.data(), hostnameBuffer.size()) != 0)
        return Err(DracError(
          DracErrorCode::ApiUnavailable, std::format("gethostname() failed: {} (errno {})", strerror(errno), errno)
        ));

      hostnameBuffer.at(HOST_NAME_MAX) = '\0';

      return String(hostnameBuffer.data());
    });
  }

  fn GetKernelVersion(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("haiku_kernel_version", []() -> Result<String> {
      system_info    sysinfo;
      const status_t status = get_system_info(&sysinfo);

      if (status != B_OK)
        return Err(DracError(DracErrorCode::InternalError, std::format("get_system_info failed: {}", strerror(status))));

      return String(std::to_string(sysinfo.kernel_version).c_str());
    });
  }

  fn GetDiskUsage() -> Result<DiskSpace> {
    struct statvfs stat;

    if (statvfs("/boot", &stat) == -1)
      return Err(DracError(std::format("Failed to get filesystem stats for '/boot' (statvfs call failed)")));

    return DiskSpace {
      .usedBytes  = (stat.f_blocks * stat.f_frsize) - (stat.f_bfree * stat.f_frsize),
      .totalBytes = stat.f_blocks * stat.f_frsize,
    };
  }
} // namespace draconis::core::system

namespace package {
  fn GetHaikuCount() -> Result<u64> {
    BPackageKit::BPackageRoster  roster;
    BPackageKit::BPackageInfoSet packageList;

    const status_t status = roster.GetActivePackages(BPackageKit::B_PACKAGE_INSTALLATION_LOCATION_SYSTEM, packageList);

    if (status != B_OK)
      return Err(DracError(DracErrorCode::ApiUnavailable, "Failed to get active package list"));

    return static_cast<u64>(packageList.CountInfos());
  }
} // namespace package

#endif // __HAIKU__
</file>

<file path="src/Lib/OS/Serenity.cpp">
#ifdef __serenity__

// clang-format off
#include <format>                 // std::format
#include <fstream>                // std::ifstream
#include <glaze/core/common.hpp>  // glz::object
#include <glaze/core/context.hpp> // glz::{error_ctx, error_code}
#include <glaze/core/meta.hpp>    // glz::detail::Object
#include <glaze/core/read.hpp>    // glz::read
#include <glaze/core/reflect.hpp> // glz::format_error
#include <glaze/json/read.hpp>    // glz::read<glaze_opts>
#include <iterator>               // std::istreambuf_iterator
#include <pwd.h>                  // getpwuid, passwd
#include <string>                 // std::string (String)
#include <sys/statvfs.h>          // statvfs
#include <sys/types.h>            // uid_t
#include <sys/utsname.h>          // utsname, uname
#include <unistd.h>               // getuid, gethostname
#include <unordered_set>          // std::unordered_set

#include "Services/PackageCounting.hpp"
#include "Util/Error.hpp"
#include "Util/Env.hpp"
#include "Util/Logging.hpp"
#include "Util/Types.hpp"
#include "Util/Caching.hpp"
#include "Util/CacheManager.hpp"

#include "OperatingSystem.hpp"
// clang-format on

using namespace draconis::utils::types;
using draconis::utils::error::DracError, draconis::utils::error::DracErrorCode;
using draconis::utils::env::GetEnv;

namespace {
  using glz::opts, glz::detail::Object, glz::object;

  constexpr opts glaze_opts = { .error_on_unknown_keys = false };

  struct MemStatData {
    u64 physical_allocated = 0;
    u64 physical_available = 0;

    // NOLINTBEGIN(readability-identifier-naming)
    struct glaze {
      using T = MemStatData;
      static constexpr Object value =
        object("physical_allocated", &T::physical_allocated, "physical_available", &T::physical_available);
    };
    // NOLINTEND(readability-identifier-naming)
  };

  fn CountUniquePackages(const String& dbPath) -> Result<u64> {
    std::ifstream dbFile(dbPath);

    if (!dbFile.is_open())
      return Err(DracError(DracErrorCode::NotFound, std::format("Failed to open file: {}", dbPath)));

    std::unordered_set<String> uniquePackages;
    String                     line;

    while (std::getline(dbFile, line))
      if (line.starts_with("manual ") || line.starts_with("auto "))
        uniquePackages.insert(line);

    return uniquePackages.size();
  }
} // namespace

namespace draconis::core::system {
  fn GetOSVersion(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("serenity_os_version", []() -> Result<String> {
        utsname uts;

        if (uname(&uts) == -1)
            return Err(DracError("uname call failed for OS Version"));

        return uts.sysname;
    });
  }

  fn GetMemInfo() -> Result<u64> {
    CStr          path = "/sys/kernel/memstat";
    std::ifstream file(path);

    if (!file)
      return Err(DracError(DracErrorCode::NotFound, std::format("Could not open {}", path)));

    String buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    if (buffer.empty())
      return Err(DracError(DracErrorCode::IoError, std::format("File is empty: {}", path)));

    MemStatData data;

    glz::error_ctx error_context = glz::read<glaze_opts>(data, buffer);

    if (error_context)
      return Err(DracError(
        DracErrorCode::ParseError,
        std::format("Failed to parse JSON from {}: {}", path, glz::format_error(error_context, buffer))
      ));

    if (data.physical_allocated > std::numeric_limits<u64>::max() - data.physical_available)
      return Err(DracError(DracErrorCode::InternalError, "Memory size overflow during calculation"));

    return (data.physical_allocated + data.physical_available) * PAGE_SIZE;
  }

  fn GetNowPlaying() -> Result<MediaInfo> {
    return Err(DracError(DracErrorCode::NotSupported, "Now playing is not supported on SerenityOS"));
  }

  fn GetWindowManager(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("serenity_wm", []() -> Result<String> {
        return "WindowManager";
    });
  }

  fn GetDesktopEnvironment(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("serenity_desktop_environment", []() -> Result<String> {
        return "SerenityOS Desktop";
    });
  }

  fn GetShell(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("serenity_shell", []() -> Result<String> {
        uid_t   userId = getuid();
        passwd* pw     = getpwuid(userId);

        if (pw == nullptr)
            return Err(DracError(DracErrorCode::NotFound, std::format("User ID {} not found in /etc/passwd", userId)));

        if (pw->pw_shell == nullptr || *(pw->pw_shell) == '\0')
            return Err(DracError(
                DracErrorCode::NotFound, std::format("User shell entry is empty in /etc/passwd for user ID {}", userId)
            ));

        String shell = pw->pw_shell;

        if (shell.starts_with("/bin/"))
            shell = shell.substr(5);

        return shell;
    });
  }

  fn GetHost(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("serenity_host", []() -> Result<String> {
        Array<char, HOST_NAME_MAX> hostname_buffer;

        if (gethostname(hostname_buffer.data(), hostname_buffer.size()) != 0)
            return Err(DracError("gethostname() failed: {}"));

        return String(hostname_buffer.data());
    });
  }

  fn GetKernelVersion(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("serenity_kernel_version", []() -> Result<String> {
        utsname uts;

        if (uname(&uts) == -1)
            return Err(DracError("uname call failed for Kernel Version"));

        return uts.release;
    });
  }

  fn GetDiskUsage() -> Result<DiskSpace> {
    struct statvfs stat;

    if (statvfs("/", &stat) == -1)
      return Err(DracError("statvfs call failed for '/'"));

    const u64 totalBytes = static_cast<u64>(stat.f_blocks) * stat.f_frsize;
    const u64 freeBytes  = static_cast<u64>(stat.f_bfree) * stat.f_frsize;
    const u64 usedBytes  = totalBytes - freeBytes;

    return DiskSpace { usedBytes, totalBytes };
  }
} // namespace draconis::core::system

namespace package {
  fn GetSerenityCount() -> Result<u64> {
    return CountUniquePackages("/usr/Ports/installed.db");
  }
} // namespace package

#endif // __serenity__
</file>

<file path="src/Lib/Tests/PackageCountingMockTest.cpp">
#include <filesystem> // std::filesystem::{path, temp_directory_path}

#include <Drac++/Services/Packages.hpp>

#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Types.hpp>

#include "gmock/gmock.h"
#include "gtest/gtest.h"

using namespace testing;
using namespace draconis::utils::types;
using draconis::services::packages::Manager;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;

// NOLINTBEGIN(readability-identifier-naming)
class PackageCountingMock {
 public:
  MOCK_METHOD(Result<u64>, GetCountFromDirectory, (const String&, const std::filesystem::path&, const String&, bool), ());
  MOCK_METHOD(Result<u64>, GetCountFromDb, (const String&, const std::filesystem::path&, const String&), ());
  MOCK_METHOD(Result<u64>, GetTotalCount, (const Manager), ());
};
// NOLINTEND(readability-identifier-naming)

class PackageCountingTest : public Test {
 protected:
  PackageCountingMock m_mockCounter;
};

TEST_F(PackageCountingTest, GetCountFromDirectoryReturnsExpectedValue) {
  const String                pmId        = "test";
  const std::filesystem::path dirPath     = "/test/path";
  const String                filter      = ".pkg";
  constexpr bool              subtractOne = false;

  EXPECT_CALL(m_mockCounter, GetCountFromDirectory(pmId, dirPath, filter, subtractOne))
    .WillOnce(Return(Result<u64>(42)));

  const Result<u64> result = m_mockCounter.GetCountFromDirectory(pmId, dirPath, filter, subtractOne);

  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 42);
}

TEST_F(PackageCountingTest, GetCountFromDbReturnsExpectedValue) {
  const String                pmId   = "test";
  const std::filesystem::path dbPath = "/test/db.sqlite";
  const String                query  = "SELECT COUNT(*) FROM packages";

  EXPECT_CALL(m_mockCounter, GetCountFromDb(pmId, dbPath, query))
    .WillOnce(Return(Result<u64>(100)));

  const Result<u64> result = m_mockCounter.GetCountFromDb(pmId, dbPath, query);

  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 100);
}

TEST_F(PackageCountingTest, GetTotalCountReturnsExpectedValue) {
  Manager enabledManagers = Manager::CARGO;

#if defined(__linux__) || defined(__APPLE__)
  enabledManagers = enabledManagers | Manager::NIX;
#endif

  EXPECT_CALL(m_mockCounter, GetTotalCount(enabledManagers))
    .WillOnce(Return(Result<u64>(150)));

  const Result<u64> result = m_mockCounter.GetTotalCount(enabledManagers);

  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 150);
}

TEST_F(PackageCountingTest, GetCountFromDirectoryReturnsErrorWhenDirectoryNotFound) {
  const String                pmId        = "test";
  const std::filesystem::path dirPath     = "/nonexistent/path";
  const String                filter      = ".pkg";
  constexpr bool              subtractOne = false;

  EXPECT_CALL(m_mockCounter, GetCountFromDirectory(pmId, dirPath, filter, subtractOne))
    .WillOnce(Return(Err(DracError(NotFound, "Directory not found"))));

  Result<u64> result = m_mockCounter.GetCountFromDirectory(pmId, dirPath, filter, subtractOne);

  EXPECT_FALSE(result);
  EXPECT_EQ(result.error().code, NotFound);
}

TEST_F(PackageCountingTest, GetCountFromDbReturnsErrorWhenDatabaseCorrupt) {
  const String                pmId   = "test";
  const std::filesystem::path dbPath = "/test/corrupt.sqlite";
  const String                query  = "SELECT COUNT(*) FROM packages";

  EXPECT_CALL(m_mockCounter, GetCountFromDb(pmId, dbPath, query))
    .WillOnce(Return(Err(DracError(ParseError, "Database is corrupt"))));

  Result<u64> result = m_mockCounter.GetCountFromDb(pmId, dbPath, query);

  EXPECT_FALSE(result);
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(PackageCountingTest, GetTotalCountReturnsErrorWhenNoManagersEnabled) {
  constexpr Manager enabledManagers = Manager::NONE;

  EXPECT_CALL(m_mockCounter, GetTotalCount(enabledManagers))
    .WillOnce(Return(Err(DracError(InvalidArgument, "No package managers enabled"))));

  Result<u64> result = m_mockCounter.GetTotalCount(enabledManagers);

  EXPECT_FALSE(result);
  EXPECT_EQ(result.error().code, InvalidArgument);
}

#ifdef __linux__
TEST_F(PackageCountingTest, LinuxPackageManagersAreAvailable) {
  constexpr Manager linuxManagers = Manager::CARGO | Manager::NIX | Manager::PACMAN | Manager::DPKG;

  EXPECT_CALL(m_mockCounter, GetTotalCount(linuxManagers))
    .WillOnce(Return(Result<u64>(200)));

  const Result<u64> result = m_mockCounter.GetTotalCount(linuxManagers);

  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 200);
}
#endif

#ifdef __APPLE__
TEST_F(PackageCountingTest, MacPackageManagersAreAvailable) {
  constexpr Manager macManagers = Manager::CARGO | Manager::NIX | Manager::HOMEBREW;

  EXPECT_CALL(m_mockCounter, GetTotalCount(macManagers))
    .WillOnce(Return(Result<u64>(150)));

  const Result<u64> result = m_mockCounter.GetTotalCount(macManagers);

  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 150);
}
#endif

#ifdef _WIN32
TEST_F(PackageCountingTest, WindowsPackageManagersAreAvailable) {
  constexpr Manager winManagers = Manager::CARGO | Manager::WINGET | Manager::CHOCOLATEY;

  EXPECT_CALL(m_mockCounter, GetTotalCount(winManagers))
    .WillOnce(Return(Result<u64>(100)));

  const Result<u64> result = m_mockCounter.GetTotalCount(winManagers);

  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 100);
}
#endif

fn main(i32 argc, char** argv) -> i32 {
  InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
</file>

<file path="src/Lib/Tests/WeatherServiceTest.cpp">
#if DRAC_ENABLE_WEATHER

  #include <Drac++/Utils/Error.hpp>
  #include <Drac++/Utils/Types.hpp>

  #include "Services/Weather/DataTransferObjects.hpp"
  #include "Services/Weather/WeatherUtils.hpp"
  #include "gtest/gtest.h"

using namespace testing;
using namespace draconis::utils::types;
using namespace draconis::services::weather::utils;
using namespace draconis::services::weather::dto;
using glz::read, glz::error_code, glz::error_ctx;
using enum draconis::utils::error::DracErrorCode;

class WeatherServiceTest : public testing::Test {};

TEST_F(WeatherServiceTest, StripTimeOfDay_DaySuffix) {
  EXPECT_EQ(StripTimeOfDayFromSymbol("clearsky_day"), "clearsky");
  EXPECT_EQ(StripTimeOfDayFromSymbol("partlycloudy_day"), "partlycloudy");
}

TEST_F(WeatherServiceTest, StripTimeOfDay_NightSuffix) {
  EXPECT_EQ(StripTimeOfDayFromSymbol("clearsky_night"), "clearsky");
  EXPECT_EQ(StripTimeOfDayFromSymbol("cloudy_night"), "cloudy");
}

TEST_F(WeatherServiceTest, StripTimeOfDay_PolarTwilightSuffix) {
  EXPECT_EQ(StripTimeOfDayFromSymbol("fair_polartwilight"), "fair");
}

TEST_F(WeatherServiceTest, StripTimeOfDay_NoSuffix) {
  EXPECT_EQ(StripTimeOfDayFromSymbol("rain"), "rain");
  EXPECT_EQ(StripTimeOfDayFromSymbol("heavyrainandthunder"), "heavyrainandthunder");
}

TEST_F(WeatherServiceTest, StripTimeOfDay_EmptyString) {
  EXPECT_EQ(StripTimeOfDayFromSymbol(""), "");
}

TEST_F(WeatherServiceTest, StripTimeOfDay_SuffixOnly) {
  EXPECT_EQ(StripTimeOfDayFromSymbol("_day"), "_day");
}

TEST_F(WeatherServiceTest, StripTimeOfDay_PartialSuffix) {
  EXPECT_EQ(StripTimeOfDayFromSymbol("clearsky_da"), "clearsky_da");
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_Valid) {
  // Test case: 2023-10-26T10:30:00Z
  // Online epoch converters give 1698316200 for this timestamp
  Result<time_t> result = ParseIso8601ToEpoch("2023-10-26T10:30:00Z");
  ASSERT_TRUE(result.has_value());
  EXPECT_EQ(result.value(), 1698316200);

  // Test case: 1970-01-01T00:00:00Z (Epoch itself)
  result = ParseIso8601ToEpoch("1970-01-01T00:00:00Z");
  ASSERT_TRUE(result.has_value());
  EXPECT_EQ(result.value(), 0);

  // Test case: 2000-03-01T12:00:00Z
  result = ParseIso8601ToEpoch("2000-03-01T12:00:00Z");
  ASSERT_TRUE(result.has_value());
  EXPECT_EQ(result.value(), 951912000);
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_InvalidFormat_TooShort) {
  Result<time_t> result = ParseIso8601ToEpoch("2023-10-26T10:30:00");
  ASSERT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_InvalidFormat_TooLong) {
  Result<time_t> result = ParseIso8601ToEpoch("2023-10-26T10:30:00ZEXTRA");
  ASSERT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_InvalidFormat_WrongSeparator) {
  Result<time_t> result = ParseIso8601ToEpoch("2023-10-26X10:30:00Z");
  ASSERT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_InvalidValues_BadMonth) {
  // Note: The current implementation doesn't validate date ranges, it only checks format
  // Month 13 might actually be accepted by the system time functions
  // Let's test with a clearly invalid format instead
  Result<time_t> result = ParseIso8601ToEpoch("2023-AB-26T10:30:00Z"); // Non-numeric month
  ASSERT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_InvalidValues_NonNumeric) {
  Result<time_t> result = ParseIso8601ToEpoch("2023-1A-26T10:30:00Z");
  ASSERT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(WeatherServiceTest, ParseISO8601ToEpoch_EmptyString) {
  Result<time_t> result = ParseIso8601ToEpoch("");
  ASSERT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, ParseError);
}

TEST_F(WeatherServiceTest, MetNoSymbolDescriptions_ClearWeather) {
  const std::unordered_map<StringView, StringView>& descriptions = GetMetnoSymbolDescriptions();

  EXPECT_EQ(descriptions.at("clearsky"), "clear sky");
  EXPECT_EQ(descriptions.at("fair"), "fair");
  EXPECT_EQ(descriptions.at("partlycloudy"), "partly cloudy");
  EXPECT_EQ(descriptions.at("cloudy"), "cloudy");
  EXPECT_EQ(descriptions.at("fog"), "fog");
}

TEST_F(WeatherServiceTest, MetNoSymbolDescriptions_RainWeather) {
  const std::unordered_map<StringView, StringView>& descriptions = GetMetnoSymbolDescriptions();

  EXPECT_EQ(descriptions.at("lightrain"), "light rain");
  EXPECT_EQ(descriptions.at("rain"), "rain");
  EXPECT_EQ(descriptions.at("heavyrain"), "heavy rain");
  EXPECT_EQ(descriptions.at("rainandthunder"), "rain and thunder");
}

TEST_F(WeatherServiceTest, MetNoSymbolDescriptions_SnowWeather) {
  const std::unordered_map<StringView, StringView>& descriptions = GetMetnoSymbolDescriptions();

  EXPECT_EQ(descriptions.at("lightsnow"), "light snow");
  EXPECT_EQ(descriptions.at("snow"), "snow");
  EXPECT_EQ(descriptions.at("heavysnow"), "heavy snow");
  EXPECT_EQ(descriptions.at("snowandthunder"), "snow and thunder");
}

TEST_F(WeatherServiceTest, OpenMeteoWeatherDescription_CommonCodes) {
  EXPECT_EQ(GetOpenmeteoWeatherDescription(0), "clear sky");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(1), "mainly clear");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(2), "partly cloudy");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(3), "overcast");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(45), "fog");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(48), "fog");
}

TEST_F(WeatherServiceTest, OpenMeteoWeatherDescription_RainCodes) {
  EXPECT_EQ(GetOpenmeteoWeatherDescription(51), "drizzle");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(55), "drizzle");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(61), "rain");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(65), "rain");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(80), "rain showers");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(82), "rain showers");
}

TEST_F(WeatherServiceTest, OpenMeteoWeatherDescription_SnowCodes) {
  EXPECT_EQ(GetOpenmeteoWeatherDescription(71), "snow fall");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(75), "snow fall");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(77), "snow grains");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(85), "snow showers");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(86), "snow showers");
}

TEST_F(WeatherServiceTest, OpenMeteoWeatherDescription_ThunderstormCodes) {
  EXPECT_EQ(GetOpenmeteoWeatherDescription(95), "thunderstorm");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(96), "thunderstorm with hail");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(99), "thunderstorm with hail");
}

TEST_F(WeatherServiceTest, OpenMeteoWeatherDescription_UnknownCode) {
  EXPECT_EQ(GetOpenmeteoWeatherDescription(999), "unknown");
  EXPECT_EQ(GetOpenmeteoWeatherDescription(-1), "unknown");
}

TEST_F(WeatherServiceTest, MetNoJsonParsing_ValidCompleteResponse) {
  const String validJson = R"({
    "properties": {
      "timeseries": [
        {
          "time": "2023-10-26T10:30:00Z",
          "data": {
            "instant": {
              "details": {
                "air_temperature": 15.2
              }
            },
            "next_1_hours": {
              "summary": {
                "symbol_code": "clearsky_day"
              }
            }
          }
        }
      ]
    }
  })";

  metno::Response response;
  const error_ctx result = read<glz::opts { .error_on_unknown_keys = false }>(response, validJson);

  ASSERT_EQ(result.ec, error_code::none);
  ASSERT_FALSE(response.properties.timeseries.empty());

  const auto& [time, data] = response.properties.timeseries[0];
  EXPECT_EQ(time, "2023-10-26T10:30:00Z");
  EXPECT_DOUBLE_EQ(data.instant.details.airTemperature, 15.2);
  ASSERT_TRUE(data.next1Hours.has_value());
  EXPECT_EQ(data.next1Hours->summary.symbolCode, "clearsky_day");
}

TEST_F(WeatherServiceTest, MetNoJsonParsing_ValidMinimalResponse) {
  const String minimalJson = R"({
    "properties": {
      "timeseries": [
        {
          "time": "2023-10-26T10:30:00Z",
          "data": {
            "instant": {
              "details": {
                "air_temperature": -5.0
              }
            }
          }
        }
      ]
    }
  })";

  metno::Response response;
  const error_ctx result = read<glz::opts { .error_on_unknown_keys = false }>(response, minimalJson);

  ASSERT_EQ(result.ec, error_code::none);
  ASSERT_FALSE(response.properties.timeseries.empty());

  const auto& [time, data] = response.properties.timeseries[0];
  EXPECT_EQ(time, "2023-10-26T10:30:00Z");
  EXPECT_DOUBLE_EQ(data.instant.details.airTemperature, -5.0);
  EXPECT_FALSE(data.next1Hours.has_value());
}

TEST_F(WeatherServiceTest, MetNoJsonParsing_InvalidJson) {
  const String invalidJson = R"({
    "properties": {
      "timeseries": [
        {
          "time": "2023-10-26T10:30:00Z",
          "data": {
            "instant": {
              // Missing details object
            }
          }
        }
      ]
    }
  })";

  metno::Response response;
  const error_ctx result = read<glz::opts { .error_on_unknown_keys = false }>(response, invalidJson);

  EXPECT_NE(result.ec, error_code::none);
}

TEST_F(WeatherServiceTest, MetNoJsonParsing_EmptyTimeseries) {
  const String emptyTimeseriesJson = R"({
    "properties": {
      "timeseries": []
    }
  })";

  metno::Response response;
  const error_ctx result = read<glz::opts { .error_on_unknown_keys = false }>(response, emptyTimeseriesJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_TRUE(response.properties.timeseries.empty());
}

TEST_F(WeatherServiceTest, OpenMeteoJsonParsing_ValidResponse) {
  const String validJson = R"({
    "current_weather": {
      "temperature": 22.5,
      "weathercode": 1,
      "time": "2023-10-26T10:30:00Z"
    }
  })";

  openmeteo::Response response;
  const error_ctx     result = read<glz::opts { .error_on_unknown_keys = false }>(response, validJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.currentWeather.temperature, 22.5);
  EXPECT_EQ(response.currentWeather.weathercode, 1);
  EXPECT_EQ(response.currentWeather.time, "2023-10-26T10:30:00Z");
}

TEST_F(WeatherServiceTest, OpenMeteoJsonParsing_NegativeTemperature) {
  const String coldWeatherJson = R"({
    "current_weather": {
      "temperature": -15.8,
      "weathercode": 71,
      "time": "2023-12-15T08:00:00Z"
    }
  })";

  openmeteo::Response response;
  const error_ctx     result = read<glz::opts { .error_on_unknown_keys = false }>(response, coldWeatherJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.currentWeather.temperature, -15.8);
  EXPECT_EQ(response.currentWeather.weathercode, 71);
  EXPECT_EQ(response.currentWeather.time, "2023-12-15T08:00:00Z");
}

TEST_F(WeatherServiceTest, OpenMeteoJsonParsing_InvalidJson) {
  const String invalidJson = R"({
    "current_weather": {
      "temperature": "not_a_number",
      "weathercode": 1,
      "time": "2023-10-26T10:30:00Z"
    }
  })";

  openmeteo::Response response;
  const error_ctx     result = read<glz::opts { .error_on_unknown_keys = false }>(response, invalidJson);

  EXPECT_NE(result.ec, error_code::none);
}

TEST_F(WeatherServiceTest, OpenMeteoJsonParsing_MissingFields) {
  const String incompleteJson = R"({
    "current_weather": {
      "temperature": 20.0
    }
  })";

  openmeteo::Response response = {};
  const error_ctx     result   = read<glz::opts { .error_on_unknown_keys = false }>(response, incompleteJson);

  // Note: Glaze doesn't fail on missing fields by default, it just leaves them uninitialized
  // This test verifies that parsing succeeds and only specified fields are updated
  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.currentWeather.temperature, 20.0);
  EXPECT_EQ(response.currentWeather.weathercode, 0); // Zero-initialized
  EXPECT_TRUE(response.currentWeather.time.empty()); // Default constructed empty string
}

TEST_F(WeatherServiceTest, OpenWeatherMapJsonParsing_ValidResponse) {
  const String validJson = R"({
    "main": {
      "temp": 18.7
    },
    "weather": [
      {
        "description": "scattered clouds"
      }
    ],
    "name": "London",
    "dt": 1698316200
  })";

  owm::OWMResponse response;
  const error_ctx  result = read<glz::opts { .error_on_unknown_keys = false }>(response, validJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.main.temp, 18.7);
  ASSERT_FALSE(response.weather.empty());
  EXPECT_EQ(response.weather[0].description, "scattered clouds");
  EXPECT_EQ(response.name, "London");
  EXPECT_EQ(response.dt, 1698316200);
}

TEST_F(WeatherServiceTest, OpenWeatherMapJsonParsing_EmptyWeatherArray) {
  const String emptyWeatherJson = R"({
    "main": {
      "temp": 25.0
    },
    "weather": [],
    "name": "Unknown",
    "dt": 1698316200
  })";

  owm::OWMResponse response;
  const error_ctx  result = read<glz::opts { .error_on_unknown_keys = false }>(response, emptyWeatherJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.main.temp, 25.0);
  EXPECT_TRUE(response.weather.empty());
  EXPECT_EQ(response.name, "Unknown");
  EXPECT_EQ(response.dt, 1698316200);
}

TEST_F(WeatherServiceTest, OpenWeatherMapJsonParsing_MultipleWeatherEntries) {
  const String multiWeatherJson = R"({
    "main": {
      "temp": 12.3
    },
    "weather": [
      {
        "description": "light rain"
      },
      {
        "description": "broken clouds"
      }
    ],
    "name": "Paris",
    "dt": 1698316200
  })";

  owm::OWMResponse response;
  const error_ctx  result = read<glz::opts { .error_on_unknown_keys = false }>(response, multiWeatherJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.main.temp, 12.3);
  ASSERT_EQ(response.weather.size(), 2UL);
  EXPECT_EQ(response.weather[0].description, "light rain");
  EXPECT_EQ(response.weather[1].description, "broken clouds");
  EXPECT_EQ(response.name, "Paris");
}

TEST_F(WeatherServiceTest, OpenWeatherMapJsonParsing_InvalidJson) {
  const String invalidJson = R"({
    "main": {
      "temp": null
    },
    "weather": [
      {
        "description": "clear sky"
      }
    ],
    "name": "TestCity",
    "dt": "not_a_number"
  })";

  owm::OWMResponse response;
  const error_ctx  result = read<glz::opts { .error_on_unknown_keys = false }>(response, invalidJson);

  EXPECT_NE(result.ec, error_code::none);
}

TEST_F(WeatherServiceTest, OpenWeatherMapJsonParsing_EmptyName) {
  const String emptyNameJson = R"({
    "main": {
      "temp": 8.9
    },
    "weather": [
      {
        "description": "overcast clouds"
      }
    ],
    "name": "",
    "dt": 1698316200
  })";

  owm::OWMResponse response;
  const error_ctx  result = read<glz::opts { .error_on_unknown_keys = false }>(response, emptyNameJson);

  ASSERT_EQ(result.ec, error_code::none);
  EXPECT_DOUBLE_EQ(response.main.temp, 8.9);
  EXPECT_EQ(response.name, "");
  EXPECT_EQ(response.weather[0].description, "overcast clouds");
}

fn main(i32 argc, char** argv) -> i32 {
  InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

#endif // DRAC_ENABLE_WEATHER
</file>

<file path=".clang-tidy">
Checks: >
  *,
  -abseil-*,
  -altera-*,
  -boost-*,
  -bugprone-easily-swappable-parameters,
  -bugprone-implicit-widening-of-multiplication-result,
  -cert-env33-c,
  -cert-dcl59-cpp,
  -concurrency-mt-unsafe,
  -cppcoreguidelines-avoid-magic-numbers,
  -cppcoreguidelines-macro-usage,
  -cppcoreguidelines-owning-memory,
  -cppcoreguidelines-pro-bounds-array-to-pointer-decay,
  -cppcoreguidelines-pro-type-member-init,
  -cppcoreguidelines-pro-type-vararg,
  -ctad-maybe-unsupported,
  -fuchsia-*,
  -google-*,
  -hicpp-*,
  -llvm-include-order,
  -llvm-namespace-comment,
  -llvmlibc-*,
  -misc-non-private-member-variables-in-classes,
  -readability-avoid-nested-conditional-operator,
  -readability-braces-around-statements,
  -readability-function-cognitive-complexity,
  -readability-implicit-bool-conversion,
  -readability-isolate-declaration,
  -readability-magic-numbers
CheckOptions:
  cppcoreguidelines-avoid-do-while.IgnoreMacros: "do while"
  readability-else-after-return.WarnOnUnfixable: false
  readability-identifier-length.IgnoredVariableNames: '_'
  readability-identifier-naming.ClassCase: CamelCase
  readability-identifier-naming.EnumCase: CamelCase
  readability-identifier-naming.LocalConstantCase: camelBack
  readability-identifier-naming.LocalVariableCase: camelBack
  readability-identifier-naming.GlobalFunctionCase: CamelCase
  readability-identifier-naming.MemberCase: camelBack
  readability-identifier-naming.MethodCase: camelBack
  readability-identifier-naming.MethodIgnoredRegexp: ((to|from)_class)
  readability-identifier-naming.ParameterPackCase: lower_case
  readability-identifier-naming.PrivateMemberCase: camelBack
  readability-identifier-naming.PrivateMemberPrefix: 'm_'
  readability-identifier-naming.PrivateMethodCase: camelBack
  readability-identifier-naming.PrivateMethodPrefix: ''
  readability-identifier-naming.ProtectedMemberPrefix: 'm_'
  readability-identifier-naming.ProtectedMethodPrefix: ''
  readability-identifier-naming.PublicMemberCase: camelBack
  readability-identifier-naming.StaticConstantCase: UPPER_CASE
  readability-identifier-naming.StaticVariableCase: CamelCase
  readability-identifier-naming.StructCase: CamelCase
  readability-identifier-naming.TemplateParameterCase: lower_case
  readability-identifier-naming.TemplateTemplateParameterCase: CamelCase
  readability-identifier-naming.TypeTemplateParameterCase: CamelCase
  readability-identifier-naming.TypedefCase: CamelCase
  readability-identifier-naming.UnionCase: CamelCase
</file>

<file path="src/CLI/meson.build">
# ------- #
#  Files  #
# ------- #
main_app_sources = files('Config/Config.cpp', 'Core/SystemInfo.cpp', 'UI/UI.cpp', 'main.cpp')

# ------------------------- #
#  Link/ObjC Configuration  #
# ------------------------- #
link_args = []
objc_args = []

if host_system == 'darwin'
  objc_args += ['-fobjc-arc']
elif host_system == 'linux'
  if get_option('build_for_musl') == true
    link_args += ['-static']
  else
    link_args += ['-static-libgcc', '-static-libstdc++']
  endif
elif host_system == 'haiku'
  link_args += ['-lpackage', '-lbe']
endif

# ------------------- #
#  Executable Target  #
# ------------------- #
executable(
  'draconis++',
  main_app_sources,
  dependencies: [draconis_dep] + lib_deps,
  link_args: link_args,
  objc_args: objc_args,
  install: true,
)
</file>

<file path="src/Lib/Services/Weather/DataTransferObjects.hpp">
#pragma once

#if DRAC_ENABLE_WEATHER

// clang-format off
  // we need glaze.hpp include before any other includes that might use it
  // because core/meta.hpp complains about not having uint8_t defined otherwise
  #include <glaze/glaze.hpp>
  #include <glaze/core/meta.hpp>

  #include "Drac++/Utils/Types.hpp"
// clang-format on

namespace draconis::services::weather::dto {
  namespace {
    using draconis::utils::types::f64;
    using draconis::utils::types::i32;
    using draconis::utils::types::i64;
    using draconis::utils::types::Option;
    using draconis::utils::types::String;
    using draconis::utils::types::Vec;
  } // namespace

  // MetNo Data Transfer Objects
  namespace metno {
    struct Details {
      f64 airTemperature;
    };

    struct Next1hSummary {
      String symbolCode;
    };

    struct Next1h {
      Next1hSummary summary;
    };

    struct Instant {
      Details details;
    };

    struct Data {
      Instant        instant;
      Option<Next1h> next1Hours;
    };

    struct Timeseries {
      String time;
      Data   data;
    };

    struct Properties {
      Vec<Timeseries> timeseries;
    };

    struct Response {
      Properties properties;
    };
  } // namespace metno

  // OpenMeteo Data Transfer Objects
  namespace openmeteo {
    struct Response {
      struct Current {
        f64    temperature;
        i32    weathercode;
        String time;
      } currentWeather;
    };
  } // namespace openmeteo

  // OpenWeatherMap Data Transfer Objects
  namespace owm {
    struct OWMResponse {
      struct Main {
        f64 temp;
      };

      struct Weather {
        String description;
      };

      Main           main;
      Vec<Weather>   weather;
      String         name;
      i64            dt;
      Option<i32>    cod;
      Option<String> message;
    };
  } // namespace owm
} // namespace draconis::services::weather::dto

namespace glz {
  namespace {
    using namespace draconis::services::weather::dto;
  } // namespace

  // MetNo Glaze meta definitions
  template <>
  struct meta<metno::Details> {
    static constexpr detail::Object value = object("air_temperature", &metno::Details::airTemperature);
  };

  template <>
  struct meta<metno::Next1hSummary> {
    static constexpr detail::Object value = object("symbol_code", &metno::Next1hSummary::symbolCode);
  };

  template <>
  struct meta<metno::Next1h> {
    static constexpr detail::Object value = object("summary", &metno::Next1h::summary);
  };

  template <>
  struct meta<metno::Instant> {
    static constexpr detail::Object value = object("details", &metno::Instant::details);
  };

  template <>
  struct meta<metno::Data> {
    static constexpr detail::Object value = object("instant", &metno::Data::instant, "next_1_hours", &metno::Data::next1Hours);
  };

  template <>
  struct meta<metno::Timeseries> {
    static constexpr detail::Object value = object("time", &metno::Timeseries::time, "data", &metno::Timeseries::data);
  };

  template <>
  struct meta<metno::Properties> {
    static constexpr detail::Object value = object("timeseries", &metno::Properties::timeseries);
  };

  template <>
  struct meta<metno::Response> {
    static constexpr detail::Object value = object("properties", &metno::Response::properties);
  };

  // OpenMeteo Glaze meta definitions
  template <>
  struct meta<openmeteo::Response::Current> {
    static constexpr detail::Object value = object("temperature", &openmeteo::Response::Current::temperature, "weathercode", &openmeteo::Response::Current::weathercode, "time", &openmeteo::Response::Current::time);
  };

  template <>
  struct meta<openmeteo::Response> {
    static constexpr detail::Object value = object("current_weather", &openmeteo::Response::currentWeather);
  };

  // OpenWeatherMap Glaze meta definitions
  template <>
  struct meta<owm::OWMResponse::Main> {
    static constexpr detail::Object value = object("temp", &owm::OWMResponse::Main::temp);
  };

  template <>
  struct meta<owm::OWMResponse::Weather> {
    static constexpr detail::Object value = object("description", &owm::OWMResponse::Weather::description);
  };

  template <>
  struct meta<owm::OWMResponse> {
    static constexpr detail::Object value = object("main", &owm::OWMResponse::main, "weather", &owm::OWMResponse::weather, "name", &owm::OWMResponse::name, "dt", &owm::OWMResponse::dt, "cod", &owm::OWMResponse::cod, "message", &owm::OWMResponse::message);
  };
} // namespace glz

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Services/Weather/MetNoService.hpp">
#pragma once

#if DRAC_ENABLE_WEATHER

  #include "Drac++/Services/Weather.hpp"

  #include "Drac++/Utils/Types.hpp"

namespace draconis::services::weather {
  class MetNoService final : public IWeatherService {
   public:
    MetNoService(utils::types::f64 lat, utils::types::f64 lon, UnitSystem units);
    [[nodiscard]] fn getWeatherInfo() const -> utils::types::Result<Report> override;

   private:
    utils::types::f64 m_lat;
    utils::types::f64 m_lon;
    UnitSystem        m_units;
  };
} // namespace draconis::services::weather

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Services/Weather/OpenMeteoService.hpp">
#pragma once

#if DRAC_ENABLE_WEATHER

  #include "Drac++/Services/Weather.hpp"

  #include "Drac++/Utils/Types.hpp"

namespace draconis::services::weather {
  class OpenMeteoService final : public IWeatherService {
   public:
    OpenMeteoService(utils::types::f64 lat, utils::types::f64 lon, UnitSystem units);
    [[nodiscard]] fn getWeatherInfo() const -> utils::types::Result<Report> override;

   private:
    utils::types::f64 m_lat;
    utils::types::f64 m_lon;
    UnitSystem        m_units;
  };
} // namespace draconis::services::weather

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Services/Weather/OpenWeatherMapService.hpp">
#pragma once

#if DRAC_ENABLE_WEATHER

  #include "Drac++/Services/Weather.hpp"

  #include "Drac++/Utils/Types.hpp"

namespace draconis::services::weather {
  class OpenWeatherMapService final : public IWeatherService {
   public:
    OpenWeatherMapService(Location location, utils::types::String apiKey, UnitSystem units);
    fn getWeatherInfo() const -> utils::types::Result<Report> override;

   private:
    Location             m_location;
    utils::types::String m_apiKey;
    UnitSystem           m_units;
  };
} // namespace draconis::services::weather

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Services/Weather/WeatherUtils.hpp">
#pragma once

#if DRAC_ENABLE_WEATHER

  #include <unordered_map>

  #include "Drac++/Utils/Types.hpp"

namespace draconis::services::weather::utils {
  namespace {
    using draconis::utils::types::i32;
    using draconis::utils::types::Result;
    using draconis::utils::types::String;
    using draconis::utils::types::StringView;
  } // namespace

  /**
   * @brief Strips time-of-day suffixes (_day, _night, _polartwilight) from a weather symbol code.
   * @param symbol The weather symbol code.
   * @return The symbol code without the time-of-day suffix.
   */
  fn StripTimeOfDayFromSymbol(StringView symbol) -> String;

  /**
   * @brief Parses an ISO8601 timestamp string (YYYY-MM-DDTHH:MM:SSZ) to a Unix epoch timestamp.
   * @param iso8601 The ISO8601 timestamp string (must be UTC, ending in 'Z').
   * @return A Result containing the epoch timestamp (usize) on success, or a DracError on failure.
   */
  fn ParseIso8601ToEpoch(StringView iso8601) -> Result<time_t>;

  /**
   * @brief Provides a mapping from MetNo weather symbol codes (after time-of-day stripping) to human-readable descriptions.
   * @return A const reference to an unordered_map of symbol codes to descriptions.
   */
  fn GetMetnoSymbolDescriptions() -> const std::unordered_map<StringView, StringView>&;

  /**
   * @brief Provides a human-readable description for an OpenMeteo weather code.
   * @param code The OpenMeteo weather code (integer).
   * @return A StringView containing the description. Returns "unknown" if the code is not recognized.
   */
  fn GetOpenmeteoWeatherDescription(i32 code) -> String;
} // namespace draconis::services::weather::utils

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Tests/LoggingUtilsTest.cpp">
#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#include "gtest/gtest.h"

using namespace testing;
using draconis::utils::logging::Bold;
using draconis::utils::logging::Colorize;
using draconis::utils::logging::Italic;
using draconis::utils::logging::LogColor;
using draconis::utils::logging::LogLevelConst;
using draconis::utils::types::i32;
using draconis::utils::types::String;
using draconis::utils::types::StringView;

class LoggingUtilsTest : public Test {};

TEST_F(LoggingUtilsTest, Colorize_RedText) {
  constexpr StringView textToColorize = "Hello, Red World!";
  constexpr LogColor   color          = LogColor::Red;
  const String         expectedPrefix = String(LogLevelConst::COLOR_CODE_LITERALS.at(static_cast<size_t>(color)));
  const String         expectedSuffix = String(LogLevelConst::RESET_CODE);

  String colorizedText = Colorize(textToColorize, color);

  EXPECT_TRUE(colorizedText.rfind(expectedPrefix, 0) == 0);
  EXPECT_NE(colorizedText.find(textToColorize.data(), 0, textToColorize.length()), String::npos);
  EXPECT_TRUE(colorizedText.length() >= textToColorize.length() + expectedPrefix.length() + expectedSuffix.length());
  EXPECT_EQ(colorizedText.substr(colorizedText.length() - expectedSuffix.length()), expectedSuffix);
}

TEST_F(LoggingUtilsTest, Colorize_BlueText) {
  constexpr StringView textToColorize = "Blue Sky";
  constexpr LogColor   color          = LogColor::Blue;
  const String         expectedPrefix = String(LogLevelConst::COLOR_CODE_LITERALS.at(static_cast<size_t>(color)));
  const String         expectedSuffix = String(LogLevelConst::RESET_CODE);

  String colorizedText = Colorize(textToColorize, color);

  EXPECT_TRUE(colorizedText.rfind(expectedPrefix, 0) == 0);
  EXPECT_NE(colorizedText.find(textToColorize.data(), 0, textToColorize.length()), String::npos);
  EXPECT_TRUE(colorizedText.length() >= textToColorize.length() + expectedPrefix.length() + expectedSuffix.length());
  EXPECT_EQ(colorizedText.substr(colorizedText.length() - expectedSuffix.length()), expectedSuffix);
}

TEST_F(LoggingUtilsTest, Colorize_EmptyText) {
  constexpr StringView textToColorize;
  constexpr LogColor   color          = LogColor::Green;
  const String         expectedPrefix = String(LogLevelConst::COLOR_CODE_LITERALS.at(static_cast<size_t>(color)));
  const String         expectedSuffix = String(LogLevelConst::RESET_CODE);

  const String colorizedText = Colorize(textToColorize, color);
  const String expectedText  = expectedPrefix + String(textToColorize) + expectedSuffix;
  EXPECT_EQ(colorizedText, expectedText);
}

TEST_F(LoggingUtilsTest, Bold_SimpleText) {
  constexpr StringView textToBold     = "This is bold.";
  const String         expectedPrefix = String(LogLevelConst::BOLD_START);
  const String         expectedSuffix = String(LogLevelConst::BOLD_END);

  const String boldedText   = Bold(textToBold);
  const String expectedText = expectedPrefix + String(textToBold) + expectedSuffix;

  EXPECT_EQ(boldedText, expectedText);
}

TEST_F(LoggingUtilsTest, Bold_EmptyText) {
  constexpr StringView textToBold;
  const String         expectedPrefix = String(LogLevelConst::BOLD_START);
  const String         expectedSuffix = String(LogLevelConst::BOLD_END);

  const String boldedText   = Bold(textToBold);
  const String expectedText = expectedPrefix + String(textToBold) + expectedSuffix;
  EXPECT_EQ(boldedText, expectedText);
}

TEST_F(LoggingUtilsTest, Italic_SimpleText) {
  constexpr StringView textToItalicize = "This is italic.";
  const String         expectedPrefix  = String(LogLevelConst::ITALIC_START);
  const String         expectedSuffix  = String(LogLevelConst::ITALIC_END);

  const String italicizedText = Italic(textToItalicize);
  const String expectedText   = expectedPrefix + String(textToItalicize) + expectedSuffix;

  EXPECT_EQ(italicizedText, expectedText);
}

TEST_F(LoggingUtilsTest, Italic_EmptyText) {
  constexpr StringView textToItalicize;
  const String         expectedPrefix = String(LogLevelConst::ITALIC_START);
  const String         expectedSuffix = String(LogLevelConst::ITALIC_END);

  const String italicizedText = Italic(textToItalicize);
  const String expectedText   = expectedPrefix + String(textToItalicize) + expectedSuffix;
  EXPECT_EQ(italicizedText, expectedText);
}

TEST_F(LoggingUtilsTest, Combined_BoldItalicRedText) {
  constexpr StringView textToStyle = "Styled Text";
  constexpr LogColor   color       = LogColor::Magenta;

  const String colorPrefix  = String(LogLevelConst::COLOR_CODE_LITERALS.at(static_cast<size_t>(color)));
  const String colorSuffix  = String(LogLevelConst::RESET_CODE);
  const String boldPrefix   = String(LogLevelConst::BOLD_START);
  const String boldSuffix   = String(LogLevelConst::BOLD_END);
  const String italicPrefix = String(LogLevelConst::ITALIC_START);
  const String italicSuffix = String(LogLevelConst::ITALIC_END);

  const String styledText = Colorize(Bold(Italic(textToStyle)), color);

  String expectedInnerText       = italicPrefix + String(textToStyle) + italicSuffix;
  expectedInnerText              = boldPrefix + expectedInnerText + boldSuffix;
  const String expectedFinalText = colorPrefix + expectedInnerText + colorSuffix;

  EXPECT_EQ(styledText, expectedFinalText);
}

fn main(i32 argc, char** argv) -> i32 {
  InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
</file>

<file path="src/Lib/Tests/meson.build">
# ----------------- #
#  Test Files      #
# ----------------- #
test_sources = {
  'core': files('CacheManagerTest.cpp', 'CoreTypesTest.cpp', 'LoggingUtilsTest.cpp'),
  'packages': files('PackageCountingIntegrationTest.cpp', 'PackageCountingMockTest.cpp'),
  'weather': files('WeatherServiceTest.cpp'),
}

# ----------------- #
#  Test Executable  #
# ----------------- #
gtest_dep = dependency('gtest', fallback: ['gtest', 'gtest_dep'], main: false, required: false)
gmock_dep = dependency('gmock', fallback: ['gtest', 'gmock_dep'], required: false)

if gtest_dep.found() and gmock_dep.found()
  test_common_args = ['--gtest_color=yes', '--gtest_print_time=1']
  test_common_dependencies = [draconis_dep, gtest_dep, gmock_dep] + lib_deps
  test_inc = include_directories('..')

  fs = import('fs')

  # Always build core tests
  foreach test_file : test_sources['core']
    test_name = fs.stem(test_file)

    test_exe = executable(
      test_name,
      test_file,
      dependencies: test_common_dependencies,
      include_directories: test_inc,
    )

    test(
      test_name,
      test_exe,
      args: test_common_args,
      protocol: 'gtest',
      suite: 'core',
      timeout: 30,
      is_parallel: true,
    )
  endforeach

  # Conditionally build package tests
  if get_option('packagecount').enabled()
    foreach test_file : test_sources['packages']
      test_name = fs.stem(test_file)

      test_exe = executable(
        test_name,
        test_file,
        dependencies: test_common_dependencies,
        include_directories: test_inc,
      )

      test(
        test_name,
        test_exe,
        args: test_common_args,
        protocol: 'gtest',
        suite: 'packages',
        timeout: 30,
        is_parallel: true,
      )
    endforeach
  endif

  # Conditionally build weather tests
  if get_option('weather').enabled()
    foreach test_file : test_sources['weather']
      test_name = fs.stem(test_file)

      test_exe = executable(
        test_name,
        test_file,
        dependencies: test_common_dependencies,
        include_directories: test_inc,
      )

      test(
        test_name,
        test_exe,
        args: test_common_args,
        protocol: 'gtest',
        suite: 'weather',
        timeout: 30,
        is_parallel: true,
      )
    endforeach
  endif
endif
</file>

<file path="subprojects/glaze.wrap">
[wrap-file]
source_url = https://github.com/stephenberry/glaze/archive/refs/tags/v5.5.4.tar.gz
source_filename = glaze-5.5.4.tar.gz
source_hash = 309184e6cf046669f22b336b85a1ab92278a45ad05fce079be4c0f45e19dcbd2
directory = glaze-5.5.4
</file>

<file path="src/Lib/meson.build">
# ------- #
#  Files  #
# ------- #

# Structured source organization
lib_sources = {
  'base' : files(),
  'packages' : files('Services/Packages.cpp'),
  'weather' : files(
    'Services/Weather/MetNoService.cpp',
    'Services/Weather/OpenMeteoService.cpp',
    'Services/Weather/OpenWeatherMapService.cpp',
    'Services/Weather/WeatherFactory.cpp',
    'Services/Weather/WeatherUtils.cpp',
  ),
}

# Platform-specific sources
platform_sources = {
  'darwin' : files('OS/macOS.cpp', 'OS/macOS/Bridge.mm'),
  'dragonfly' : files('OS/BSD.cpp'),
  'freebsd' : files('OS/BSD.cpp'),
  'haiku' : files('OS/Haiku.cpp'),
  'linux' : files('OS/Linux.cpp'),
  'netbsd' : files('OS/BSD.cpp'),
  'serenity' : files('OS/Serenity.cpp'),
  'windows' : files('OS/Windows.cpp'),
}

# Build final source list
lib_all_sources = lib_sources['base']

if get_option('packagecount').enabled()
  lib_all_sources += lib_sources['packages']
endif

if get_option('weather').enabled()
  lib_all_sources += lib_sources['weather']
endif

# Add platform sources
lib_all_sources += platform_sources.get(host_system, files())

# Link arguments
link_args = []

if get_option('use_linked_pci_ids') == true
  link_args += meson.project_source_root() / 'pci_ids.o'
endif

# ----------------- #
#  Static Library   #
# ----------------- #
libdrac = static_library(
  'drac++',
  lib_all_sources,
  dependencies : lib_deps,
  install : false,
)

draconis_dep = declare_dependency(
  link_with : libdrac,
  dependencies : [includes_dep],
  link_args : link_args,
)
</file>

<file path="src/Lib/OS/BSD.cpp">
#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)

// clang-format off
#include <dbus/dbus-protocol.h> // DBUS_TYPE_*
#include <dbus/dbus-shared.h>   // DBUS_BUS_SESSION
#include <fstream>              // ifstream
#include <sys/socket.h>         // ucred, getsockopt, SOL_SOCKET, SO_PEERCRED
#include <sys/statvfs.h>        // statvfs
#include <sys/sysctl.h>         // sysctlbyname
#include <sys/un.h>             // LOCAL_PEERCRED
#include <sys/utsname.h>        // uname, utsname

#ifndef __NetBSD__
  #include <kenv.h>      // kenv
  #include <sys/ucred.h> // xucred
#endif

#include "Services/PackageCounting.hpp"
#include "Util/Error.hpp"
#include "Util/Env.hpp"
#include "Util/Logging.hpp"
#include "Util/Types.hpp"
#include "Util/Caching.hpp"
#include "Util/CacheManager.hpp"
#include "Wrappers/DBus.hpp"
#include "Wrappers/Wayland.hpp"
#include "Wrappers/XCB.hpp"

#include "OperatingSystem.hpp"
// clang-format on

using namespace draconis::utils::types;
using draconis::utils::error::DracError, draconis::utils::error::DracErrorCode;

namespace {
  #ifdef __FreeBSD__
  fn GetPathByPid(pid_t pid) -> Result<String> {
    Array<char, PATH_MAX> exePathBuf {};
    usize                 size = exePathBuf.size();
    Array<i32, 4>         mib {};

    mib.at(0) = CTL_KERN;
    mib.at(1) = KERN_PROC_ARGS;
    mib.at(2) = pid;
    mib.at(3) = KERN_PROC_PATHNAME;

    if (sysctl(mib.data(), 4, exePathBuf.data(), &size, nullptr, 0) == -1)
      return Err(DracError(std::format("sysctl KERN_PROC_PATHNAME failed for pid {}", pid)));

    if (size == 0 || exePathBuf[0] == '\0')
      return Err(
        DracError(DracErrorCode::NotFound, std::format("sysctl KERN_PROC_PATHNAME returned empty path for pid {}", pid))
      );

    exePathBuf.at(std::min(size, exePathBuf.size() - 1)) = '\0';

    return String(exePathBuf.data());
  }
  #endif

  #ifdef HAVE_XCB
  fn GetX11WindowManager() -> Result<String> {
    using namespace xcb;
    using namespace matchit;
    using enum ConnError;
    using drac::types::StringView;

    const DisplayGuard conn;

    if (!conn)
      if (const i32 err = ConnectionHasError(conn.get()))
        return Err(
          DracError(
            DracErrorCode::ApiUnavailable,
            match(err)(
              is | Generic         = "Stream/Socket/Pipe Error",
              is | ExtNotSupported = "Extension Not Supported",
              is | MemInsufficient = "Insufficient Memory",
              is | ReqLenExceed    = "Request Length Exceeded",
              is | ParseErr        = "Display String Parse Error",
              is | InvalidScreen   = "Invalid Screen",
              is | FdPassingFailed = "FD Passing Failed",
              is | _               = std::format("Unknown Error Code ({})", err)
            )
          )
        );

    fn internAtom = [&conn](const StringView name) -> Result<atom_t> {
      using drac::types::u16;

      const ReplyGuard<intern_atom_reply_t> reply(InternAtomReply(conn.get(), InternAtom(conn.get(), 0, static_cast<u16>(name.size()), name.data()), nullptr));

      if (!reply)
        return Err(DracError(DracErrorCode::PlatformSpecific, std::format("Failed to get X11 atom reply for '{}'", name)));

      return reply->atom;
    };

    const Result<atom_t> supportingWmCheckAtom = internAtom("_NET_SUPPORTING_WM_CHECK");
    const Result<atom_t> wmNameAtom            = internAtom("_NET_WM_NAME");
    const Result<atom_t> utf8StringAtom        = internAtom("UTF8_STRING");

    if (!supportingWmCheckAtom || !wmNameAtom || !utf8StringAtom) {
      if (!supportingWmCheckAtom)
        error_log("Failed to get _NET_SUPPORTING_WM_CHECK atom");

      if (!wmNameAtom)
        error_log("Failed to get _NET_WM_NAME atom");

      if (!utf8StringAtom)
        error_log("Failed to get UTF8_STRING atom");

      return Err(DracError(DracErrorCode::PlatformSpecific, "Failed to get X11 atoms"));
    }

    const ReplyGuard<get_property_reply_t> wmWindowReply(GetPropertyReply(
      conn.get(),
      GetProperty(conn.get(), 0, conn.rootScreen()->root, *supportingWmCheckAtom, ATOM_WINDOW, 0, 1),
      nullptr
    ));

    if (!wmWindowReply || wmWindowReply->type != ATOM_WINDOW || wmWindowReply->format != 32 ||
        GetPropertyValueLength(wmWindowReply.get()) == 0)
      return Err(DracError(DracErrorCode::NotFound, "Failed to get _NET_SUPPORTING_WM_CHECK property"));

    const window_t wmRootWindow = *static_cast<window_t*>(GetPropertyValue(wmWindowReply.get()));

    const ReplyGuard<get_property_reply_t> wmNameReply(GetPropertyReply(
      conn.get(), GetProperty(conn.get(), 0, wmRootWindow, *wmNameAtom, *utf8StringAtom, 0, 1024), nullptr
    ));

    if (!wmNameReply || wmNameReply->type != *utf8StringAtom || GetPropertyValueLength(wmNameReply.get()) == 0)
      return Err(DracError(DracErrorCode::NotFound, "Failed to get _NET_WM_NAME property"));

    const char* nameData = static_cast<const char*>(GetPropertyValue(wmNameReply.get()));
    const usize length   = GetPropertyValueLength(wmNameReply.get());

    return String(nameData, length);
  }
  #else
  fn GetX11WindowManager() -> Result<String> {
    return Err(DracError(DracErrorCode::NotSupported, "XCB (X11) support not available"));
  }
  #endif

  fn GetWaylandCompositor() -> Result<String> {
  #ifndef __FreeBSD__
    return "Wayland Compositor";
  #else
    const wl::DisplayGuard display;

    if (!display)
      return Err(DracError(DracErrorCode::NotFound, "Failed to connect to display (is Wayland running?)"));

    const i32 fileDescriptor = display.fd();
    if (fileDescriptor < 0)
      return Err(DracError(DracErrorCode::ApiUnavailable, "Failed to get Wayland file descriptor"));

    pid_t peerPid = -1; // Initialize PID

    struct xucred cred;

    socklen_t len = sizeof(cred);

    if (getsockopt(fileDescriptor, SOL_SOCKET, LOCAL_PEERCRED, &cred, &len) == -1)
      return Err(DracError("Failed to get socket credentials (LOCAL_PEERCRED)"));

    peerPid = cred.cr_pid;

    if (peerPid <= 0)
      return Err(DracError(DracErrorCode::PlatformSpecific, "Failed to obtain a valid peer PID"));

    Result<String> exePathResult = GetPathByPid(peerPid);

    if (!exePathResult)
      return Err(std::move(exePathResult).error());

    const String& exeRealPath = *exePathResult;

    StringView compositorNameView;

    if (const usize lastSlash = exeRealPath.rfind('/'); lastSlash != String::npos)
      compositorNameView = StringView(exeRealPath).substr(lastSlash + 1);
    else
      compositorNameView = exeRealPath;

    if (compositorNameView.empty() || compositorNameView == "." || compositorNameView == "/")
      return Err(DracError(DracErrorCode::NotFound, "Failed to get compositor name from path"));

    if (constexpr StringView wrappedSuffix = "-wrapped"; compositorNameView.length() > 1 + wrappedSuffix.length() &&
        compositorNameView[0] == '.' && compositorNameView.ends_with(wrappedSuffix)) {
      const StringView cleanedView =
        compositorNameView.substr(1, compositorNameView.length() - 1 - wrappedSuffix.length());

      if (cleanedView.empty())
        return Err(DracError(DracErrorCode::NotFound, "Compositor name invalid after heuristic"));

      return String(cleanedView);
    }

    return String(compositorNameView);
  #endif
  }
} // namespace

namespace draconis::core::system {
  using drac::env::GetEnv;

  fn GetOSVersion(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("bsd_os_version", []() -> Result<String> {
      constexpr CStr path = "/etc/os-release";

      std::ifstream file(path);

      if (file) {
        String               line;
        constexpr StringView prefix = "NAME=";

        while (std::getline(file, line)) {
          if (StringView(line).starts_with(prefix)) {
            String value = line.substr(prefix.size());

            if ((value.length() >= 2 && value.front() == '"' && value.back() == '"') ||
                (value.length() >= 2 && value.front() == '\'' && value.back() == '\''))
              value = value.substr(1, value.length() - 2);

            return String(value);
          }
        }
      }

      utsname uts;

      if (uname(&uts) == -1)
        return Err(DracError(std::format("Failed to open {} and uname() call also failed", path)));

      String osName = uts.sysname;

      if (osName.empty())
        return Err(DracError(DracErrorCode::ParseError, "uname() returned empty sysname or release"));

      return String(osName);
    });
  }

  fn GetMemInfo() -> Result<u64> {
    u64   mem  = 0;
    usize size = sizeof(mem);

  #ifdef __NetBSD__
    sysctlbyname("hw.physmem64", &mem, &size, nullptr, 0);
  #else
    sysctlbyname("hw.physmem", &mem, &size, nullptr, 0);
  #endif

    return mem;
  }

  fn GetNowPlaying() -> Result<MediaInfo> {
    using namespace dbus;

    Result<Connection> connectionResult = Connection::busGet(DBUS_BUS_SESSION);
    if (!connectionResult)
      return Err(connectionResult.error());

    const Connection& connection = *connectionResult;

    Option<String> activePlayer = None;

    {
      Result<Message> listNamesResult =
        Message::newMethodCall("org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", "ListNames");
      if (!listNamesResult)
        return Err(listNamesResult.error());

      Result<Message> listNamesReplyResult = connection.sendWithReplyAndBlock(*listNamesResult, 100);
      if (!listNamesReplyResult)
        return Err(listNamesReplyResult.error());

      MessageIter iter = listNamesReplyResult->iterInit();
      if (!iter.isValid() || iter.getArgType() != DBUS_TYPE_ARRAY)
        return Err(DracError(DracErrorCode::ParseError, "Invalid DBus ListNames reply format: Expected array"));

      MessageIter subIter = iter.recurse();
      if (!subIter.isValid())
        return Err(
          DracError(DracErrorCode::ParseError, "Invalid DBus ListNames reply format: Could not recurse into array")
        );

      while (subIter.getArgType() != DBUS_TYPE_INVALID) {
        if (Option<String> name = subIter.getString())
          if (name->starts_with("org.mpris.MediaPlayer2.")) {
            activePlayer = std::move(*name);
            break;
          }
        if (!subIter.next())
          break;
      }
    }

    if (!activePlayer)
      return Err(DracError(DracErrorCode::NotFound, "No active MPRIS players found"));

    Result<Message> msgResult = Message::newMethodCall(
      activePlayer->c_str(), "/org/mpris/MediaPlayer2", "org.freedesktop.DBus.Properties", "Get"
    );

    if (!msgResult)
      return Err(msgResult.error());

    Message& msg = *msgResult;

    if (!msg.appendArgs("org.mpris.MediaPlayer2.Player", "Metadata"))
      return Err(DracError(DracErrorCode::InternalError, "Failed to append arguments to Properties.Get message"));

    Result<Message> replyResult = connection.sendWithReplyAndBlock(msg, 100);

    if (!replyResult)
      return Err(replyResult.error());

    Option<String> title  = None;
    Option<String> artist = None;

    MessageIter propIter = replyResult->iterInit();
    if (!propIter.isValid())
      return Err(DracError(DracErrorCode::ParseError, "Properties.Get reply has no arguments or invalid iterator"));

    if (propIter.getArgType() != DBUS_TYPE_VARIANT)
      return Err(DracError(DracErrorCode::ParseError, "Properties.Get reply argument is not a variant"));

    MessageIter variantIter = propIter.recurse();
    if (!variantIter.isValid())
      return Err(DracError(DracErrorCode::ParseError, "Could not recurse into variant"));

    if (variantIter.getArgType() != DBUS_TYPE_ARRAY || variantIter.getElementType() != DBUS_TYPE_DICT_ENTRY)
      return Err(DracError(DracErrorCode::ParseError, "Metadata variant content is not a dictionary array (a{sv})"));

    MessageIter dictIter = variantIter.recurse();
    if (!dictIter.isValid())
      return Err(DracError(DracErrorCode::ParseError, "Could not recurse into metadata dictionary array"));

    while (dictIter.getArgType() == DBUS_TYPE_DICT_ENTRY) {
      MessageIter entryIter = dictIter.recurse();
      if (!entryIter.isValid()) {
        if (!dictIter.next())
          break;
        continue;
      }

      Option<String> key = entryIter.getString();
      if (!key) {
        if (!dictIter.next())
          break;
        continue;
      }

      if (!entryIter.next() || entryIter.getArgType() != DBUS_TYPE_VARIANT) {
        if (!dictIter.next())
          break;
        continue;
      }

      MessageIter valueVariantIter = entryIter.recurse();
      if (!valueVariantIter.isValid()) {
        if (!dictIter.next())
          break;
        continue;
      }

      if (*key == "xesam:title") {
        title = valueVariantIter.getString();
      } else if (*key == "xesam:artist") {
        if (valueVariantIter.getArgType() == DBUS_TYPE_ARRAY && valueVariantIter.getElementType() == DBUS_TYPE_STRING) {
          if (MessageIter artistArrayIter = valueVariantIter.recurse(); artistArrayIter.isValid())
            artist = artistArrayIter.getString();
        }
      }

      if (!dictIter.next())
        break;
    }

    return MediaInfo(std::move(title), std::move(artist));
  }

  fn GetWindowManager(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("bsd_wm", []() -> Result<String> {
      if (!GetEnv("DISPLAY") && !GetEnv("WAYLAND_DISPLAY") && !GetEnv("XDG_SESSION_TYPE"))
        return Err(DracError(DracErrorCode::NotFound, "Could not find a graphical session"));

      if (Result<String> waylandResult = GetWaylandCompositor())
        return String(*waylandResult);

      if (Result<String> x11Result = GetX11WindowManager())
        return String(*x11Result);

      return Err(DracError(DracErrorCode::NotFound, "Could not detect window manager (Wayland/X11) or both failed"));
    });
  }

  fn GetDesktopEnvironment(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("bsd_desktop_environment", []() -> Result<String> {
      if (!GetEnv("DISPLAY") && !GetEnv("WAYLAND_DISPLAY") && !GetEnv("XDG_SESSION_TYPE"))
        return Err(DracError(DracErrorCode::NotFound, "Could not find a graphical session"));

      return GetEnv("XDG_CURRENT_DESKTOP")
        .transform([](String xdgDesktop) -> String {
          if (const usize colon = xdgDesktop.find(':'); colon != String::npos)
            xdgDesktop.resize(colon);

          return xdgDesktop;
        })
        .or_else([](const DracError&) -> Result<String> { return GetEnv("DESKTOP_SESSION"); })
        .transform([](String desktopSession) -> String {
          if (const usize colon = desktopSession.find(':'); colon != String::npos)
            desktopSession.resize(colon);

          return desktopSession;
        })
        .transform([](String desktop) -> String { return String(desktop); });
    });
  }

  fn GetShell(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("bsd_shell", []() -> Result<String> {
      if (const Result<String> shellPath = GetEnv("SHELL")) {
        // clang-format off
            constexpr Array<Pair<StringView, StringView>, 5> shellMap {{
                { "bash",    "Bash" },
                {  "zsh",     "Zsh" },
                { "fish",    "Fish" },
                {   "nu", "Nushell" },
                {   "sh",      "SH" }, // sh last because other shells contain "sh"
            }};
        // clang-format on

        for (const auto& [exe, name] : shellMap)
          if (shellPath->contains(exe))
            return String(name);

        return String(*shellPath); // fallback to the raw shell path
      }

      return Err(DracError(DracErrorCode::NotFound, "Could not find SHELL environment variable"));
    });
  }

  fn GetHost(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("bsd_host", []() -> Result<String> {
      Array<char, 256> buffer {};
      usize            size = buffer.size();

  #if defined(__FreeBSD__) || defined(__DragonFly__)
      i32 result = kenv(KENV_GET, "smbios.system.product", buffer.data(), buffer.size() - 1); // Ensure space for null

      if (result == -1) {
        if (sysctlbyname("hw.model", buffer.data(), &size, nullptr, 0) == -1)
          return Err(DracError("kenv smbios.system.product failed and sysctl hw.model also failed"));

        buffer.at(std::min(size, buffer.size() - 1)) = '\0';
        return String(buffer.data());
      }

      if (result > 0)
        buffer.at(result) = '\0';
      else
        buffer.at(0) = '\0';

  #elifdef __NetBSD__
        if (sysctlbyname("machdep.dmi.system-product", buffer.data(), &size, nullptr, 0) == -1)
            return Err(DracError(std::format("sysctlbyname failed for")));

        buffer[std::min(size, buffer.size() - 1)] = '\0';
  #endif
      if (buffer[0] == '\0')
        return Err(DracError(DracErrorCode::NotFound, "Failed to get host product information (empty result)"));

      return String(buffer.data());
    });
  }

  fn GetKernelVersion(draconis::utils::cache::CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("bsd_kernel_version", []() -> Result<String> {
      utsname uts;

      if (uname(&uts) == -1)
        return Err(DracError("uname call failed"));

      if (std::strlen(uts.release) == 0)
        return Err(DracError(DracErrorCode::ParseError, "uname returned null kernel release"));

      return String(uts.release);
    });
  }

  fn GetDiskUsage() -> Result<DiskSpace> {
    struct statvfs stat;

    if (statvfs("/", &stat) == -1)
      return Err(DracError(std::format("Failed to get filesystem stats for '/' (statvfs call failed)")));

    return DiskSpace {
      .usedBytes  = (stat.f_blocks * stat.f_frsize) - (stat.f_bfree * stat.f_frsize),
      .totalBytes = stat.f_blocks * stat.f_frsize,
    };
  }
} // namespace draconis::core::system

namespace package {
  #ifdef __NetBSD__
  fn GetPkgSrcCount(draconis::utils::cache::CacheManager& cache) -> Result<u64> {
    return GetCountFromDirectory(cache, "pkgsrc", fs::current_path().root_path() / "usr" / "pkg" / "pkgdb", true);
  }
  #else
  fn GetPkgNgCount(draconis::utils::cache::CacheManager& cache) -> Result<u64> {
    return GetCountFromDb(cache, "pkgng", "/var/db/pkg/local.sqlite", "SELECT COUNT(*) FROM packages");
  }
  #endif
} // namespace package

#endif // __FreeBSD__ || __DragonFly__ || __NetBSD__
</file>

<file path="src/Lib/Tests/CoreTypesTest.cpp">
#include <Drac++/Utils/DataTypes.hpp>
#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#include "gtest/gtest.h"

using namespace testing;
using draconis::utils::types::String, draconis::utils::types::i32, draconis::utils::types::BytesToGiB;

class CoreTypesTest : public Test {};

TEST_F(CoreTypesTest, BytesToGiB_ZeroBytes) {
  BytesToGiB   dataSize(0);
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "0.00GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_OneGiB) {
  BytesToGiB   dataSize(1073741824); // 1 * GIB (1 * 1024 * 1024 * 1024)
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "1.00GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_OnePointFiveGiB) {
  BytesToGiB   dataSize(1610612736); // 1.5 * GIB
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "1.50GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_RoundingToTwoDecimalPlaces) {
  BytesToGiB   dataSize(1325153042);
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "1.23GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_HalfGiB) {
  BytesToGiB   dataSize(536870912); // 0.5 * GIB
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "0.50GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_LargeValue) {
  BytesToGiB   dataSize(107374182400); // 100 * GIB
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "100.00GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_SmallFractionalValueRoundsToZero) {
  BytesToGiB   dataSize(1073741);
  const String formatted = std::format("{}", dataSize);
  EXPECT_EQ(formatted, "0.00GiB");
}

TEST_F(CoreTypesTest, BytesToGiB_RoundingNearBoundary) {
  BytesToGiB   dataSizeRoundDown(5368709);
  const String formattedRoundDown = std::format("{}", dataSizeRoundDown);
  EXPECT_EQ(formattedRoundDown, "0.00GiB");

  BytesToGiB   dataSizeRoundUp(10737418);
  const String formattedRoundUp = std::format("{}", dataSizeRoundUp);
  EXPECT_EQ(formattedRoundUp, "0.01GiB");
}

fn main(i32 argc, char** argv) -> i32 {
  InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
</file>

<file path="third_party/matchit.hpp">
/**
 * @file matchit.hpp
 * @brief Matchit library for pattern matching in C++
 * @author Bowen Fu
 * @copyright Copyright (c) 2021-2022 Bowen Fu
 * @license Apache-2.0 License
 * @version 1.0.0
 * @date 2022-01-01
 */

/*
 *  Copyright (c) 2021-2022 Bowen Fu
 *  Distributed Under The Apache-2.0 License
 */

#pragma once

#include <algorithm>
#include <any>
#include <array>
#include <cassert>
#include <cstdint>
#include <memory>
#include <optional>
#include <stdexcept>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>

// NOLINTBEGIN(readability-identifier-*, cppcoreguidelines-special-member-functions)
namespace matchit {
  namespace impl {
    template <typename Value, bool byRef>
    class ValueType {
     public:
      using ValueT = Value;
    };

    template <typename Value>
    class ValueType<Value, true> {
     public:
      using ValueT = Value&&;
    };

    template <typename Value, typename... Patterns>
    constexpr auto matchPatterns(Value&& value, const Patterns&... patterns);

    template <typename Value, bool byRef>
    class MatchHelper {
     private:
      using ValueT = typename ValueType<Value, byRef>::ValueT;
      ValueT mValue;
      using ValueRefT = ValueT&&;

     public:
      template <typename V>
      constexpr explicit MatchHelper(V&& value)
        : mValue { std::forward<V>(value) } {}

      template <typename... PatternPair>
      constexpr auto operator()(const PatternPair&... patterns) {
        return matchPatterns(std::forward<ValueRefT>(mValue), patterns...);
      }

      MatchHelper(const MatchHelper&) = delete;
      MatchHelper(MatchHelper&&)      = delete;
    };

    template <typename Value>
    constexpr auto match(Value&& value) {
      return MatchHelper<Value, true> { std::forward<Value>(value) };
    }

    template <typename First, typename... Values>
    constexpr auto match(First&& first, Values&&... values) {
      auto result = std::forward_as_tuple(std::forward<First>(first), std::forward<Values>(values)...);
      return MatchHelper<decltype(result), false> { std::forward<decltype(result)>(result) };
    }

    template <typename T>
    class Nullary : public T {
     public:
      using T::operator();

      constexpr Nullary(const T& t) : T(t) {}
      constexpr Nullary(T&& t) : T(std::move(t)) {}
    };

    template <typename T>
    constexpr auto nullary(const T& t) {
      return Nullary<T> { t };
    }

    template <typename T>
    constexpr auto nullary(T&& t)
      requires(!std::is_lvalue_reference_v<T>)
    {
      return Nullary<std::decay_t<T>> { std::forward<T>(t) };
    }

    template <typename T>
    class Id;
    template <typename T>
    constexpr auto expr(Id<T>& id) {
      return nullary([&] { return *id; });
    }

    template <typename T>
    constexpr auto expr(const T& v) {
      return nullary([&] { return v; });
    }

    template <typename T>
    constexpr auto expr(T&& v)
      requires(!std::is_lvalue_reference_v<T>)
    {
      using U     = std::remove_reference_t<T>;
      auto shared = std::make_shared<U>(std::forward<T>(v));
      return nullary([shared]() -> U {
        return std::move(*shared);
      });
    }

    template <typename T>
    constexpr auto toNullary(T&& v) {
      if constexpr (std::is_invocable_v<std::decay_t<T>>)
        return std::forward<T>(v);
      else
        return expr(std::forward<T>(v));
    }

    // for constant
    template <typename T>
    class EvalTraits {
     public:
      template <typename... Args>
      constexpr static auto evalImpl(const T& v, const Args&... /*unused*/) -> decltype(auto) {
        return v;
      }
    };

    template <typename T>
    class EvalTraits<Nullary<T>> {
     public:
      constexpr static auto evalImpl(const Nullary<T>& e) -> decltype(auto) {
        return e();
      }
    };

    // Only allowed in nullary
    template <typename T>
    class EvalTraits<Id<T>> {
     public:
      constexpr static auto evalImpl(const Id<T>& id) -> decltype(auto) {
        return *id;
      }
    };

    template <typename Pred>
    class Meet;

    // Unary is an alias of Meet.
    template <typename T>
    using Unary = Meet<T>;

    template <typename T>
    class EvalTraits<Unary<T>> {
     public:
      template <typename Arg>
      constexpr static auto evalImpl(const Unary<T>& e, const Arg& arg) -> decltype(auto) {
        return e(arg);
      }
    };

    class Wildcard;
    template <>
    class EvalTraits<Wildcard> {
     public:
      template <typename Arg>
      constexpr static auto evalImpl(const Wildcard& /*unused*/, const Arg& arg) -> decltype(auto) {
        return arg;
      }
    };

    template <typename T, typename... Args>
    constexpr auto evaluate_(const T& t, const Args&... args) -> decltype(auto) {
      return EvalTraits<T>::evalImpl(t, args...);
    }

    template <typename T>
    class IsNullaryOrId : public std::false_type {};

    template <typename T>
    class IsNullaryOrId<Id<T>> : public std::true_type {};

    template <typename T>
    class IsNullaryOrId<Nullary<T>> : public std::true_type {};

    template <typename T>
    constexpr bool isNullaryOrIdV = IsNullaryOrId<std::decay_t<T>>::value;

#define UN_OP_FOR_NULLARY(op)                        \
  template <typename T>                              \
  constexpr auto operator op(T const& t)             \
    requires isNullaryOrIdV<T>                       \
  {                                                  \
    return nullary([&] { return op evaluate_(t); }); \
  }

#define BIN_OP_FOR_NULLARY(op)                                    \
  template <typename T, typename U>                               \
  constexpr auto operator op(T const& t, U const& u)              \
    requires isNullaryOrIdV<T> || isNullaryOrIdV<U>               \
  {                                                               \
    return nullary([&] { return evaluate_(t) op evaluate_(u); }); \
  }

    // ADL will find these operators.
    UN_OP_FOR_NULLARY(!)
    UN_OP_FOR_NULLARY(-)

#undef UN_OP_FOR_NULLARY

    BIN_OP_FOR_NULLARY(+)
    BIN_OP_FOR_NULLARY(-)
    BIN_OP_FOR_NULLARY(*)
    BIN_OP_FOR_NULLARY(/)
    BIN_OP_FOR_NULLARY(%)
    BIN_OP_FOR_NULLARY(<)
    BIN_OP_FOR_NULLARY(<=)
    BIN_OP_FOR_NULLARY(==)
    BIN_OP_FOR_NULLARY(!=)
    BIN_OP_FOR_NULLARY(>=)
    BIN_OP_FOR_NULLARY(>)
    BIN_OP_FOR_NULLARY(||)
    BIN_OP_FOR_NULLARY(&&)
    BIN_OP_FOR_NULLARY(^)

#undef BIN_OP_FOR_NULLARY

    // Unary
    template <typename T>
    class IsUnaryOrWildcard : public std::false_type {};

    template <>
    class IsUnaryOrWildcard<Wildcard> : public std::true_type {};

    template <typename T>
    class IsUnaryOrWildcard<Unary<T>> : public std::true_type {};

    template <typename T>
    constexpr bool isUnaryOrWildcardV = IsUnaryOrWildcard<std::decay_t<T>>::value;

    // unary is an alias of meet.
    template <typename T>
    constexpr auto unary(T&& t) {
      return meet(std::forward<T>(t));
    }

#define UN_OP_FOR_UNARY(op)                                                   \
  template <typename T>                                                       \
  constexpr auto operator op(T const& t)                                      \
    requires isUnaryOrWildcardV<T>                                            \
  {                                                                           \
    return unary([&](auto&& arg) constexpr { return op evaluate_(t, arg); }); \
  }

#define BIN_OP_FOR_UNARY(op)                                                                    \
  template <typename T, typename U>                                                             \
  constexpr auto operator op(T const& t, U const& u)                                            \
    requires isUnaryOrWildcardV<T> || isUnaryOrWildcardV<U>                                     \
  {                                                                                             \
    return unary([&](auto&& arg) constexpr { return evaluate_(t, arg) op evaluate_(u, arg); }); \
  }

    UN_OP_FOR_UNARY(!)
    UN_OP_FOR_UNARY(-)

#undef UN_OP_FOR_UNARY

    BIN_OP_FOR_UNARY(+)
    BIN_OP_FOR_UNARY(-)
    BIN_OP_FOR_UNARY(*)
    BIN_OP_FOR_UNARY(/)
    BIN_OP_FOR_UNARY(%)
    BIN_OP_FOR_UNARY(<)
    BIN_OP_FOR_UNARY(<=)
    BIN_OP_FOR_UNARY(==)
    BIN_OP_FOR_UNARY(!=)
    BIN_OP_FOR_UNARY(>=)
    BIN_OP_FOR_UNARY(>)
    BIN_OP_FOR_UNARY(||)
    BIN_OP_FOR_UNARY(&&)
    BIN_OP_FOR_UNARY(^)

#undef BIN_OP_FOR_UNARY

    template <typename I, typename S = I>
    class Subrange {
      I mBegin;
      S mEnd;

     public:
      constexpr Subrange(const I begin, const S end)
        : mBegin { begin }, mEnd { end } {}

      constexpr Subrange(const Subrange& other)
        : mBegin { other.begin() }, mEnd { other.end() } {}

      auto operator=(const Subrange& other) -> Subrange& {
        if (this == &other)
          return *this;

        mBegin = other.begin();
        mEnd   = other.end();

        return *this;
      }

      [[nodiscard]] auto size() const -> size_t {
        return static_cast<size_t>(std::distance(mBegin, mEnd));
      }

      [[nodiscard]] auto begin() const {
        return mBegin;
      }

      [[nodiscard]] auto end() const {
        return mEnd;
      }
    };

    template <typename I, typename S>
    constexpr auto makeSubrange(I begin, S end) {
      return Subrange<I, S> { begin, end };
    }

    template <typename RangeType>
    class IterUnderlyingType {
     public:
      using beginT = decltype(std::begin(std::declval<RangeType&>()));
      using endT   = decltype(std::end(std::declval<RangeType&>()));
    };

    // force array iterators fallback to pointers.
    template <typename ElemT, size_t size>
    class IterUnderlyingType<std::array<ElemT, size>> {
     public:
      using beginT = decltype(&*std::begin(std::declval<std::array<ElemT, size>&>()));
      using endT   = beginT;
    };

    // force array iterators fallback to pointers.
    template <typename ElemT, size_t size>
    class IterUnderlyingType<const std::array<ElemT, size>> {
     public:
      using beginT = decltype(&*std::begin(std::declval<const std::array<ElemT, size>&>()));
      using endT   = beginT;
    };

    template <typename RangeType>
    using SubrangeT =
      Subrange<typename IterUnderlyingType<RangeType>::beginT, typename IterUnderlyingType<RangeType>::endT>;

    template <typename I, typename S>
    auto operator==(const Subrange<I, S>& lhs, const Subrange<I, S>& rhs) -> bool {
      using std::operator==;
      return lhs.size() == rhs.size() && std::equal(lhs.begin(), lhs.end(), rhs.begin());
    }

    template <typename K1, typename V1, typename K2, typename V2>
    constexpr auto operator==(const std::pair<K1, V1>& t, const std::pair<K2, V2>& u) {
      return t.first == u.first && t.second == u.second;
    }

    template <typename T, typename... Ts>
    class WithinTypes {
     public:
      constexpr static bool value = (std::is_same_v<T, Ts> || ...);
    };

    template <typename T, typename Tuple>
    class PrependUnique;

    template <typename T, typename... Ts>
    class PrependUnique<T, std::tuple<Ts...>> {
      constexpr static bool unique = !WithinTypes<T, Ts...>::value;

     public:
      using type = std::conditional_t<unique, std::tuple<T, Ts...>, std::tuple<Ts...>>;
    };

    template <typename T, typename Tuple>
    using PrependUniqueT = typename PrependUnique<T, Tuple>::type;

    template <typename Tuple>
    class Unique;

    template <typename... Ts>
    using UniqueT = typename Unique<std::tuple<Ts...>>::type;

    template <>
    class Unique<std::tuple<>> {
     public:
      using type = std::tuple<>;
    };

    template <typename T, typename... Ts>
    class Unique<std::tuple<T, Ts...>> {
     public:
      using type = PrependUniqueT<T, UniqueT<Ts...>>;
    };

    static_assert(std::is_same_v<std::tuple<int32_t>, UniqueT<int32_t, int32_t>>);
    static_assert(std::is_same_v<std::tuple<std::tuple<>, int32_t>, UniqueT<int32_t, std::tuple<>, int32_t>>);

    using std::get;

    namespace detail {
      template <std::size_t start, class Tuple, std::size_t... I>
      constexpr auto subtupleImpl(Tuple&& t, std::index_sequence<I...> /*unused*/) -> decltype(auto) {
        return std::forward_as_tuple(get<start + I>(std::forward<Tuple>(t))...);
      }
    } // namespace detail

    // [start, end)
    template <std::size_t start, std::size_t end, class Tuple>
    constexpr auto subtuple(Tuple&& t) -> decltype(auto) {
      constexpr size_t tupleSize = std::tuple_size_v<std::remove_reference_t<Tuple>>;
      static_assert(start <= end);
      static_assert(end <= tupleSize);
      return detail::subtupleImpl<start>(std::forward<Tuple>(t), std::make_index_sequence<end - start> {});
    }

    template <std::size_t start, class Tuple>
    constexpr auto drop(Tuple&& t) -> decltype(auto) {
      constexpr size_t tupleSize = std::tuple_size_v<std::remove_reference_t<Tuple>>;
      static_assert(start <= tupleSize);
      return subtuple<start, tupleSize>(std::forward<Tuple>(t));
    }

    template <std::size_t len, class Tuple>
    constexpr auto take(Tuple&& t) -> decltype(auto) {
      constexpr size_t tupleSize = std::tuple_size_v<std::remove_reference_t<Tuple>>;
      static_assert(len <= tupleSize);
      return subtuple<0, len>(std::forward<Tuple>(t));
    }

    template <class F, class Tuple>
    constexpr auto apply_(F&& f, Tuple&& t) -> decltype(auto) {
      return std::apply(std::forward<F>(f), drop<0>(std::forward<Tuple>(t)));
    }

    // as constexpr
    template <class F, class... Args>
    constexpr auto invoke_(F&& f, Args&&... args) noexcept(std::is_nothrow_invocable_v<F, Args...>) -> std::invoke_result_t<F, Args...> {
      return std::apply(std::forward<F>(f), std::forward_as_tuple(std::forward<Args>(args)...));
    }

    template <class T>
    struct decayArray {
     private:
      using U = std::remove_reference_t<T>;

     public:
      using type = std::conditional_t<std::is_array_v<U>, std::remove_extent_t<U>*, T>;
    };

    template <class T>
    using decayArrayT = typename decayArray<T>::type;

    static_assert(std::is_same_v<decayArrayT<int32_t*>, int32_t*>);
    static_assert(std::is_same_v<decayArrayT<const int32_t*>, const int32_t*>);
    static_assert(std::is_same_v<decayArrayT<const int32_t&>, const int32_t&>);

    template <typename T>
    struct AddConstToPointer {
      using type =
        std::conditional_t<!std::is_pointer_v<T>, T, std::add_pointer_t<std::add_const_t<std::remove_pointer_t<T>>>>;
    };

    template <typename T>
    using AddConstToPointerT = typename AddConstToPointer<T>::type;

    static_assert(std::is_same_v<AddConstToPointerT<void*>, const void*>);
    static_assert(std::is_same_v<AddConstToPointerT<int32_t>, int32_t>);

    template <typename Pattern>
    using InternalPatternT = std::remove_reference_t<AddConstToPointerT<decayArrayT<Pattern>>>;

    template <typename Pattern>
    class PatternTraits;

    template <typename... PatternPairs>
    class PatternPairsRetType {
     public:
      using RetType = std::common_type_t<typename PatternPairs::RetType...>;
    };

    enum class IdProcess : uint8_t {
      kCANCEL,
      kCONFIRM,
    };

    template <typename Pattern>
    constexpr void processId(const Pattern& pattern, int32_t depth, IdProcess idProcess) {
      PatternTraits<Pattern>::processIdImpl(pattern, depth, idProcess);
    }

    template <typename Tuple>
    class Variant;

    template <typename T, typename... Ts>
    class Variant<std::tuple<T, Ts...>> {
     public:
      using type = std::variant<std::monostate, T, Ts...>;
    };

    template <typename... Ts>
    using UniqVariant = typename Variant<UniqueT<Ts...>>::type;

    template <typename... Ts>
    class Context {
      using ElementT   = UniqVariant<Ts...>;
      using ContainerT = std::array<ElementT, sizeof...(Ts)>;
      ContainerT mMemHolder;
      size_t     mSize = 0;

     public:
      template <typename T>
      constexpr auto emplace_back(T&& t) -> void {
        mMemHolder[mSize] = std::forward<T>(t);
        ++mSize;
      }
      constexpr auto back() -> ElementT& {
        return mMemHolder[mSize - 1];
      }
    };

    template <>
    class Context<> {};

    template <typename T>
    class ContextTrait;

    template <typename... Ts>
    class ContextTrait<std::tuple<Ts...>> {
     public:
      using ContextT = Context<Ts...>;
    };

    template <typename Value, typename Pattern, typename ConctextT>
    constexpr auto matchPattern(Value&& value, const Pattern& pattern, int32_t depth, ConctextT& context) {
      const auto result  = PatternTraits<Pattern>::matchPatternImpl(std::forward<Value>(value), pattern, depth, context);
      const auto process = result ? IdProcess::kCONFIRM : IdProcess::kCANCEL;
      processId(pattern, depth, process);
      return result;
    }

    template <typename Pattern, typename Func>
    class PatternPair {
     public:
      using RetType  = std::invoke_result_t<Func>;
      using PatternT = Pattern;

      constexpr PatternPair(const Pattern& pattern, const Func& func)
        : mPattern { pattern }, mHandler { func } {}

      template <typename Value, typename ContextT>
      constexpr auto matchValue(Value&& value, ContextT& context) const -> bool {
        return matchPattern(std::forward<Value>(value), mPattern, /*depth*/ 0, context);
      }

      constexpr auto execute() const {
        return mHandler();
      }

     private:
      Pattern                                                               mPattern;
      std::conditional_t<std::is_function_v<Func>, const Func&, const Func> mHandler;
    };

    template <typename Pattern, typename Pred>
    class PostCheck;

    template <typename Pred>
    class When {
     public:
      Pred mPred;
    };

    template <typename Pred>
    constexpr auto when(Pred&& pred) {
      auto p = toNullary(std::forward<Pred>(pred));
      return When<decltype(p)> { p };
    }

    template <typename Pattern>
    class PatternHelper {
     public:
      constexpr explicit PatternHelper(const Pattern& pattern)
        : mPattern { pattern } {}

      template <typename Func>
      constexpr auto operator=(Func&& func) { // NOLINT(misc-unconventional-assign-operator, cppcoreguidelines-c-copy-assignment-signature)
        auto f = toNullary(std::forward<Func>(func));
        return PatternPair<Pattern, decltype(f)> { mPattern, f };
      }

      template <typename Pred>
      constexpr auto operator|(const When<Pred>& w) {
        return PatternHelper<PostCheck<Pattern, Pred>>(PostCheck(mPattern, w.mPred));
      }

     private:
      Pattern mPattern;
    };

    template <typename... Patterns>
    class Ds;

    template <typename... Patterns>
    constexpr auto ds(const Patterns&... patterns) -> Ds<Patterns...>;

    template <typename Pattern>
    class OooBinder;

    class PatternPipable {
     public:
      template <typename Pattern>
      // ReSharper disable once CppDFAUnreachableFunctionCall
      constexpr auto operator|(const Pattern& p) const -> PatternHelper<Pattern> {
        return PatternHelper<Pattern> { p };
      }

      template <typename T>
      constexpr auto operator|(const T* p) const -> PatternHelper<const T*> {
        return PatternHelper<const T*> { p };
      }

      template <typename Pattern>
      constexpr auto operator|(const OooBinder<Pattern>& p) const -> PatternHelper<Pattern> {
        return operator|(ds(p));
      }
    };

    constexpr PatternPipable is {};

    template <typename Pattern>
    class PatternTraits {
     public:
      template <typename Value>
      using AppResultTuple = std::tuple<>;

      constexpr static int nbIdV = 0;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const Pattern& pattern, int32_t /* depth */, ContextT& /*context*/) -> bool {
        return pattern == std::forward<Value>(value);
      }
      constexpr static void processIdImpl(const Pattern& /*unused*/, int32_t /*depth*/, IdProcess /*unused*/) {}
    };

    class Wildcard {};

    constexpr Wildcard _;

    template <>
    class PatternTraits<Wildcard> {
      using Pattern = Wildcard;

     public:
      template <typename Value>
      using AppResultTuple = std::tuple<>;

      constexpr static int nbIdV = 0;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& /*unused*/, const Pattern& /*unused*/, int32_t /*unused*/, ContextT& /*unused*/) -> bool {
        return true;
      }
      constexpr static auto processIdImpl(const Pattern& /*unused*/, int32_t /*depth*/, IdProcess /*unused*/) -> void {}
    };

    template <typename... Patterns>
    class Or {
     public:
      constexpr explicit Or(const Patterns&... patterns)
        : mPatterns { patterns... } {}
      constexpr auto patterns() const -> const std::tuple<InternalPatternT<Patterns>...>& {
        return mPatterns;
      }

     private:
      std::tuple<InternalPatternT<Patterns>...> mPatterns;
    };

    template <typename... Patterns>
    constexpr auto or_(const Patterns&... patterns) -> Or<Patterns...> {
      return Or<Patterns...> { patterns... };
    }

    template <typename... Patterns>
    class PatternTraits<Or<Patterns...>> {
     public:
      template <typename Value>
      using AppResultTuple =
        decltype(std::tuple_cat(typename PatternTraits<Patterns>::template AppResultTuple<Value> {}...));

      constexpr static int nbIdV = (PatternTraits<Patterns>::nbIdV + ... + 0);

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const Or<Patterns...>& orPat, int32_t depth, ContextT& context) -> bool {
        constexpr uint64_t patSize = sizeof...(Patterns);
        return std::apply(
                 [&value, depth, &context](const auto&... patterns) {
                   return (matchPattern(value, patterns, depth + 1, context) || ...);
                 },
                 take<patSize - 1>(orPat.patterns())
               ) ||
          matchPattern(std::forward<Value>(value), get<patSize - 1>(orPat.patterns()), depth + 1, context);
      }
      constexpr static void processIdImpl(const Or<Patterns...>& orPat, int32_t depth, IdProcess idProcess) {
        return std::apply(
          [depth, idProcess](const auto&... patterns) { return (processId(patterns, depth, idProcess), ...); },
          orPat.patterns()
        );
      }
    };

    template <typename Pred>
    class Meet : public Pred {
     public:
      using Pred::operator();
    };

    template <typename Pred>
    constexpr auto meet(const Pred& pred) -> Meet<Pred> {
      return Meet<Pred> { pred };
    }

    template <typename Pred>
    class PatternTraits<Meet<Pred>> {
     public:
      template <typename Value>
      using AppResultTuple = std::tuple<>;

      constexpr static int nbIdV = 0;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const Meet<Pred>& meetPat, int32_t /* depth */, ContextT& /*unused*/) -> bool {
        return meetPat(std::forward<Value>(value));
      }

      constexpr static auto processIdImpl(const Meet<Pred>& /*unused*/, int32_t /*depth*/, IdProcess /*unused*/) -> void {}
    };

    template <typename Unary, typename Pattern>
    class App {
     public:
      constexpr App(Unary&& unary, const Pattern& pattern)
        : mUnary { std::move(unary) }, mPattern { pattern } {}

      [[nodiscard]] constexpr auto unary() const -> const Unary& {
        return mUnary;
      }
      [[nodiscard]] constexpr auto pattern() const -> const InternalPatternT<Pattern>& {
        return mPattern;
      }

     private:
      std::decay_t<Unary>       mUnary;
      InternalPatternT<Pattern> mPattern;
    };

    template <typename Unary, typename Pattern>
    constexpr auto app(Unary&& unary, const Pattern& pattern) -> App<Unary, Pattern> {
      return { std::forward<Unary>(unary), pattern };
    }

    constexpr int y = 1;
    static_assert(std::holds_alternative<const int32_t*>(std::variant<std::monostate, const int32_t*> { &y }));

    template <typename Unary, typename Pattern>
    class PatternTraits<App<Unary, Pattern>> {
     public:
      template <typename Value>
      using AppResult = std::invoke_result_t<Unary, Value>;
      // We store value for scalar types in Id and they can not be moved. So to
      // support constexpr.
      template <typename Value>
      using AppResultCurTuple = std::conditional_t<
        std::is_lvalue_reference_v<AppResult<Value>> || std::is_scalar_v<AppResult<Value>>,
        std::tuple<>,
        std::tuple<std::decay_t<AppResult<Value>>>>;

      template <typename Value>
      using AppResultTuple = decltype(std::tuple_cat(
        std::declval<AppResultCurTuple<Value>>(),
        std::declval<typename PatternTraits<Pattern>::template AppResultTuple<AppResult<Value>>>()
      ));

      constexpr static int nbIdV = PatternTraits<Pattern>::nbIdV;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const App<Unary, Pattern>& appPat, const int32_t depth, ContextT& context) -> bool {
        if constexpr (std::is_same_v<AppResultCurTuple<Value>, std::tuple<>>) {
          return matchPattern(
            std::forward<AppResult<Value>>(invoke_(appPat.unary(), std::forward<Value>(value))), appPat.pattern(), depth + 1, context
          );
        } else {
          context.emplace_back(invoke_(appPat.unary(), std::forward<Value>(value)));
          decltype(auto) result = get<std::decay_t<AppResult<Value>>>(context.back());
          return matchPattern(std::forward<decltype(result)>(result), appPat.pattern(), depth + 1, context);
        }
      }

      constexpr static auto processIdImpl(const App<Unary, Pattern>& appPat, int32_t depth, IdProcess idProcess) -> void {
        return processId(appPat.pattern(), depth, idProcess);
      }
    };

    template <typename... Patterns>
    class And {
     public:
      constexpr explicit And(const Patterns&... patterns)
        : mPatterns { patterns... } {}

      constexpr auto patterns() const -> const std::tuple<InternalPatternT<Patterns>...>& {
        return mPatterns;
      }

     private:
      std::tuple<InternalPatternT<Patterns>...> mPatterns;
    };

    template <typename... Patterns>
    constexpr auto and_(const Patterns&... patterns) -> And<Patterns...> {
      return { patterns... };
    }

    template <typename Tuple>
    class NbIdInTuple;

    template <typename... Patterns>
    class NbIdInTuple<std::tuple<Patterns...>> {
     public:
      constexpr static int nbIdV = (PatternTraits<std::decay_t<Patterns>>::nbIdV + ... + 0);
    };

    template <typename... Patterns>
    class PatternTraits<And<Patterns...>> {
     public:
      template <typename Value>
      using AppResultTuple =
        decltype(std::tuple_cat(std::declval<typename PatternTraits<Patterns>::template AppResultTuple<Value>>()...));

      constexpr static int nbIdV = (PatternTraits<Patterns>::nbIdV + ... + 0);

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const And<Patterns...>& andPat, int32_t depth, ContextT& context) -> bool {
        constexpr uint64_t patSize    = sizeof...(Patterns);
        const auto         exceptLast = std::apply(
          [&value, depth, &context](const auto&... patterns) {
            return (matchPattern(value, patterns, depth + 1, context) && ...);
          },
          take<patSize - 1>(andPat.patterns())
        );

        // No Id in patterns except the last one.
        if constexpr (NbIdInTuple<std::decay_t<decltype(take<patSize - 1>(andPat.patterns()))>>::nbIdV == 0) {
          return exceptLast &&
            matchPattern(std::forward<Value>(value), get<patSize - 1>(andPat.patterns()), depth + 1, context);
        } else {
          return exceptLast && matchPattern(value, get<patSize - 1>(andPat.patterns()), depth + 1, context);
        }
      }
      constexpr static void processIdImpl(const And<Patterns...>& andPat, int32_t depth, IdProcess idProcess) {
        return std::apply(
          [depth, idProcess](const auto&... patterns) { return (processId(patterns, depth, idProcess), ...); },
          andPat.patterns()
        );
      }
    };

    template <typename Pattern>
    class Not {
     public:
      explicit Not(const Pattern& pattern)
        : mPattern { pattern } {}
      [[nodiscard]] constexpr auto pattern() const -> const InternalPatternT<Pattern>& {
        return mPattern;
      }

     private:
      InternalPatternT<Pattern> mPattern;
    };

    template <typename Pattern>
    constexpr auto not_(const Pattern& pattern) -> Not<Pattern> {
      return { pattern };
    }

    template <typename Pattern>
    class PatternTraits<Not<Pattern>> {
     public:
      template <typename Value>
      using AppResultTuple = typename PatternTraits<Pattern>::template AppResultTuple<Value>;

      constexpr static int nbIdV = PatternTraits<Pattern>::nbIdV;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const Not<Pattern>& notPat, const int32_t depth, ContextT& context) -> bool {
        return !matchPattern(std::forward<Value>(value), notPat.pattern(), depth + 1, context);
      }

      constexpr static void processIdImpl(const Not<Pattern>& notPat, int32_t depth, IdProcess idProcess) {
        processId(notPat.pattern(), depth, idProcess);
      }
    };

    template <typename Ptr, typename Value, typename = std::void_t<>>
    struct StorePointer : std::false_type {};

    template <typename Type>
    using ValueVariant = std::conditional_t<
      std::is_lvalue_reference_v<Type>,
      UniqVariant<std::remove_reference_t<Type>*>,
      std::conditional_t<
        std::is_rvalue_reference_v<Type>,
        UniqVariant<std::remove_reference_t<Type>, std::remove_reference_t<Type>*>,
        std::conditional_t<
          std::is_abstract_v<std::remove_reference_t<Type>>,
          UniqVariant<std::remove_reference_t<Type>*, const std::remove_reference_t<Type>*>,
          UniqVariant<
            std::remove_reference_t<Type>,
            std::remove_reference_t<Type>*,
            const std::remove_reference_t<Type>*>>>>;

    template <typename Type, typename Value>
    struct StorePointer<Type, Value, std::void_t<decltype(std::declval<ValueVariant<Type>&>() = &std::declval<Value>())>>
      : std::is_reference<Value> {};

    static_assert(!StorePointer<char, char>::value);
    static_assert(StorePointer<char, char&>::value);
    static_assert(StorePointer<const char, const char&>::value);
    static_assert(StorePointer<const char, char&>::value);
    static_assert(StorePointer<const std::tuple<int32_t&, int32_t&>, const std::tuple<int32_t&, int32_t&>&>::value);

    template <typename... Ts>
    class Overload : public Ts... {
     public:
      using Ts::operator()...;
    };

    template <typename... Ts>
    constexpr auto overload(Ts&&... ts) -> Overload<Ts...> {
      return { std::forward<Ts>(ts)... };
    }

    template <typename Pattern>
    class OooBinder;

    class Ooo;

    template <typename Type>
    class IdTraits {
     public:
      constexpr static auto equal(const Type& lhs, const Type& rhs) -> bool {
        return lhs == rhs;
      }
    };

    template <typename Type>
    class IdBlockBase {
      int32_t mDepth {};

     private:
      ValueVariant<Type> mVariant {};

     public:
      constexpr IdBlockBase() = default;

      [[nodiscard]] constexpr auto variant() -> ValueVariant<Type>& {
        return mVariant;
      }

      constexpr void reset(const int32_t depth) {
        if (mDepth - depth >= 0) {
          mVariant = {};
          mDepth   = depth;
        }
      }

      constexpr void confirm(const int32_t depth) {
        if (mDepth > depth || mDepth == 0) {
          assert(depth == mDepth - 1 || depth == mDepth || mDepth == 0);
          mDepth = depth;
        }
      }
    };

    constexpr IdBlockBase<int> dummy;

    template <typename Type>
    class IdBlock : public IdBlockBase<Type> {
     public:
      [[nodiscard]] constexpr auto hasValue() const -> bool {
        return std::visit(
          overload(
            [](const Type&) { return true; },
            [](const Type*) { return true; },
            [](const std::monostate&) { return false; }
          ),
          IdBlockBase<Type>::mVariant
        );
      }

      [[nodiscard]] constexpr auto get() const -> decltype(auto) {
        return std::visit(
          overload(
            [](const Type& v) -> Type { return v; },
            [](const Type* p) -> const Type& { return *p; },
            [](Type* p) -> const Type& { return *p; },
            [](const std::monostate&) -> const Type& { throw std::logic_error("invalid state!"); }
          ),
          IdBlockBase<Type>::mVariant
        );
      }
    };

    template <typename Type>
    class IdBlock<const Type&> : public IdBlock<Type> {};

    template <typename Type>
    class IdBlock<Type&> : public IdBlockBase<Type&> {
     public:
      [[nodiscard]] constexpr auto hasValue() const -> bool {
        return std::visit(
          overload([](Type*) { return true; }, [](const std::monostate&) { return false; }),
          IdBlockBase<Type&>::mVariant
        );
      }

      [[nodiscard]] constexpr auto get() -> decltype(auto) {
        return std::visit(
          overload(
            [](Type* v) -> Type& {
              if (v == nullptr) {
                throw std::logic_error("Trying to dereference a nullptr!");
              }
              return *v;
            },
            [](std::monostate&) -> Type& { throw std::logic_error("Invalid state!"); }
          ),
          IdBlockBase<Type&>::mVariant
        );
      }
    };

    template <typename Type>
    class IdBlock<Type&&> : public IdBlockBase<Type&&> {
     public:
      [[nodiscard]] constexpr auto hasValue() const -> bool {
        return std::visit(
          overload(
            [](const Type&) { return true; }, [](Type*) { return true; }, [](const std::monostate&) { return false; }
          ),
          IdBlockBase<Type&&>::mVariant
        );
      }

      [[nodiscard]] constexpr auto get() -> decltype(auto) {
        return std::visit(
          overload(
            [](Type& v) -> Type& { return v; },
            [](Type* v) -> Type& {
              if (v == nullptr) {
                throw std::logic_error("Trying to dereference a nullptr!");
              }
              return *v;
            },
            [](std::monostate&) -> Type& { throw std::logic_error("Invalid state!"); }
          ),
          IdBlockBase<Type&&>::mVariant
        );
      }
    };

    template <typename Type>
    class IdUtil {
     public:
      template <typename Value>
      constexpr static auto bindValue(ValueVariant<Type>& v, Value&& value, std::false_type /* StorePointer */) {
        // for constexpr
        v = ValueVariant<Type> { std::forward<Value>(value) };
      }

      template <typename Value>
      constexpr static auto bindValue(ValueVariant<Type>& v, Value&& value, std::true_type /* StorePointer */) {
        v = ValueVariant<Type> { &std::forward<Value>(value) };
      }
    };

    template <typename Type>
    class Id {
     private:
      using BlockT   = IdBlock<Type>;
      using BlockVT  = std::variant<BlockT, BlockT*>;
      BlockVT mBlock = BlockT {};

      [[nodiscard]] constexpr auto internalValue() const -> decltype(auto) {
        return block().get();
      }

     public:
      constexpr Id() = default;

      constexpr Id(const Id& id)
        : mBlock(BlockVT { &id.block() }) {}

      // non-const to inform users not to mark Id as const.
      template <typename Pattern>
      constexpr auto at(Pattern&& pattern) -> decltype(auto) {
        return and_(std::forward<Pattern>(pattern), *this);
      }

      // non-const to inform users not to mark Id as const.
      constexpr auto at(const Ooo& /*unused*/) -> OooBinder<Type> {
        return OooBinder<Type> { *this };
      }

      [[nodiscard]] constexpr auto block() const -> BlockT& {
        return std::visit(
          overload([](BlockT& v) -> BlockT& { return v; }, [](BlockT* p) -> BlockT& { return *p; }),
          mBlock
        );
      }

      template <typename Value>
      constexpr auto matchValue(Value&& v) const -> bool {
        if (hasValue())
          return IdTraits<std::decay_t<Type>>::equal(internalValue(), v);

        IdUtil<Type>::bindValue(block().variant(), std::forward<Value>(v), StorePointer<Type, Value> {});
        return true;
      }

      constexpr auto reset(int32_t depth) const -> void {
        return block().reset(depth);
      }

      constexpr auto confirm(int32_t depth) const -> void {
        return block().confirm(depth);
      }

      [[nodiscard]] constexpr auto hasValue() const -> bool {
        return block().hasValue();
      }

      // non-const to inform users not to mark Id as const.
      [[nodiscard]] constexpr auto get() -> decltype(auto) {
        return block().get();
      }

      // non-const to inform users not to mark Id as const.
      [[nodiscard]] constexpr auto operator*() -> decltype(auto) {
        return get();
      }
    };

    template <typename Type>
    class PatternTraits<Id<Type>> {
     public:
      template <typename Value>
      using AppResultTuple = std::tuple<>;

      constexpr static bool nbIdV = true;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const Id<Type>& idPat, int32_t /* depth */, ContextT& /*unused*/) -> bool {
        return idPat.matchValue(std::forward<Value>(value));
      }

      constexpr static auto processIdImpl(const Id<Type>& idPat, int32_t depth, const IdProcess idProcess) -> void {
        switch (idProcess) {
          case IdProcess::kCANCEL:  idPat.reset(depth); break;
          case IdProcess::kCONFIRM: idPat.confirm(depth); break;
        }
      }
    };

    template <typename... Patterns>
    class Ds {
     public:
      constexpr explicit Ds(const Patterns&... patterns)
        : mPatterns { patterns... } {}

      [[nodiscard]] constexpr auto patterns() const -> const auto& {
        return mPatterns;
      }

      using Type = std::tuple<InternalPatternT<Patterns>...>;

     private:
      Type mPatterns;
    };

    template <typename... Patterns>
    constexpr auto ds(const Patterns&... patterns) -> Ds<Patterns...> {
      return Ds<Patterns...> { patterns... };
    }

    template <typename T>
    class OooBinder {
      Id<T> mId;

     public:
      explicit OooBinder(const Id<T>& id)
        : mId { id } {}

      [[nodiscard]] constexpr auto binder() const -> decltype(auto) {
        return mId;
      }
    };

    class Ooo {
     public:
      template <typename T>
      constexpr auto operator()(Id<T> id) const -> OooBinder<T> {
        return OooBinder<T> { id };
      }
    };

    constexpr Ooo ooo;

    template <>
    class PatternTraits<Ooo> {
     public:
      template <typename Value>
      using AppResultTuple = std::tuple<>;

      constexpr static bool nbIdV = false;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& /*unused*/, Ooo /*unused*/, int32_t /*depth*/, ContextT& /*unused*/) -> bool {
        return true;
      }

      constexpr static auto processIdImpl(Ooo /*unused*/, int32_t /*depth*/, IdProcess /*unused*/) -> void {}
    };

    template <typename Pattern>
    class PatternTraits<OooBinder<Pattern>> {
     public:
      template <typename Value>
      using AppResultTuple = typename PatternTraits<Pattern>::template AppResultTuple<Value>;

      constexpr static bool nbIdV = PatternTraits<Pattern>::nbIdV;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(Value&& value, const OooBinder<Pattern>& oooBinderPat, const int32_t depth, ContextT& context) {
        return matchPattern(std::forward<Value>(value), oooBinderPat.binder(), depth + 1, context);
      }

      constexpr static auto processIdImpl(const OooBinder<Pattern>& oooBinderPat, int32_t depth, IdProcess idProcess) -> void {
        processId(oooBinderPat.binder(), depth, idProcess);
      }
    };

    template <typename T>
    class IsOoo : public std::false_type {};

    template <>
    class IsOoo<Ooo> : public std::true_type {};

    template <typename T>
    class IsOooBinder : public std::false_type {};

    template <typename T>
    class IsOooBinder<OooBinder<T>> : public std::true_type {};

    template <typename T>
    constexpr bool isOooBinderV = IsOooBinder<std::decay_t<T>>::value;

    template <typename T>
    constexpr bool isOooOrBinderV = IsOoo<std::decay_t<T>>::value || isOooBinderV<T>;

    template <typename... Patterns>
    constexpr size_t nbOooOrBinderV = ((isOooOrBinderV<Patterns> ? 1 : 0) + ... + 0);

    static_assert(nbOooOrBinderV<int32_t&, const Ooo&, const char*, Wildcard, const Ooo> == 2);

    template <typename Tuple, std::size_t... I>
    constexpr auto findOooIdxImpl(std::index_sequence<I...> /*unused*/) -> std::size_t {
      return ((isOooOrBinderV<decltype(get<I>(std::declval<Tuple>()))> ? I : 0) + ...);
    }

    template <typename Tuple>
    constexpr auto findOooIdx() -> std::size_t {
      return findOooIdxImpl<Tuple>(std::make_index_sequence<std::tuple_size_v<std::remove_reference_t<Tuple>>> {});
    }

    static_assert(isOooOrBinderV<Ooo>);
    static_assert(isOooOrBinderV<OooBinder<int32_t>>);
    static_assert(findOooIdx<std::tuple<int32_t, OooBinder<int32_t>, const char*>>() == 1);
    static_assert(findOooIdx<std::tuple<int32_t, Ooo, const char*>>() == 1);

    using std::get;

    template <std::size_t valueStartIdx, std::size_t patternStartIdx, std::size_t... I, typename ValueTuple, typename PatternTuple, typename ContextT>
    constexpr auto matchPatternMultipleImpl(ValueTuple&& valueTuple, PatternTuple&& patternTuple, const int32_t depth, ContextT& context, std::index_sequence<I...> /*unused*/) -> decltype(auto) {
      const auto func = [&]<typename T>(T&& value, auto&& pattern) { return matchPattern(std::forward<T>(value), pattern, depth + 1, context); };

      static_cast<void>(func);

      return (func(get<I + valueStartIdx>(std::forward<ValueTuple>(valueTuple)), std::get<I + patternStartIdx>(patternTuple)) && ...);
    }

    template <std::size_t valueStartIdx, std::size_t patternStartIdx, std::size_t size, typename ValueTuple, typename PatternTuple, typename ContextT>
    constexpr auto matchPatternMultiple(ValueTuple&& valueTuple, PatternTuple&& patternTuple, int32_t depth, ContextT& context) -> decltype(auto) {
      return matchPatternMultipleImpl<valueStartIdx, patternStartIdx>(
        std::forward<ValueTuple>(valueTuple), std::forward<PatternTuple>(patternTuple), depth, context, std::make_index_sequence<size> {}
      );
    }

    template <std::size_t patternStartIdx, std::size_t... I, typename RangeBegin, typename PatternTuple, typename ContextT>
    constexpr auto matchPatternRangeImpl(RangeBegin&& rangeBegin, PatternTuple&& patternTuple, const int32_t depth, ContextT& context, std::index_sequence<I...> /*unused*/) -> decltype(auto) {
      const auto func = [&]<typename T>(T&& value, auto&& pattern) { return matchPattern(std::forward<T>(value), pattern, depth + 1, context); };

      static_cast<void>(func);

      auto it = rangeBegin;

      bool result = true;

      ((result = result && func(*it, std::get<I + patternStartIdx>(patternTuple)), ++it), ...);

      return result;
    }

    template <std::size_t patternStartIdx, std::size_t size, typename ValueRangeBegin, typename PatternTuple, typename ContextT>
    constexpr auto matchPatternRange(
      ValueRangeBegin&& valueRangeBegin,
      PatternTuple&&    patternTuple,
      int32_t           depth,
      ContextT&         context
    ) {
      return matchPatternRangeImpl<patternStartIdx>(
        std::forward<ValueRangeBegin>(valueRangeBegin), std::forward<PatternTuple>(patternTuple), depth, context, std::make_index_sequence<size> {}
      );
    }

    template <std::size_t start, typename Indices, typename Tuple>
    class IndexedTypes;

    template <typename Tuple, std::size_t start, std::size_t... I>
    class IndexedTypes<start, std::index_sequence<I...>, Tuple> {
     public:
      using type = std::tuple<std::decay_t<decltype(std::get<start + I>(std::declval<Tuple>()))>...>;
    };

    template <std::size_t start, std::size_t end, class Tuple>
    class SubTypes {
      constexpr static size_t tupleSize = std::tuple_size_v<std::remove_reference_t<Tuple>>;
      static_assert(start <= end);
      static_assert(end <= tupleSize);

      using Indices = std::make_index_sequence<end - start>;

     public:
      using type = typename IndexedTypes<start, Indices, Tuple>::type;
    };

    template <std::size_t start, std::size_t end, class Tuple>
    using SubTypesT = typename SubTypes<start, end, Tuple>::type;

    static_assert(std::is_same_v<std::tuple<std::nullptr_t>, SubTypesT<3, 4, std::tuple<char, bool, int32_t, std::nullptr_t>>>);
    static_assert(std::is_same_v<std::tuple<char>, SubTypesT<0, 1, std::tuple<char, bool, int32_t, std::nullptr_t>>>);
    static_assert(std::is_same_v<std::tuple<>, SubTypesT<1, 1, std::tuple<char, bool, int32_t, std::nullptr_t>>>);
    static_assert(std::is_same_v<std::tuple<int32_t, std::nullptr_t>, SubTypesT<2, 4, std::tuple<char, bool, int32_t, std::nullptr_t>>>);

    template <typename ValueTuple>
    class IsArray : public std::false_type {};

    template <typename T, size_t s>
    class IsArray<std::array<T, s>> : public std::true_type {};

    template <typename ValueTuple>
    constexpr bool isArrayV = IsArray<std::decay_t<ValueTuple>>::value;

    template <typename Value, typename = std::void_t<>>
    struct IsTupleLike : std::false_type {};

    template <typename Value>
    struct IsTupleLike<Value, std::void_t<decltype(std::tuple_size<Value>::value)>> : std::true_type {};

    template <typename ValueTuple>
    constexpr bool isTupleLikeV = IsTupleLike<std::decay_t<ValueTuple>>::value;

    static_assert(isTupleLikeV<std::pair<int32_t, char>>);
    static_assert(!isTupleLikeV<bool>);

    template <typename Value, typename = std::void_t<>>
    struct IsRange : std::false_type {};

    template <typename Value>
    struct IsRange<Value, std::void_t<decltype(std::begin(std::declval<Value>())), decltype(std::end(std::declval<Value>()))>>
      : std::true_type {};

    template <typename ValueTuple>
    constexpr bool isRangeV = IsRange<std::decay_t<ValueTuple>>::value;

    static_assert(!isRangeV<std::pair<int32_t, char>>);
    static_assert(isRangeV<const std::array<int32_t, 5>>);

    template <typename... Patterns>
    class PatternTraits<Ds<Patterns...>> {
      constexpr static size_t nbOooOrBinder = nbOooOrBinderV<Patterns...>;
      static_assert(nbOooOrBinder == 0 || nbOooOrBinder == 1);

     public:
      template <typename PsTuple, typename VsTuple>
      class PairPV;

      template <typename... Ps, typename... Vs>
      class PairPV<std::tuple<Ps...>, std::tuple<Vs...>> {
       public:
        using type = decltype(std::tuple_cat(std::declval<typename PatternTraits<Ps>::template AppResultTuple<Vs>>()...));
      };

      template <std::size_t nbOoos, typename ValueTuple>
      class AppResultForTupleHelper;

      template <typename... Values>
      class AppResultForTupleHelper<0, std::tuple<Values...>> {
       public:
        using type = decltype(std::tuple_cat(std::declval<typename PatternTraits<Patterns>::template AppResultTuple<Values>>()...));
      };

      template <typename... Values>
      class AppResultForTupleHelper<1, std::tuple<Values...>> {
        constexpr static size_t idxOoo = findOooIdx<typename Ds<Patterns...>::Type>();
        using Ps0                      = SubTypesT<0, idxOoo, std::tuple<Patterns...>>;
        using Vs0                      = SubTypesT<0, idxOoo, std::tuple<Values...>>;
        constexpr static bool isBinder = isOooBinderV<std::tuple_element_t<idxOoo, std::tuple<Patterns...>>>;
        // <0, ...int32_t> to workaround compile failure for std::tuple<>.
        using ElemT                          = std::tuple_element_t<0, std::tuple<std::remove_reference_t<Values>..., int32_t>>;
        constexpr static int64_t diff        = static_cast<int64_t>(sizeof...(Values) - sizeof...(Patterns));
        constexpr static size_t  clippedDiff = static_cast<size_t>(diff > 0 ? diff : 0);
        using OooResultTuple =
          std::conditional_t<isBinder, std::tuple<SubrangeT<std::array<ElemT, clippedDiff>>>, std::tuple<>>;
        using FirstHalfTuple             = typename PairPV<Ps0, Vs0>::type;
        using Ps1                        = SubTypesT<idxOoo + 1, sizeof...(Patterns), std::tuple<Patterns...>>;
        constexpr static size_t vs1Start = static_cast<size_t>(static_cast<int64_t>(idxOoo) + 1 + diff);
        using Vs1                        = SubTypesT<vs1Start, sizeof...(Values), std::tuple<Values...>>;
        using SecondHalfTuple            = typename PairPV<Ps1, Vs1>::type;

       public:
        using type = decltype(std::tuple_cat(
          std::declval<FirstHalfTuple>(),
          std::declval<OooResultTuple>(),
          std::declval<SecondHalfTuple>()
        ));
      };

      template <typename Tuple>
      using AppResultForTuple = typename AppResultForTupleHelper<nbOooOrBinder, decltype(drop<0>(std::declval<Tuple>()))>::type;

      template <typename RangeType>
      using RangeTuple = std::conditional_t<nbOooOrBinder == 1, std::tuple<SubrangeT<RangeType>>, std::tuple<>>;

      template <typename RangeType>
      using AppResultForRangeType = decltype(std::tuple_cat(
        std::declval<RangeTuple<RangeType>>(),
        std::declval<typename PatternTraits<Patterns>::template AppResultTuple<decltype(*std::begin(std::declval<RangeType>()))>>()...
      ));

      template <typename Value, typename = std::void_t<>>
      class AppResultHelper;

      template <typename Value>
      class AppResultHelper<Value, std::enable_if_t<isTupleLikeV<Value>>> {
       public:
        using type = AppResultForTuple<Value>;
      };

      template <typename RangeType>
      class AppResultHelper<RangeType, std::enable_if_t<!isTupleLikeV<RangeType> && isRangeV<RangeType>>> {
       public:
        using type = AppResultForRangeType<RangeType>;
      };

      template <typename Value>
      using AppResultTuple = typename AppResultHelper<Value>::type;

      constexpr static size_t nbIdV = (PatternTraits<Patterns>::nbIdV + ... + 0);

      template <typename ValueTuple, typename ContextT>
      constexpr static auto matchPatternImpl(ValueTuple&& valueTuple, const Ds<Patterns...>& dsPat, int32_t depth, ContextT& context)
        -> bool
        requires(isTupleLikeV<ValueTuple>)
      {
        if constexpr (nbOooOrBinder == 0) {
          return std::apply(
            [&valueTuple, depth, &context](const auto&... patterns) {
              return apply_(
                [depth, &context, &patterns...]<typename... T>(T&&... values) constexpr {
                  static_assert(sizeof...(patterns) == sizeof...(values));
                  return (matchPattern(std::forward<T>(values), patterns, depth + 1, context) && ...);
                },
                valueTuple
              );
            },
            dsPat.patterns()
          );
        } else if constexpr (nbOooOrBinder == 1) {
          constexpr size_t idxOoo   = findOooIdx<typename Ds<Patterns...>::Type>();
          constexpr bool   isBinder = isOooBinderV<std::tuple_element_t<idxOoo, std::tuple<Patterns...>>>;
          constexpr bool   isArray  = isArrayV<ValueTuple>;
          auto             result   = matchPatternMultiple<0, 0, idxOoo>(std::forward<ValueTuple>(valueTuple), dsPat.patterns(), depth, context);
          constexpr size_t valLen   = std::tuple_size_v<std::decay_t<ValueTuple>>;
          constexpr size_t patLen   = sizeof...(Patterns);

          if constexpr (isArray) {
            if constexpr (isBinder) {
              const size_t rangeSize = static_cast<long>(valLen - (patLen - 1));
              context.emplace_back(makeSubrange(&valueTuple[idxOoo], &valueTuple[idxOoo] + rangeSize));
              using type = decltype(makeSubrange(&valueTuple[idxOoo], &valueTuple[idxOoo] + rangeSize));
              result     = result &&
                matchPattern(std::get<type>(context.back()), std::get<idxOoo>(dsPat.patterns()), depth, context);
            }
          } else {
            static_assert(!isBinder);
          }

          return result && matchPatternMultiple<valLen - patLen + idxOoo + 1, idxOoo + 1, patLen - idxOoo - 1>(std::forward<ValueTuple>(valueTuple), dsPat.patterns(), depth, context);
        }

        return false;
      }

      template <typename ValueRange, typename ContextT>
      constexpr static auto matchPatternImpl(ValueRange&& valueRange, const Ds<Patterns...>& dsPat, int32_t depth, ContextT& context)
        -> bool
        requires(!isTupleLikeV<ValueRange> && isRangeV<ValueRange>)
      {
        static_assert(nbOooOrBinder == 0 || nbOooOrBinder == 1);
        constexpr size_t nbPat = sizeof...(Patterns);

        if constexpr (nbOooOrBinder == 0) {
          // size mismatch for dynamic array is not an error;
          if (std::forward<ValueRange>(valueRange).size() != nbPat)
            return false;

          return matchPatternRange<0, nbPat>(std::begin(std::forward<ValueRange>(valueRange)), dsPat.patterns(), depth, context);
        } else if constexpr (nbOooOrBinder == 1) {
          if (std::forward<ValueRange>(valueRange).size() < nbPat - 1)
            return false;

          constexpr auto   idxOoo   = findOooIdx<typename Ds<Patterns...>::Type>();
          constexpr auto   isBinder = isOooBinderV<std::tuple_element_t<idxOoo, std::tuple<Patterns...>>>;
          auto             result   = matchPatternRange<0, idxOoo>(std::begin(std::forward<ValueRange>(valueRange)), dsPat.patterns(), depth, context);
          const size_t     valLen   = std::forward<ValueRange>(valueRange).size();
          constexpr size_t patLen   = sizeof...(Patterns);
          const auto       beginOoo = std::next(std::begin(std::forward<ValueRange>(valueRange)), idxOoo);

          if constexpr (isBinder) {
            const size_t rangeSize = static_cast<long>(valLen - (patLen - 1));
            const auto   end       = std::next(beginOoo, rangeSize);
            context.emplace_back(makeSubrange(beginOoo, end));
            using type = decltype(makeSubrange(beginOoo, end));
            result     = result &&
              matchPattern(std::get<type>(context.back()), std::get<idxOoo>(dsPat.patterns()), depth, context);
          }

          const auto beginAfterOoo = std::next(beginOoo, static_cast<long>(valLen - patLen + 1));
          return result &&
            matchPatternRange<idxOoo + 1, patLen - idxOoo - 1>(beginAfterOoo, dsPat.patterns(), depth, context);
        }

        return false;
      }

      constexpr static auto processIdImpl(const Ds<Patterns...>& dsPat, int32_t depth, IdProcess idProcess) -> void {
        return std::apply(
          [depth, idProcess](auto&&... patterns) { return (processId(patterns, depth, idProcess), ...); },
          dsPat.patterns()
        );
      }
    };

    static_assert(std::is_same_v<PatternTraits<Ds<OooBinder<SubrangeT<const std::array<int32_t, 2>>>>>::AppResultTuple<const std::array<int32_t, 2>>, std::tuple<matchit::impl::Subrange<const int32_t*>>>);
    static_assert(std::is_same_v<PatternTraits<Ds<OooBinder<Subrange<int32_t*>>, matchit::impl::Id<int32_t>>>::AppResultTuple<const std::array<int32_t, 3>>, std::tuple<matchit::impl::Subrange<const int32_t*>>>);
    static_assert(std::is_same_v<PatternTraits<Ds<OooBinder<Subrange<int32_t*>>, matchit::impl::Id<int32_t>>>::AppResultTuple<std::array<int32_t, 3>>, std::tuple<matchit::impl::Subrange<int32_t*>>>);

    template <typename Pattern, typename Pred>
    class PostCheck {
     public:
      constexpr explicit PostCheck(const Pattern& pattern, const Pred& pred)
        : mPattern { pattern }, mPred { pred } {}
      [[nodiscard]] constexpr auto check() const -> bool {
        return mPred();
      }

      constexpr auto pattern() const -> const Pattern& {
        return mPattern;
      }

     private:
      Pattern mPattern;
      Pred    mPred;
    };

    template <typename Pattern, typename Pred>
    class PatternTraits<PostCheck<Pattern, Pred>> {
     public:
      template <typename Value>
      using AppResultTuple = typename PatternTraits<Pattern>::template AppResultTuple<Value>;

      template <typename Value, typename ContextT>
      constexpr static auto matchPatternImpl(
        Value&&                         value,
        const PostCheck<Pattern, Pred>& postCheck,
        const int32_t                   depth,
        ContextT&                       context
      ) -> bool {
        return matchPattern(std::forward<Value>(value), postCheck.pattern(), depth + 1, context) && postCheck.check();
      }

      constexpr static auto processIdImpl(const PostCheck<Pattern, Pred>& postCheck, int32_t depth, IdProcess idProcess) -> void {
        processId(postCheck.pattern(), depth, idProcess);
      }
    };

    static_assert(std::is_same_v<PatternTraits<Wildcard>::AppResultTuple<int32_t>, std::tuple<>>);
    static_assert(std::is_same_v<PatternTraits<int32_t>::AppResultTuple<int32_t>, std::tuple<>>);
    constexpr auto x = [](auto&& t) { return t; };
    static_assert(std::is_same_v<PatternTraits<App<decltype(x), Wildcard>>::AppResultTuple<std::array<int32_t, 3>>, std::tuple<std::array<int32_t, 3>>>);

    static_assert(PatternTraits<And<App<decltype(x), Wildcard>>>::nbIdV == 0);
    static_assert(PatternTraits<And<App<decltype(x), Id<int32_t>>>>::nbIdV == 1);
    static_assert(PatternTraits<And<Id<int32_t>, Id<float>>>::nbIdV == 2);
    static_assert(PatternTraits<Or<Id<int32_t>, Id<float>>>::nbIdV == 2);
    static_assert(PatternTraits<Or<Wildcard, float>>::nbIdV == 0);

    template <typename Value, typename... PatternPairs>
    constexpr auto matchPatterns(Value&& value, const PatternPairs&... patterns) {
      using RetType   = typename PatternPairsRetType<PatternPairs...>::RetType;
      using TypeTuple = decltype(std::tuple_cat(
        std::declval<typename PatternTraits<typename PatternPairs::PatternT>::template AppResultTuple<Value>>()...
      ));

      // expression, has return value.
      if constexpr (!std::is_same_v<RetType, void>) {
        constexpr auto func = [](const auto& pattern, auto&& val, RetType& result) constexpr -> bool {
          if (auto context = typename ContextTrait<TypeTuple>::ContextT {};
              pattern.matchValue(std::forward<Value>(val), context)) {
            result = pattern.execute();
            processId(pattern, 0, IdProcess::kCANCEL);
            return true;
          }
          return false;
        };

        RetType result {};

        const bool matched = (func(patterns, std::forward<Value>(value), result) || ...);

        if (!matched)
          throw std::logic_error { "Error: no patterns got matched!" };

        static_cast<void>(matched);
        return result;
      } else {
        const auto func = [](const auto& pattern, auto&& val) -> bool {
          if (auto context = typename ContextTrait<TypeTuple>::ContextT {};
              pattern.matchValue(std::forward<Value>(val), context)) {
            pattern.execute();
            processId(pattern, 0, IdProcess::kCANCEL);
            return true;
          }
          return false;
        };
        const bool matched = (func(patterns, std::forward<Value>(value)) || ...);
        static_cast<void>(matched);
      }
    }

    template <typename T>
    constexpr auto cast = [](auto&& input) { return static_cast<T>(input); };

    constexpr auto deref = [](auto&& x) -> decltype(*x)& { return *x; };
    constexpr auto some  = [](const auto pat) { return and_(app(cast<bool>, true), app(deref, pat)); };

    constexpr auto none = app(cast<bool>, false);

    template <typename Value, typename Variant, typename = std::void_t<>>
    struct ViaGetIf : std::false_type {};

    using std::get_if;

    template <typename T, typename Variant>
    struct ViaGetIf<T, Variant, std::void_t<decltype(get_if<T>(std::declval<const Variant*>()))>> : std::true_type {};

    template <typename T, typename Variant>
    constexpr bool viaGetIfV = ViaGetIf<T, Variant>::value;

    static_assert(viaGetIfV<int, std::variant<int, bool>>);

    template <typename T>
    class AsPointer {
      static_assert(!std::is_reference_v<T>);

     public:
      template <typename Variant>
      constexpr auto operator()(Variant&& v) const
        requires(viaGetIfV<T, std::decay_t<Variant>>)
      {
        return get_if<T>(std::addressof(std::forward<Variant>(v)));
      }

      // template to disable implicit cast to std::any
      template <typename A>
      constexpr auto operator()(A&& a) const
        requires(std::is_same_v<std::decay_t<A>, std::any>)
      {
        return std::any_cast<T>(std::addressof(std::forward<A>(a)));
      }

      // cast to base class
      template <typename D>
      constexpr auto operator()(const D& d) const -> decltype(static_cast<const T*>(std::addressof(d)))
        requires(!viaGetIfV<T, D> && std::is_base_of_v<T, D>)
      {
        return static_cast<const T*>(std::addressof(d));
      }

      // No way to handle rvalue to save copy in this class. Need to define some in another way to handle this.
      // cast to base class
      template <typename D>
      constexpr auto operator()(D& d) const -> decltype(static_cast<T*>(std::addressof(d)))
        requires(!viaGetIfV<T, D> && std::is_base_of_v<T, D>)
      {
        return static_cast<T*>(std::addressof(d));
      }

      // cast to derived class
      template <typename B>
      constexpr auto operator()(const B& b) const -> decltype(dynamic_cast<const T*>(std::addressof(b)))
        requires(!viaGetIfV<T, B> && std::is_base_of_v<B, T>)
      {
        return dynamic_cast<const T*>(std::addressof(b));
      }

      // cast to derived class
      template <typename B>
      constexpr auto operator()(B& b) const -> decltype(dynamic_cast<T*>(std::addressof(b)))
        requires(!viaGetIfV<T, B> && std::is_base_of_v<B, T>)
      {
        return dynamic_cast<T*>(std::addressof(b));
      }

      constexpr auto operator()(const T& b) const {
        return std::addressof(b);
      }

      constexpr auto operator()(T& b) const {
        return std::addressof(b);
      }
    };

    static_assert(std::is_invocable_v<AsPointer<int>, int>);
    static_assert(std::is_invocable_v<AsPointer<std::tuple<int>>, std::tuple<int>>);

    template <typename T>
    constexpr AsPointer<T> asPointer;

    template <typename T>
    constexpr auto as = [](const auto pat) { return app(asPointer<T>, some(pat)); };

    template <typename Value, typename Pattern>
    constexpr auto matched(Value&& v, Pattern&& p) {
      return match(std::forward<Value>(v))(
        is | std::forward<Pattern>(p) = [] { return true; }, is | _ = [] { return false; }
      );
    }

    constexpr auto dsVia = [](auto... members) {
      return [members...](auto... pats) { return and_(app(members, pats)...); };
    };

    template <typename T>
    constexpr auto asDsVia = [](auto... members) { return [members...](auto... pats) { return as<T>(and_(app(members, pats)...)); }; };

    constexpr auto in = [](const auto& first, const auto& last) {
      return meet([=](auto&& v) { return first <= v && v <= last; });
    };
  } // namespace impl

  using impl::_;
  using impl::and_;
  using impl::app;
  using impl::as;
  using impl::asDsVia;
  using impl::ds;
  using impl::dsVia;
  using impl::expr;
  using impl::Id;
  using impl::in;
  using impl::is;
  using impl::match;
  using impl::matched;
  using impl::meet;
  using impl::none;
  using impl::not_;
  using impl::ooo;
  using impl::or_;
  using impl::some;
  using impl::Subrange;
  using impl::SubrangeT;
  using impl::when;
} // namespace matchit
// NOLINTEND(readability-identifier-*, cppcoreguidelines-special-member-functions)
</file>

<file path="examples/meson.build">
# Vulkan
vulkan_dep = dependency('vulkan', required: true)

# GLFW
glfw_dep = dependency('glfw3', required: true, fallback: ['glfw', 'glfw_dep'])

# ImGui
imgui_dep = dependency('imgui', fallback: ['imgui', 'imgui_dep'])

link_args = []

if host_system == 'linux'
  if get_option('build_for_musl') == true
    link_args += ['-static']
  else
    link_args += ['-static-libgcc', '-static-libstdc++']
  endif
endif

# Nintendo Switch (Horizon OS) example
# Build Nintendo Switch .nro when devkitPro toolchain is available

switch_example = get_option('build_switch_example')

if switch_example
  aarch64_gpp = find_program('aarch64-none-elf-g++', required: switch_example)
  elf2nro = find_program('elf2nro', required: switch_example)
  nacptool = find_program('nacptool', required: switch_example)
  devkitpro = run_command('sh', '-c', 'printf %s "$DEVKITPRO"', check: false).stdout().strip()

  if aarch64_gpp.found() and elf2nro.found() and nacptool.found() and devkitpro != ''
    specs_arg = '-specs=' + devkitpro + '/libnx/switch.specs'
    include_arg = '-I' + devkitpro + '/libnx/include'
    lib_arg = '-L' + devkitpro + '/libnx/lib'
    proj_inc_arg = '-I' + meson.project_source_root() + '/include'
    third_party_inc_arg = '-I' + meson.project_source_root() + '/third_party'
    src_inc_arg = '-I' + meson.project_source_root() + '/src'
    lib_inc_arg = '-I' + meson.project_source_root() + '/src/Lib'

    nix_cflags = run_command('sh', '-c', 'printf %s "$NIX_CFLAGS_COMPILE"', check: false).stdout().strip().split()

    switch_nacp = custom_target(
      'switch_app_nacp',
      output: 'switch_app.nacp',
      command: [
        nacptool,
        '--create', 'switch_app', # Title
        'draconis++', # Author
        meson.project_version(),
        '@OUTPUT@',
      ],
      build_by_default: true,
      install: false,
    )

    switch_src = [
      'switch_app/main.cpp',
      meson.project_source_root() / 'src/Lib/OS/Switch.cpp',
    ]

    # Add weather service sources if weather is enabled
    if get_option('weather').enabled()
      switch_src += [
        meson.project_source_root() / 'src/Lib/Services/Weather/MetNoService.cpp',
        meson.project_source_root() / 'src/Lib/Services/Weather/OpenMeteoService.cpp',
        meson.project_source_root() / 'src/Lib/Services/Weather/OpenWeatherMapService.cpp',
        meson.project_source_root() / 'src/Lib/Services/Weather/WeatherFactory.cpp',
        meson.project_source_root() / 'src/Lib/Services/Weather/WeatherUtils.cpp',
      ]
    endif

    # Add weather feature flag and dependencies for Switch app
    weather_flag = get_option('weather').enabled() ? ['-DDRAC_ENABLE_WEATHER=1'] : []

    # Add Switch-specific defines for weather
    if get_option('weather').enabled()
      weather_flag += [
        '-D_DEFAULT_SOURCE', # Expose timegm on some platforms
        '-DDRAC_VERSION="' + meson.project_version() + '"',
      ]
    endif

    # Add libcurl for weather services if enabled
    weather_libs = []
    if get_option('weather').enabled()
      # Try to find curl in devkitPro or common Switch development locations
      curl_lib_paths = [
        devkitpro + '/portlibs/switch/lib',
        devkitpro + '/libnx/lib',
        '/opt/devkitpro/portlibs/switch/lib',
        '/opt/devkitpro/libnx/lib',
      ]

      curl_found = false
      foreach path : curl_lib_paths
        if not curl_found and run_command('test', '-f', path + '/libcurl.a', check: false).returncode() == 0
          weather_libs += ['-L' + path, '-lcurl']
          curl_found = true
        endif
      endforeach

      if not curl_found
        # Fallback to standard curl dependency
        curl_dep = dependency('libcurl', required: false)
        if curl_dep.found()
          weather_libs += ['-lcurl']
        else
          # Last resort: try standard library path
          weather_libs += ['-lcurl']
        endif
      endif

      # Add zlib dependency for curl compression support
      zlib_lib_paths = [
        devkitpro + '/portlibs/switch/lib',
        devkitpro + '/libnx/lib',
        '/opt/devkitpro/portlibs/switch/lib',
        '/opt/devkitpro/libnx/lib',
      ]

      zlib_found = false
      foreach path : zlib_lib_paths
        if not zlib_found and run_command('test', '-f', path + '/libz.a', check: false).returncode() == 0
          weather_libs += ['-L' + path, '-lz']
          zlib_found = true
        endif
      endforeach

      if not zlib_found
        # Fallback to standard zlib dependency
        zlib_dep = dependency('zlib', required: false)
        if zlib_dep.found()
          weather_libs += ['-lz']
        else
          # Last resort: try standard library path
          weather_libs += ['-lz']
        endif
      endif
    endif

    switch_elf = custom_target(
      'switch_app_elf',
      input: switch_src,
      output: 'switch_app.elf',
      command: [
        aarch64_gpp,
        '@INPUT@',
        '-o', '@OUTPUT@',
        '-std=gnu++23',
        '-D__SWITCH__', proj_inc_arg,
        '-Dfn=auto',
        third_party_inc_arg,
        src_inc_arg,
        lib_inc_arg,
      ]
      + nix_cflags
      + weather_flag
      + weather_libs
      + [
        '-g',
        '-O2',
        '-ffunction-sections',
        '-fPIE',
        '-march=armv8-a+crc+crypto',
        '-mtune=cortex-a57',
        '-mtp=soft',
        include_arg,
        specs_arg,
        lib_arg,
        '-lnx',
      ],
      build_by_default: true,
      install: false,
    )

    custom_target(
      'switch_app_nro',
      input: [switch_elf, switch_nacp],
      output: 'switch_app.nro',
      command: [elf2nro, '@INPUT0@', '@OUTPUT@', '--nacp=@INPUT1@'],
      build_by_default: true,
      install: false,
    )
  elif switch_example
    error('build_switch_example enabled but required tools not found')
  endif
endif

executable(
  'vulkan_app',
  'vulkan_app/main.cpp',
  dependencies: [draconis_dep, vulkan_dep, glfw_dep, imgui_dep] + lib_deps,
  link_args: link_args,
  install: false,
)

executable(
  'glaze_http',
  'glaze_http/main.cpp',
  dependencies: [draconis_dep] + lib_deps,
  link_args: link_args,
  install: false,
)

executable(
  'mcp_server',
  'mcp_server/main.cpp',
  dependencies: [draconis_dep] + lib_deps,
  link_args: link_args,
  install: false,
)
</file>

<file path="include/Drac++/Utils/DataTypes.hpp">
/**
 * @file DataTypes.hpp
 * @brief Defines various data structures for use in Drac++.
 *
 * This header provides a collection of data structures for use
 * in the Drac++ project.
 */

#pragma once

#include <chrono>

#include <Drac++/Utils/Types.hpp>

namespace draconis::utils::types {
  /**
   * @struct OSInfo
   * @brief Represents information about the operating system.
   */
  struct OSInfo {
    String name;
    String version;
    String id;

    OSInfo() = default;

    OSInfo(String name, String version, String identifier)
      : name(std::move(name)), version(std::move(version)), id(std::move(identifier)) {}
  };

  /**
   * @struct ResourceUsage
   * @brief Represents usage information for a resource (disk space, RAM, etc.).
   *
   * Used to report usage statistics for various system resources.
   */
  struct ResourceUsage {
    u64 usedBytes;  ///< Currently used resource space in bytes.
    u64 totalBytes; ///< Total resource space in bytes.

    ResourceUsage() = default;

    ResourceUsage(u64 usedBytes, u64 totalBytes)
      : usedBytes(usedBytes), totalBytes(totalBytes) {}
  };

  /**
   * @struct MediaInfo
   * @brief Holds structured metadata about currently playing media.
   *
   * Used as the success type for os::GetNowPlaying.
   * Using Option<> for fields that might not always be available.
   */
  struct MediaInfo {
    Option<String> title;  ///< Track title.
    Option<String> artist; ///< Track artist(s).

    MediaInfo() = default;

    MediaInfo(Option<String> title, Option<String> artist)
      : title(std::move(title)), artist(std::move(artist)) {}
  };

  constexpr u64 GIB = 1'073'741'824;

  struct BytesToGiB {
    u64 value;

    explicit constexpr BytesToGiB(const u64 value)
      : value(value) {}
  };

  struct SecondsToFormattedDuration {
    std::chrono::seconds value;

    explicit constexpr SecondsToFormattedDuration(const std::chrono::seconds value)
      : value(value) {}
  };

  enum class CPUArch : u8 {
    X86,     ///< x86 32-bit architecture.
    X86_64,  ///< x86_64 64-bit architecture.
    ARM,     ///< 32-bit ARM architecture.
    AARCH64, ///< 64-bit ARM architecture (ARMv8-A).
    UNKNOWN  ///< Unknown or unsupported architecture.
  };

  /**
   * @struct CPUCores
   * @brief Represents the number of physical and logical cores on a CPU.
   *
   * Used to report the number of physical and logical cores on a CPU.
   */
  struct CPUCores {
    usize physical; ///< Number of physical cores.
    usize logical;  ///< Number of logical cores.

    CPUCores() = default;

    CPUCores(const usize physical, const usize logical)
      : physical(physical), logical(logical) {}
  };

  struct Frequencies {
    f64 base;    ///< Base (rated) frequency in MHz.
    f64 max;     ///< Maximum (turbo) frequency in MHz.
    f64 current; ///< Current operating frequency in MHz (can fluctuate).

    Frequencies() = default;

    Frequencies(f64 base, f64 max, f64 current)
      : base(base), max(max), current(current) {}
  };

  /**
   * @struct Output
   * @brief Represents a display or monitor device.
   *
   * Used to report the display or monitor device.
   */
  struct DisplayInfo {
    usize id; ///< Output ID.

    struct Resolution {
      usize width;  ///< Width in pixels.
      usize height; ///< Height in pixels.
    } resolution;   ///< Resolution in pixels.

    f64  refreshRate; ///< Refresh rate in Hz.
    bool isPrimary;   ///< Whether the display is the primary display.

    DisplayInfo() = default;

    DisplayInfo(const usize identifier, const Resolution resolution, const f64 refreshRate, const bool isPrimary)
      : id(identifier), resolution(resolution), refreshRate(refreshRate), isPrimary(isPrimary) {}
  };

  /**
   * @struct NetworkInterface
   * @brief Represents a network interface.
   */
  struct NetworkInterface {
    String         name;        ///< Network interface name.
    Option<String> ipv4Address; ///< Network interface IPv4 address.
    Option<String> ipv6Address; ///< Network interface IPv6 address.
    Option<String> macAddress;  ///< Network interface MAC address.
    bool           isUp;        ///< Whether the network interface is up.
    bool           isLoopback;  ///< Whether the network interface is a loopback interface.

    NetworkInterface() = default;

    NetworkInterface(String name, Option<String> ipv4Address, Option<String> ipv6Address, Option<String> macAddress, bool isUp, bool isLoopback)
      : name(std::move(name)), ipv4Address(std::move(ipv4Address)), ipv6Address(std::move(ipv6Address)), macAddress(std::move(macAddress)), isUp(isUp), isLoopback(isLoopback) {}
  };

  struct Battery {
    enum class Status : u8 {
      Unknown,     ///< Battery status is unknown.
      Charging,    ///< Battery is charging.
      Discharging, ///< Battery is discharging.
      Full,        ///< Battery is fully charged.
      NotPresent   ///< No battery present.
    } status;      ///< Current battery status.

    Option<u8>                   percentage;    ///< Battery charge percentage (0-100).
    Option<std::chrono::seconds> timeRemaining; ///< Estimated time remaining in seconds, if available.

    Battery() = default;

    Battery(const Status status, const Option<u8> percentage, Option<std::chrono::seconds> timeRemaining)
      : status(status), percentage(percentage), timeRemaining(timeRemaining) {}
  };
} // namespace draconis::utils::types

namespace std {
  template <>
  struct formatter<draconis::utils::types::BytesToGiB> : formatter<draconis::utils::types::f64> {
    fn format(const draconis::utils::types::BytesToGiB& BTG, auto& ctx) const {
      return format_to(ctx.out(), "{:.2f}GiB", static_cast<draconis::utils::types::f64>(BTG.value) / draconis::utils::types::GIB);
    }
  };

  template <>
  struct formatter<draconis::utils::types::SecondsToFormattedDuration> : formatter<draconis::utils::types::String> {
    fn format(const draconis::utils::types::SecondsToFormattedDuration& stfd, auto& ctx) const {
      using draconis::utils::types::Array;
      using draconis::utils::types::String;
      using draconis::utils::types::u64;
      using draconis::utils::types::usize;

      const u64 totalSeconds = stfd.value.count();
      const u64 days         = totalSeconds / 86400;
      const u64 hours        = (totalSeconds % 86400) / 3600;
      const u64 minutes      = (totalSeconds % 3600) / 60;
      const u64 seconds      = totalSeconds % 60;

      Array<String, 4> parts = {};

      usize partsCount = 0;

      if (days > 0)
        parts.at(partsCount++) = std::format("{}d", days);
      if (hours > 0)
        parts.at(partsCount++) = std::format("{}h", hours);
      if (minutes > 0)
        parts.at(partsCount++) = std::format("{}m", minutes);
      if (seconds > 0 || partsCount == 0)
        parts.at(partsCount++) = std::format("{}s", seconds);

      String formattedString;
      for (usize i = 0; i < partsCount; ++i) {
        formattedString += parts.at(i);
        if (i < partsCount - 1)
          formattedString += " ";
      }

      return std::formatter<String>::format(formattedString, ctx);
    }
  };
} // namespace std
</file>

<file path="src/Lib/Services/Weather/OpenWeatherMapService.cpp">
#if DRAC_ENABLE_WEATHER

  #include "OpenWeatherMapService.hpp"

  #include <utility>

  #include "Drac++/Utils/CacheManager.hpp"
  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Types.hpp"

  #include "DataTransferObjects.hpp"
  #include "Wrappers/Curl.hpp"

using namespace draconis::utils::types;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;
using draconis::services::weather::OpenWeatherMapService;
using draconis::services::weather::Report;
using draconis::services::weather::UnitSystem;

namespace {
  fn MakeApiRequest(const String& url) -> Result<Report> {
    using draconis::utils::types::None, draconis::utils::types::Option;
    using glz::error_ctx, glz::read, glz::error_code;

    String responseBuffer;

    Curl::Easy curl({
      .url                = url,
      .writeBuffer        = &responseBuffer,
      .timeoutSecs        = 10L,
      .connectTimeoutSecs = 5L,
    });

    if (!curl) {
      if (const Option<DracError>& initError = curl.getInitializationError())
        ERR_FROM(*initError);

      ERR(ApiUnavailable, "Failed to initialize cURL (Easy handle is invalid after construction)");
    }

    if (Result res = curl.perform(); !res)
      ERR_FROM(res.error());

    draconis::services::weather::dto::owm::OWMResponse owmResponse;

    if (const error_ctx errc = read<glz::opts { .error_on_unknown_keys = false }>(owmResponse, responseBuffer); errc.ec != error_code::none)
      ERR_FMT(ParseError, "Failed to parse JSON response: {}", format_error(errc, responseBuffer.data()));

    if (owmResponse.cod && *owmResponse.cod != 200) {
      using matchit::match, matchit::is, matchit::or_, matchit::_;

      String apiErrorMessage = "OpenWeatherMap API error";

      if (owmResponse.message && !owmResponse.message->empty())
        apiErrorMessage += std::format(" ({}): {}", *owmResponse.cod, *owmResponse.message);
      else
        apiErrorMessage += std::format(" (Code: {})", *owmResponse.cod);

      ERR(
        match(*owmResponse.cod)(is | 401 = PermissionDenied, is | 404 = NotFound, is | or_(429, _) = ApiUnavailable),
        std::move(apiErrorMessage)
      );
    }

    Report report = {
      .temperature = owmResponse.main.temp,
      .name        = owmResponse.name.empty() ? None : Some(owmResponse.name),
      .description = !owmResponse.weather.empty() ? owmResponse.weather[0].description : "",
    };

    return report;
  }
} // namespace

OpenWeatherMapService::OpenWeatherMapService(Location location, String apiKey, const UnitSystem units)
  : m_location(std::move(location)), m_apiKey(std::move(apiKey)), m_units(units) {}

fn OpenWeatherMapService::getWeatherInfo() const -> Result<Report> {
  return GetCacheManager()->getOrSet<Report>(
    "owm_weather",
    [&]() -> Result<Report> {
      if (std::holds_alternative<String>(m_location)) {
        const auto& city = std::get<String>(m_location);

        Result<String> escapedUrl = Curl::Easy::escape(city);
        if (!escapedUrl)
          ERR_FROM(escapedUrl.error());

        const String apiUrl = std::format("https://api.openweathermap.org/data/2.5/weather?q={}&appid={}&units={}", *escapedUrl, m_apiKey, m_units);

        return MakeApiRequest(apiUrl);
      }

      if (std::holds_alternative<Coords>(m_location)) {
        const auto& [lat, lon] = std::get<Coords>(m_location);

        const String apiUrl = std::format("https://api.openweathermap.org/data/2.5/weather?lat={:.3f}&lon={:.3f}&appid={}&units={}", lat, lon, m_apiKey, m_units);

        return MakeApiRequest(apiUrl);
      }

      ERR(ParseError, "Invalid location type in configuration.");
    }
  );
}

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Tests/PackageCountingIntegrationTest.cpp">
#include <../../../include/Drac++/Utils/Error.hpp>
#include <../../../include/Drac++/Utils/Types.hpp>
#include <filesystem> // std::filesystem::{create_directories, path, remove_all, temp_directory_path}
#include <fstream>    // std::ofstream

#include <Drac++/Services/Packages.hpp>

#include "gtest/gtest.h"

using namespace testing;
using namespace draconis::services::packages;
using namespace draconis::utils;

using enum error::DracErrorCode;
using types::i32;
using types::Result;
using types::String;
using types::u64;
using types::Unit;

namespace fs = std::filesystem;

#include <Drac++/Utils/CacheManager.hpp>

class PackageCountingIntegrationTest : public Test {
 public:
  fs::path            mTestDir;
  cache::CacheManager mCacheManager;

 protected:
  fn SetUp() -> Unit override {
    mTestDir = fs::temp_directory_path() / "draconis_pkg_test";
    fs::create_directories(mTestDir);
    mCacheManager.setGlobalPolicy({ .location = cache::CacheLocation::TempDirectory });
  }

  fn TearDown() -> Unit override {
    fs::remove_all(mTestDir);
  }

  static fn CreateTestFile(const fs::path& path, const String& content = "") -> Unit {
    std::ofstream file(path);
    file << content;
  }

  static fn CreateTestDir(const fs::path& path) -> Unit {
    fs::create_directories(path);
  }
};

TEST_F(PackageCountingIntegrationTest, GetCountFromDirectory_EmptyDirectory) {
  const auto result = GetCountFromDirectory(mCacheManager, "test", mTestDir);
  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 0);
}

TEST_F(PackageCountingIntegrationTest, GetCountFromDirectory_WithFiles) {
  CreateTestFile(mTestDir / "file1.txt");
  CreateTestFile(mTestDir / "file2.txt");
  CreateTestFile(mTestDir / "file3.txt");

  const auto result = GetCountFromDirectory(mCacheManager, "test_files", mTestDir);
  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 3);
}

TEST_F(PackageCountingIntegrationTest, GetCountFromDirectory_WithFilter) {
  CreateTestFile(mTestDir / "file1.txt");
  CreateTestFile(mTestDir / "file2.txt");
  CreateTestFile(mTestDir / "file3.txt");
  CreateTestFile(mTestDir / "file1.dat");
  CreateTestFile(mTestDir / "file2.dat");

  const auto result = GetCountFromDirectory(mCacheManager, "test_filter", mTestDir, String(".txt"));
  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 3);
}

TEST_F(PackageCountingIntegrationTest, GetCountFromDirectory_WithSubtractOne) {
  CreateTestFile(mTestDir / "file1.txt");
  CreateTestFile(mTestDir / "file2.txt");
  CreateTestFile(mTestDir / "file3.txt");

  const auto result = GetCountFromDirectory(mCacheManager, "test_subtract", mTestDir, true);
  EXPECT_TRUE(result);
  EXPECT_EQ(*result, 2);
}

TEST_F(PackageCountingIntegrationTest, GetCountFromDirectory_NonexistentDirectory) {
  const auto result = GetCountFromDirectory(mCacheManager, "test_nonexistent", mTestDir / "nonexistent");
  EXPECT_FALSE(result);
  EXPECT_EQ(result.error().code, NotFound);
}

TEST_F(PackageCountingIntegrationTest, GetTotalCount_NoManagers) {
  const auto result = GetTotalCount(mCacheManager, static_cast<Manager>(0));
  EXPECT_FALSE(result);
  EXPECT_EQ(result.error().code, UnavailableFeature);
}

TEST_F(PackageCountingIntegrationTest, GetTotalCount_CargoOnly) {
  if (Result<u64> result = GetTotalCount(mCacheManager, Manager::CARGO); !result)
    EXPECT_TRUE(result.error().code == NotFound || result.error().code == ApiUnavailable);
}

#if defined(__linux__) || defined(__APPLE__)
TEST_F(PackageCountingIntegrationTest, GetTotalCount_NixOnly) {
  // Act
  Result<u64> result = GetTotalCount(mCacheManager, Manager::NIX);

  // Assert
  // Note: This test might pass or fail depending on whether Nix is installed
  if (!result)
    EXPECT_TRUE(result.error().code == NotFound || result.error().code == ApiUnavailable);
}
#endif

#if defined(__linux__)
TEST_F(PackageCountingIntegrationTest, GetTotalCount_LinuxManagers) {
  // Act
  Result<u64> result = GetTotalCount(mCacheManager, Manager::CARGO | Manager::NIX | Manager::PACMAN | Manager::DPKG);

  // Assert
  // Note: This test might pass or fail depending on which package managers are installed
  if (!result)
    EXPECT_TRUE(result.error().code == NotFound || result.error().code == ApiUnavailable);
}
#endif

#if defined(__APPLE__)
TEST_F(PackageCountingIntegrationTest, GetTotalCount_MacManagers) {
  // Act
  Result<u64> result = GetTotalCount(mCacheManager, Manager::CARGO | Manager::NIX | Manager::HOMEBREW);

  // Assert
  // Note: This test might pass or fail depending on which package managers are installed
  if (!result)
    EXPECT_TRUE(result.error().code == NotFound || result.error().code == ApiUnavailable);
}
#endif

#if defined(_WIN32)
TEST_F(PackageCountingIntegrationTest, GetTotalCount_WindowsManagers) {
  if (Result<u64> result = GetTotalCount(mCacheManager, Manager::CARGO | Manager::WINGET | Manager::CHOCOLATEY); !result)
    EXPECT_TRUE(result.error().code == NotFound || result.error().code == ApiUnavailable);
}
#endif

fn main(i32 argc, char** argv) -> i32 {
  InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
</file>

<file path="src/Lib/Wrappers/Curl.hpp">
#pragma once

#include <curl/curl.h>
#include <utility> // std::{exchange, move}

#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Types.hpp>

namespace Curl {
  namespace {
    using draconis::utils::error::DracError;
    using enum draconis::utils::error::DracErrorCode;

    using draconis::utils::types::Err;
    using draconis::utils::types::i32;
    using draconis::utils::types::i64;
    using draconis::utils::types::None;
    using draconis::utils::types::Option;
    using draconis::utils::types::RawPointer;
    using draconis::utils::types::Result;
    using draconis::utils::types::String;
    using draconis::utils::types::Unit;
    using draconis::utils::types::usize;
  } // namespace

  /**
   * @brief Options for initializing a Curl::Easy handle.
   */
  struct EasyOptions {
    Option<String> url                = None;    ///< URL to set for the transfer
    String*        writeBuffer        = nullptr; ///< Pointer to a string buffer to store the response
    Option<i64>    timeoutSecs        = None;    ///< Timeout for the entire request in seconds
    Option<i64>    connectTimeoutSecs = None;    ///< Timeout for the connection phase in seconds
    Option<String> userAgent          = None;    ///< User-agent string
  };

  /**
   * @brief RAII wrapper for CURL easy handle.
   */
  class Easy {
    CURL*             m_curl      = nullptr;
    Option<DracError> m_initError = None; ///< Stores any error that occurred during initialization via options constructor

    static fn writeCallback(RawPointer contents, const usize size, const usize nmemb, String* str) -> usize {
      const usize totalSize = size * nmemb;
      str->append(static_cast<char*>(contents), totalSize);
      return totalSize;
    }

   public:
    /**
     * @brief Default constructor. Initializes a CURL easy handle.
     */
    Easy()
      : m_curl(curl_easy_init()) {
      if (!m_curl)
        m_initError = DracError(ApiUnavailable, "curl_easy_init() failed");
    }

    /**
     * @brief Constructor with options. Initializes a CURL easy handle and sets options.
     * @param options The options to configure the CURL handle.
     */
    explicit Easy(const EasyOptions& options)
      : m_curl(curl_easy_init()) {
      if (!m_curl) {
        m_initError = DracError(ApiUnavailable, "curl_easy_init() failed");
        return;
      }

      if (options.url)
        if (Result res = setUrl(*options.url); !res) {
          m_initError = res.error();
          return;
        }

      if (options.writeBuffer)
        if (Result res = setWriteFunction(options.writeBuffer); !res) {
          m_initError = res.error();
          return;
        }

      if (options.timeoutSecs)
        if (Result res = setTimeout(*options.timeoutSecs); !res) {
          m_initError = res.error();
          return;
        }

      if (options.connectTimeoutSecs)
        if (Result res = setConnectTimeout(*options.connectTimeoutSecs); !res) {
          m_initError = res.error();
          return;
        }

      if (options.userAgent)
        if (Result res = setUserAgent(*options.userAgent); !res) {
          m_initError = res.error();
          return;
        }
    }

    /**
     * @brief Destructor. Cleans up the CURL easy handle.
     */
    ~Easy() {
      if (m_curl)
        curl_easy_cleanup(m_curl);
    }

    // Non-copyable
    Easy(const Easy&)                = delete;
    fn operator=(const Easy&)->Easy& = delete;

    /**
     * @brief Move constructor.
     * @param other The other Easy object to move from.
     */
    Easy(Easy&& other) noexcept
      : m_curl(std::exchange(other.m_curl, nullptr)), m_initError(std::move(other.m_initError)) {}

    /**
     * @brief Move assignment operator.
     * @param other The other Easy object to move from.
     * @return A reference to this object.
     */
    fn operator=(Easy&& other) noexcept -> Easy& {
      if (this != &other) {
        if (m_curl)
          curl_easy_cleanup(m_curl);
        m_curl      = std::exchange(other.m_curl, nullptr);
        m_initError = std::move(other.m_initError);
      }

      return *this;
    }

    /**
     * @brief Checks if the CURL handle is valid and initialized without errors.
     * @return True if the handle is valid and no initialization error occurred, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const {
      return m_curl != nullptr && !m_initError;
    }

    /**
     * @brief Gets any error that occurred during initialization via the options constructor.
     * @return An Option containing a DracError if initialization failed, otherwise None.
     */
    [[nodiscard]] fn getInitializationError() const -> const Option<DracError>& {
      return m_initError;
    }

    /**
     * @brief Gets the underlying CURL handle.
     * @return The CURL handle.
     */
    [[nodiscard]] fn get() const -> CURL* {
      return m_curl;
    }

    /**
     * @brief Sets a CURL option.
     * @tparam T The type of the option value.
     * @param option The CURL option to set.
     * @param value The value to set for the option.
     * @return A Result indicating success or failure.
     */
    template <typename T>
    fn setOpt(const CURLoption option, T value) -> Result<> {
      if (!m_curl)
        ERR(InternalError, "CURL handle is not initialized or init failed");

      if (m_initError)
        ERR(InternalError, "CURL handle initialization previously failed");

      if (const CURLcode res = curl_easy_setopt(m_curl, option, value); res != CURLE_OK)
        ERR_FMT(PlatformSpecific, "curl_easy_setopt failed: {}", curl_easy_strerror(res));

      return {};
    }

    /**
     * @brief Performs a blocking file transfer.
     * @return A Result indicating success or failure.
     */
    fn perform() -> Result<> {
      if (!m_curl)
        ERR(InternalError, "CURL handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "Cannot perform request, CURL handle initialization failed: {}", m_initError->message);

      if (const CURLcode res = curl_easy_perform(m_curl); res != CURLE_OK)
        ERR_FMT(ApiUnavailable, "curl_easy_perform failed: {}", curl_easy_strerror(res));

      return {};
    }

    /**
     * @brief Gets information from a CURL transfer.
     * @tparam T The type of the information to get.
     * @param info The CURLINFO to get.
     * @param value A pointer to store the retrieved information.
     * @return A Result indicating success or failure.
     */
    template <typename T>
    fn getInfo(const CURLINFO info, T* value) -> Result<> {
      if (!m_curl)
        ERR(InternalError, "CURL handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "CURL handle initialization previously failed: {}", m_initError->message);

      if (const CURLcode res = curl_easy_getinfo(m_curl, info, value); res != CURLE_OK)
        ERR_FMT(PlatformSpecific, "curl_easy_getinfo failed: {}", curl_easy_strerror(res));

      return {};
    }

    /**
     * @brief Escapes a URL string.
     * @param url The URL string to escape.
     * @return A Result containing the escaped string or an error.
     */
    static fn escape(const String& url) -> Result<String> {
      char* escapedUrl = curl_easy_escape(nullptr, url.c_str(), static_cast<int>(url.length()));

      if (!escapedUrl)
        ERR(OutOfMemory, "curl_easy_escape failed");

      String result(escapedUrl);

      curl_free(escapedUrl);

      return result;
    }

    /**
     * @brief Sets the URL for the transfer.
     * @param url The URL to set.
     * @return A Result indicating success or failure.
     */
    fn setUrl(const String& url) -> Result<> {
      return setOpt(CURLOPT_URL, url.c_str());
    }

    /**
     * @brief Sets the write function and data for the transfer.
     * @param buffer The string buffer to write the response to.
     * @return A Result indicating success or failure.
     */
    fn setWriteFunction(String* buffer) -> Result<> {
      if (!buffer)
        ERR(InvalidArgument, "Write buffer cannot be null");

      if (Result res = setOpt(CURLOPT_WRITEFUNCTION, writeCallback); !res)
        return res;

      return setOpt(CURLOPT_WRITEDATA, buffer);
    }

    /**
     * @brief Sets the timeout for the transfer.
     * @param timeout The timeout in seconds.
     * @return A Result indicating success or failure.
     */
    fn setTimeout(const i64 timeout) -> Result<> {
      return setOpt(CURLOPT_TIMEOUT, timeout);
    }

    /**
     * @brief Sets the connect timeout for the transfer.
     * @param timeout The connect timeout in seconds.
     * @return A Result indicating success or failure.
     */
    fn setConnectTimeout(const i64 timeout) -> Result<> {
      return setOpt(CURLOPT_CONNECTTIMEOUT, timeout);
    }

    /**
     * @brief Sets the user agent for the transfer.
     * @param userAgent The user agent string.
     * @return A Result indicating success or failure.
     */
    fn setUserAgent(const String& userAgent) -> Result<> {
      return setOpt(CURLOPT_USERAGENT, userAgent.c_str());
    }
  };

  /**
   * @brief RAII wrapper for CURL multi handle.
   */
  class Multi {
    CURLM*            m_multi     = nullptr;
    Option<DracError> m_initError = None;

   public:
    /**
     * @brief Constructor. Initializes a CURL multi handle.
     */
    Multi()
      : m_multi(curl_multi_init()) {
      if (!m_multi)
        m_initError = DracError(ApiUnavailable, "curl_multi_init() failed");
    }

    /**
     * @brief Destructor. Cleans up the CURL multi handle.
     */
    ~Multi() {
      if (m_multi)
        curl_multi_cleanup(m_multi);
    }

    // Non-copyable
    Multi(const Multi&)                = delete;
    fn operator=(const Multi&)->Multi& = delete;

    /**
     * @brief Move constructor.
     * @param other The other Multi object to move from.
     */
    Multi(Multi&& other) noexcept
      : m_multi(std::exchange(other.m_multi, nullptr)), m_initError(std::move(other.m_initError)) {}

    /**
     * @brief Move assignment operator.
     * @param other The other Multi object to move from.
     * @return A reference to this object.
     */
    fn operator=(Multi&& other) noexcept -> Multi& {
      if (this != &other) {
        if (m_multi)
          curl_multi_cleanup(m_multi);

        m_multi     = std::exchange(other.m_multi, nullptr);
        m_initError = std::move(other.m_initError);
      }

      return *this;
    }

    /**
     * @brief Checks if the CURL multi handle is valid and initialized without error.
     * @return True if the handle is valid and no init error, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const {
      return m_multi != nullptr && !m_initError;
    }

    /**
     * @brief Gets any error that occurred during initialization.
     * @return An Option containing a DracError if initialization failed, otherwise None.
     */
    [[nodiscard]] fn getInitializationError() const -> const Option<DracError>& {
      return m_initError;
    }

    /**
     * @brief Gets the underlying CURLM handle.
     * @return The CURLM handle.
     */
    [[nodiscard]] fn get() const -> CURLM* {
      return m_multi;
    }

    /**
     * @brief Adds an easy handle to the multi handle.
     * @param easyHandle The Easy handle to add.
     * @return A Result indicating success or failure.
     */
    fn addHandle(const Easy& easyHandle) -> Result<> {
      if (m_initError)
        ERR_FMT(InternalError, "CURL multi handle initialization previously failed: {}", m_initError->message);

      if (!easyHandle.get())
        ERR(InvalidArgument, "Provided CURL easy handle is not valid");

      if (easyHandle.getInitializationError())
        ERR_FMT(InvalidArgument, "Provided CURL easy handle failed initialization: {}", easyHandle.getInitializationError()->message);

      if (const CURLMcode res = curl_multi_add_handle(m_multi, easyHandle.get()); res != CURLM_OK)
        ERR_FMT(PlatformSpecific, "curl_multi_add_handle failed: {}", curl_multi_strerror(res));

      return {};
    }

    /**
     * @brief Removes an easy handle from the multi handle.
     * @param easyHandle The Easy handle to remove.
     * @return A Result indicating success or failure.
     */
    fn removeHandle(const Easy& easyHandle) -> Result<> {
      if (!m_multi)
        ERR(InternalError, "CURL multi handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "CURL multi handle initialization previously failed: {}", m_initError->message);

      if (!easyHandle.get()) // It's okay to try to remove a null handle, curl_multi_remove_handle handles it.
        ERR(InvalidArgument, "Provided CURL easy handle is not valid (for removal check)");

      if (const CURLMcode res = curl_multi_remove_handle(m_multi, easyHandle.get()); res != CURLM_OK) // CURLM_BAD_EASY_HANDLE is a possible error if handle was not in multi stack
        ERR_FMT(PlatformSpecific, "curl_multi_remove_handle failed: {}", curl_multi_strerror(res));

      return {};
    }

    /**
     * @brief Performs transfers on the multi handle.
     * @param stillRunning A pointer to an integer that will be set to the number of still running transfers.
     * @return A Result indicating success or failure.
     */
    fn perform(i32* stillRunning) -> Result<> {
      if (!m_multi)
        ERR(InternalError, "CURL multi handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "CURL multi handle initialization previously failed: {}", m_initError->message);

      if (const CURLMcode res = curl_multi_perform(m_multi, stillRunning); res != CURLM_OK && res != CURLM_CALL_MULTI_PERFORM)
        ERR_FMT(PlatformSpecific, "curl_multi_perform failed: {}", curl_multi_strerror(res));

      return {};
    }

    /**
     * @brief Reads information about completed transfers.
     * @param msgsInQueue A pointer to an integer that will be set to the number of messages in the queue.
     * @return A Result containing a CURLMsg pointer or an error. The caller is responsible for checking the msg field of CURLMsg.
     */
    fn infoRead(i32* msgsInQueue) -> Result<CURLMsg*> {
      if (!m_multi)
        ERR(InternalError, "CURL multi handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "CURL multi handle initialization previously failed: {}", m_initError->message);

      CURLMsg* msg = curl_multi_info_read(m_multi, msgsInQueue);

      return msg;
    }

    /**
     * @brief Waits for activity on any of the multi handle's file descriptors using poll.
     * @param timeoutMs The maximum time to wait in milliseconds.
     * @param numfds A pointer to an integer that will be set to the number of file descriptors with activity. Can be nullptr.
     * @return A Result indicating success or failure.
     */
    fn poll(const i32 timeoutMs, i32* numfds) -> Result<> {
      if (!m_multi)
        ERR(InternalError, "CURL multi handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "CURL multi handle initialization previously failed: {}", m_initError->message);

      if (const CURLMcode res = curl_multi_poll(m_multi, nullptr, 0, timeoutMs, numfds); res != CURLM_OK)
        ERR_FMT(PlatformSpecific, "curl_multi_poll failed: {}", curl_multi_strerror(res));

      return {};
    }

    /**
     * @brief Waits for activity on any of the multi handle's file descriptors using select semantics.
     * @param timeoutMs The maximum time to wait in milliseconds.
     * @param numfds A pointer to an integer that will be set to the number of file descriptors with activity.
     * @return A Result indicating success or failure.
     * @note This function is an alternative to poll and might be needed if curl_multi_poll is not available or desired.
     *       It requires more setup with curl_multi_fdset. For simplicity, poll is preferred if available.
     *       This is a simplified version; a full fdset handling is more complex.
     */
    fn wait(const i32 timeoutMs, i32* numfds) -> Result<> {
      if (!m_multi)
        ERR(InternalError, "CURL multi handle is not initialized or init failed");

      if (m_initError)
        ERR_FMT(InternalError, "CURL multi handle initialization previously failed: {}", m_initError->message);

      if (const CURLMcode res = curl_multi_wait(m_multi, nullptr, 0, timeoutMs, numfds); res != CURLM_OK)
        ERR_FMT(PlatformSpecific, "curl_multi_wait failed: {}", curl_multi_strerror(res));

      return {};
    }
  };

  /**
   * @brief Initializes CURL globally. Should be called once at the start of the program.
   * @param flags CURL global init flags.
   * @return A Result indicating success or failure.
   */
  inline fn GlobalInit(const i32 flags = CURL_GLOBAL_ALL) -> Result<> {
    if (const CURLcode res = curl_global_init(flags); res != CURLE_OK)
      ERR_FMT(PlatformSpecific, "curl_global_init failed: {}", curl_easy_strerror(res));

    return {};
  }

  /**
   * @brief Cleans up CURL globally. Should be called once at the end of the program.
   */
  inline fn GlobalCleanup() -> Unit {
    curl_global_cleanup();
  }
} // namespace Curl
</file>

<file path="include/Drac++/Utils/ArgumentParser.hpp">
/**
 * @file ArgumentParser.hpp
 * @brief Simple command-line argument parser for Drac++.
 *
 * This header provides a lightweight argument parser that follows the Drac++
 * coding conventions and type system. It supports basic argument parsing
 * including flags, optional arguments, and help text generation.
 */

#pragma once

#include <algorithm>
#include <concepts>                  // std::convertible_to
#include <cstdlib>                   // std::exit
#include <format>                    // std::format
#include <magic_enum/magic_enum.hpp> // magic_enum::enum_name, magic_enum::enum_cast
#include <sstream>                   // std::ostringstream
#include <unordered_set>             // std::unordered_set for fast choice look-ups
#include <utility>                   // std::forward

#include "Error.hpp"
#include "Logging.hpp"
#include "Types.hpp"

namespace draconis::utils::argparse {
  namespace {
    using error::DracError;
    using error::DracErrorCode;
    using logging::Print;
    using logging::Println;

    using types::CStr;
    using types::Err;
    using types::f64;
    using types::i32;
    using types::Map;
    using types::Option;
    using types::Result;
    using types::Span;
    using types::String;
    using types::StringView;
    using types::u8;
    using types::UniquePointer;
    using types::Unit;
    using types::usize;
    using types::Vec;
  } // namespace

  /**
   * @brief Type alias for argument values.
   */
  using ArgValue = std::variant<bool, i32, f64, String>;

  /**
   * @brief Type alias for allowed choices for enum-style arguments.
   */
  using ArgChoices = Vec<String>;

  /**
   * @brief Generic traits class for enum string conversion using magic_enum.
   * @tparam EnumType The enum type
   */
  template <typename EnumType>
  struct EnumTraits {
    static constexpr bool has_string_conversion = magic_enum::is_scoped_enum_v<EnumType>;

    static fn getChoices() -> const ArgChoices& {
      static_assert(has_string_conversion, "Enum type must be a scoped enum");

      static const ArgChoices CACHED_CHOICES = [] {
        ArgChoices vec;
        const auto enumValues = magic_enum::enum_values<EnumType>();
        vec.reserve(enumValues.size());
        for (const auto value : enumValues)
          vec.emplace_back(magic_enum::enum_name(value));
        return vec;
      }();

      return CACHED_CHOICES;
    }

    static fn stringToEnum(const String& str) -> EnumType {
      static_assert(has_string_conversion, "Enum type must be a scoped enum");

      auto result = magic_enum::enum_cast<EnumType>(str);
      if (result.has_value())
        return result.value();

      const auto enumValues = magic_enum::enum_values<EnumType>();
      for (const auto value : enumValues) {
        StringView enumName = magic_enum::enum_name(value);
        if (std::ranges::equal(str, enumName, [](char charA, char charB) { return std::tolower(charA) == std::tolower(charB); }))
          return value;
      }

      return enumValues[0];
    }

    static fn enumToString(EnumType value) -> String {
      static_assert(has_string_conversion, "Enum type must be a scoped enum");
      return String(magic_enum::enum_name(value));
    }
  };

  /**
   * @brief Represents a command-line argument with its metadata and value.
   */
  class Argument {
   public:
    /**
     * @brief Construct a new Argument.
     * @param names Vector of argument names (e.g., {"-v", "--verbose"})
     * @param help_text Help text for this argument
     * @param is_flag Whether this is a flag (boolean) argument
     */
    explicit Argument(Vec<String> names, String help_text = "", bool is_flag = false)
      : m_names(std::move(names)), m_helpText(std::move(help_text)), m_isFlag(is_flag) {
      if (m_isFlag)
        m_defaultValue = false;
    }

    /**
     * @brief Construct a new Argument with variadic names.
     * @tparam NameTs Variadic list of types convertible to String
     * @param help_text Help text for this argument
     * @param is_flag Whether this is a flag (boolean) argument
     * @param names One or more argument names
     */
    template <typename... NameTs>
      requires(sizeof...(NameTs) >= 1 && (std::convertible_to<NameTs, String> && ...))
    explicit Argument(String help_text, bool is_flag, NameTs&&... names)
      : m_names { String(std::forward<NameTs>(names))... }, m_helpText(std::move(help_text)), m_isFlag(is_flag) {
      if (m_isFlag)
        m_defaultValue = false;
    }

    /**
     * @brief Set the help text for this argument.
     * @param help_text The help text
     * @return Reference to this argument for method chaining
     */
    fn help(String help_text) -> Argument& {
      m_helpText = std::move(help_text);
      return *this;
    }

    /**
     * @brief Set the default value for this argument.
     * @tparam T Type of the default value
     * @param value The default value
     * @return Reference to this argument for method chaining
     */
    template <typename T>
    fn defaultValue(T value) -> Argument& {
      m_defaultValue = std::move(value);
      return *this;
    }

    /**
     * @brief Set the default value for this argument as an enum.
     * @tparam EnumType The enum type
     * @param value The default enum value
     * @return Reference to this argument for method chaining
     */
    template <typename EnumType>
      requires std::is_enum_v<EnumType> && EnumTraits<EnumType>::has_string_conversion
                                         fn defaultValue(EnumType value) -> Argument& {
      String strValue = EnumTraits<EnumType>::enumToString(value);

      m_defaultValue = strValue;

      /* Setting choices via helper ensures lowercase set is populated. */
      return this->choices(EnumTraits<EnumType>::getChoices());
    }

    /**
     * @brief Configure this argument as a flag.
     * @return Reference to this argument for method chaining
     */
    fn flag() -> Argument& {
      m_isFlag       = true;
      m_defaultValue = false;
      return *this;
    }

    /**
     * @brief Set allowed choices for enum-style arguments.
     * @param choices Vector of allowed string values
     * @return Reference to this argument for method chaining
     */
    fn choices(const ArgChoices& choices) -> Argument& {
      m_choices = choices;

      std::unordered_set<String> lowered;
      lowered.reserve(choices.size());

      for (const String& choice : choices) {
        String lower = choice;
        std::ranges::transform(
          lower,
          lower.begin(),
          [](u8 chr) { return static_cast<CStr>(std::tolower(chr)); }
        );
        lowered.emplace(std::move(lower));
      }

      m_lowerChoices = std::move(lowered);

      return *this;
    }

    /**
     * @brief Get the value of this argument.
     * @tparam T Type to get the value as
     * @return The argument value, or default value if not provided
     */
    template <typename T>
    fn get() const -> T {
      if (m_isUsed && m_value.has_value())
        return std::get<T>(m_value.value());

      if (m_defaultValue.has_value())
        return std::get<T>(m_defaultValue.value());

      return T {};
    }

    /**
     * @brief Get the value of this argument as an enum type.
     * @tparam EnumType The enum type to convert to
     * @return The argument value converted to the enum type
     */
    template <typename EnumType>
      requires std::is_enum_v<EnumType> && EnumTraits<EnumType>::has_string_conversion
                                         fn getEnum() const -> EnumType {
      const auto strValue = get<String>();

      return EnumTraits<EnumType>::stringToEnum(strValue);
    }

    /**
     * @brief Check if this argument was used in the command line.
     * @return true if the argument was used, false otherwise
     */
    [[nodiscard]] fn isUsed() const -> bool {
      return m_isUsed;
    }

    /**
     * @brief Get the primary name of this argument.
     * @return The first name in the names list
     */
    [[nodiscard]] fn getPrimaryName() const -> const String& {
      return m_names.front();
    }

    /**
     * @brief Get all names for this argument.
     * @return Vector of all argument names
     */
    [[nodiscard]] fn getNames() const -> const Vec<String>& {
      return m_names;
    }

    /**
     * @brief Get the help text for this argument.
     * @return The help text
     */
    [[nodiscard]] fn getHelpText() const -> const String& {
      return m_helpText;
    }

    /**
     * @brief Check if this argument is a flag.
     * @return true if this is a flag argument, false otherwise
     */
    [[nodiscard]] fn isFlag() const -> bool {
      return m_isFlag;
    }

    /**
     * @brief Check if this argument has choices (enum-style).
     * @return true if this argument has choices, false otherwise
     */
    [[nodiscard]] fn hasChoices() const -> bool {
      return m_choices.has_value();
    }

    /**
     * @brief Get the allowed choices for this argument.
     * @return Vector of allowed choices, or empty vector if none set
     */
    [[nodiscard]] fn getChoices() const -> ArgChoices {
      return m_choices.value_or(ArgChoices {});
    }

    /**
     * @brief Check if this argument has a default value.
     * @return true if a default value is set, false otherwise
     */
    [[nodiscard]] fn hasDefault() const -> bool {
      return m_defaultValue.has_value();
    }

    /**
     * @brief Get the default value as a lowercase string (for help text).
     *        Returns an empty string if no default value is set.
     */
    [[nodiscard]] fn getDefaultAsString() const -> String {
      if (!m_defaultValue.has_value())
        return {};

      const ArgValue& value = m_defaultValue.value();

      String result;
      std::visit(
        [&](const auto& value) {
          using V = std::decay_t<decltype(value)>;
          if constexpr (std::is_same_v<V, bool>)
            result = value ? "true" : "false";
          else if constexpr (std::is_same_v<V, String>)
            result = value;
          else
            result = std::format("{}", value);
        },
        value
      );

      std::ranges::transform(result, result.begin(), [](char chr) { return std::tolower(chr); });

      return result;
    }

    /**
     * @brief Set the value for this argument.
     * @param value The value to set
     * @return Result indicating success or failure
     */
    fn setValue(ArgValue value) -> Result<> {
      if (hasChoices() && std::holds_alternative<String>(value)) {
        const String& strValue = std::get<String>(value);

        /* Lower-case once for lookup */
        String lowerValue = strValue;
        std::ranges::transform(
          lowerValue,
          lowerValue.begin(),
          [](u8 chr) { return static_cast<CStr>(std::tolower(chr)); }
        );

        bool isValid = m_lowerChoices && m_lowerChoices->contains(lowerValue);

        if (!isValid) {
          const ArgChoices& choices = m_choices.value();

          std::ostringstream choicesStream;
          for (usize i = 0; i < choices.size(); ++i) {
            if (i > 0)
              choicesStream << ", ";
            String lower = choices[i];
            std::ranges::transform(
              lower,
              lower.begin(),
              [](u8 chr) { return static_cast<CStr>(std::tolower(chr)); }
            );
            choicesStream << lower;
          }

          ERR_FMT(
            DracErrorCode::InvalidArgument,
            "Invalid value '{}' for argument '{}'. Allowed values: {}",
            strValue,
            getPrimaryName(),
            choicesStream.str()
          );
        }
      }

      m_value  = std::move(value);
      m_isUsed = true;
      return {};
    }

    /**
     * @brief Mark this argument as used.
     */
    fn markUsed() -> Unit {
      m_isUsed = true;

      if (m_isFlag)
        m_value = true;
    }

   private:
    Vec<String>                        m_names;        ///< Argument names (e.g., {"-v", "--verbose"})
    String                             m_helpText;     ///< Help text for this argument
    Option<ArgValue>                   m_value;        ///< The actual value provided
    Option<ArgValue>                   m_defaultValue; ///< Default value if none provided
    Option<ArgChoices>                 m_choices;      ///< Allowed choices for enum-style arguments
    Option<std::unordered_set<String>> m_lowerChoices; ///< Lower-cased set for fast validation
    bool                               m_isFlag {};    ///< Whether this is a flag argument
    bool                               m_isUsed {};    ///< Whether this argument was used
  };

  /**
   * @brief Main argument parser class.
   */
  class ArgumentParser {
   public:
    /**
     * @brief Construct a new ArgumentParser.
     * @param programName Name of the program
     * @param version Version string of the program
     */
    explicit ArgumentParser(String programName, String version)
      : m_programName(std::move(programName)), m_version(std::move(version)) {
      addArguments("-h", "--help")
        .help("Show this help message and exit")
        .flag()
        .defaultValue(false);

      addArguments("-v", "--version")
        .help("Show version information and exit")
        .flag()
        .defaultValue(false);
    }

    /**
     * @brief Construct a new ArgumentParser.
     * @param version Version string of the program
     *
     * @details Program name is set to argv[0] at runtime.
     */
    explicit ArgumentParser(String version)
      : m_version(std::move(version)) {
      addArguments("-h", "--help")
        .help("Show this help message and exit")
        .flag()
        .defaultValue(false);

      addArguments("-v", "--version")
        .help("Show version information and exit")
        .flag()
        .defaultValue(false);
    }

    /**
     * @brief Add a new argument (or multiple aliases) to the parser.
     *
     * This variadic overload allows callers to pass one or more names directly, e.g.
     *   parser.addArgument("-f", "--file");
     * without the need to manually construct a `Vec<String>` or invoke `addArguments`.
     *
     * @tparam NameTs Variadic list of types convertible to `String`
     * @param names   One or more argument names / aliases
     * @return Reference to the newly created argument
     */
    template <typename... NameTs>
      requires(sizeof...(NameTs) >= 1 && (std::convertible_to<NameTs, String> && ...))
    fn addArguments(NameTs&&... names) -> Argument& {
      m_arguments.emplace_back(std::make_unique<Argument>(String {}, false, std::forward<NameTs>(names)...));
      Argument& arg = *m_arguments.back();

      for (const String& name : arg.getNames())
        m_argumentMap[name] = &arg;

      return arg;
    }

    /**
     * @brief Parse command-line arguments.
     * @param args Span of argument strings
     * @return Result indicating success or failure
     */
    fn parseArgs(Span<const char* const> args) -> Result<> {
      if (args.empty())
        return {};

      if (m_programName.empty())
        m_programName = args[0];

      for (usize i = 1; i < args.size(); ++i) {
        StringView arg = args[i];

        if (arg == "-h" || arg == "--help") {
          printHelp();
          std::exit(0);
        }

        if (arg == "-v" || arg == "--version") {
          Println(m_version);
          std::exit(0);
        }

        auto iter = m_argumentMap.find(arg);
        if (iter == m_argumentMap.end())
          ERR_FMT(DracErrorCode::InvalidArgument, "Unknown argument: {}", arg);

        Argument* argument = iter->second;

        if (argument->isFlag()) {
          argument->markUsed();
        } else {
          if (i + 1 >= args.size())
            ERR_FMT(DracErrorCode::InvalidArgument, "Argument {} requires a value", arg);

          String value = args[++i];
          if (Result result = argument->setValue(value); !result)
            return result;
        }
      }

      return {};
    }

    /**
     * @brief Parse command-line arguments from a vector.
     * @param args Vector of argument strings
     * @return Result indicating success or failure
     */
    fn parseArgs(const Vec<String>& args) -> Result<> {
      if (args.empty())
        return {};

      if (m_programName.empty())
        m_programName = args[0];

      for (usize i = 1; i < args.size(); ++i) {
        const String& arg = args[i];

        if (arg == "-h" || arg == "--help") {
          printHelp();
          std::exit(0);
        }

        if (arg == "-v" || arg == "--version") {
          Println(m_version);
          std::exit(0);
        }

        auto iter = m_argumentMap.find(arg);
        if (iter == m_argumentMap.end())
          ERR_FMT(DracErrorCode::InvalidArgument, "Unknown argument: {}", arg);

        Argument* argument = iter->second;

        if (argument->isFlag()) {
          argument->markUsed();
        } else {
          if (i + 1 >= args.size())
            ERR_FMT(DracErrorCode::InvalidArgument, "Argument {} requires a value", arg);

          String value = args[++i];
          if (Result result = argument->setValue(value); !result)
            return result;
        }
      }

      return {};
    }

    /**
     * @brief Get the value of an argument.
     * @tparam T Type to get the value as
     * @param name Argument name
     * @return The argument value, or default value if not provided
     */
    template <typename T = String>
    fn get(StringView name) const -> T {
      auto iter = m_argumentMap.find(name);

      if (iter != m_argumentMap.end())
        return iter->second->get<T>();

      return T {};
    }

    /**
     * @brief Get the value of an argument as an enum type.
     * @tparam EnumType The enum type to convert to
     * @param name Argument name
     * @return The argument value converted to the enum type
     */
    template <typename EnumType>
    fn getEnum(StringView name) const -> EnumType {
      auto iter = m_argumentMap.find(name);

      if (iter != m_argumentMap.end())
        return iter->second->getEnum<EnumType>();

      static_assert(EnumTraits<EnumType>::has_string_conversion, "Enum type not supported. Add a specialization to EnumTraits.");

      return EnumTraits<EnumType>::stringToEnum("");
    }

    /**
     * @brief Check if an argument was used.
     * @param name Argument name
     * @return true if the argument was used, false otherwise
     */
    [[nodiscard]] fn isUsed(StringView name) const -> bool {
      auto iter = m_argumentMap.find(name);
      if (iter != m_argumentMap.end())
        return iter->second->isUsed();

      return false;
    }

    /**
     * @brief Print help message.
     */
    fn printHelp() const -> Unit {
      std::ostringstream usageStream;
      usageStream << "Usage: " << m_programName;

      for (const auto& arg : m_arguments)
        if (arg->getPrimaryName().starts_with('-')) {
          usageStream << " [" << arg->getPrimaryName();

          if (!arg->isFlag())
            usageStream << " VALUE";

          usageStream << "]";
        }

      Println(usageStream.str());
      Println();

      if (!m_arguments.empty()) {
        Println("Arguments:");
        for (const auto& arg : m_arguments) {
          std::ostringstream namesStream;
          for (usize i = 0; i < arg->getNames().size(); ++i) {
            if (i > 0)
              namesStream << ", ";

            namesStream << arg->getNames()[i];
          }

          std::ostringstream argLineStream;
          argLineStream << "  " << namesStream.str();
          if (!arg->isFlag())
            argLineStream << " VALUE";

          Println(argLineStream.str());

          if (!arg->getHelpText().empty())
            Println("    " + arg->getHelpText());

          if (arg->hasChoices()) {
            std::ostringstream choicesStream;
            choicesStream << "    Available values: ";
            const ArgChoices& choices = arg->getChoices();

            for (usize i = 0; i < choices.size(); ++i) {
              if (i > 0)
                choicesStream << ", ";

              String lower = choices[i];

              std::ranges::transform(lower, lower.begin(), [](char character) { return std::tolower(character); });

              choicesStream << lower;
            }

            Println(choicesStream.str());
          }

          if (arg->hasChoices() && arg->hasDefault())
            Println(std::format("    Default: {}", arg->getDefaultAsString()));

          Println();
        }
      }
    }

   private:
    String                       m_programName; ///< Program name
    String                       m_version;     ///< Program version
    Vec<UniquePointer<Argument>> m_arguments;   ///< List of all arguments
    Map<String, Argument*>       m_argumentMap; ///< Map of argument names to arguments
  };
} // namespace draconis::utils::argparse
</file>

<file path="include/Drac++/Utils/Env.hpp">
#pragma once

#ifdef _WIN32
  #include <stdlib.h> // NOLINT(*-deprecated-headers)
#endif

#include <cstdlib>

#include "Error.hpp"
#include "Types.hpp"

namespace draconis::utils::env {
  namespace {
    using types::i32;
    using types::Result;
    using types::UniquePointer;
    using types::Unit;
    using types::usize;

    using enum error::DracErrorCode;
  } // namespace

#ifdef _WIN32
  /**
   * @brief Safely retrieves an environment variable.
   * @tparam CharT Character type (char or wchar_t)
   * @param name The name of the environment variable to retrieve.
   * @return A Result containing the value of the environment variable.
   */
  template <typename CharT>
  [[nodiscard]] inline fn GetEnv(const CharT* name) -> Result<const CharT*> {
    CharT* rawPtr     = nullptr;
    usize  bufferSize = 0;

    i32 err = 0;

    if constexpr (std::is_same_v<CharT, char>)
      err = _dupenv_s(&rawPtr, &bufferSize, name);
    else
      err = _wdupenv_s(&rawPtr, &bufferSize, name);

    const UniquePointer<CharT, decltype(&free)> ptrManager(rawPtr, free);

    if (err != 0)
      ERR(PermissionDenied, "Failed to retrieve environment variable");

    if (!ptrManager)
      ERR(NotFound, "Environment variable not found");

    return ptrManager.get();
  }

  /**
   * @brief Safely sets an environment variable.
   * @tparam CharT Character type (char or wchar_t)
   * @param name The name of the environment variable to set.
   * @param value The value to set the environment variable to.
   */
  template <typename CharT>
  inline fn SetEnv(const CharT* name, const CharT* value) -> Unit {
    if constexpr (std::is_same_v<CharT, char>)
      _putenv_s(name, value);
    else
      _wputenv_s(name, value);
  }

  /**
   * @brief Safely unsets an environment variable.
   * @tparam CharT Character type (char or wchar_t)
   * @param name The name of the environment variable to unset.
   */
  template <typename CharT>
  inline fn UnsetEnv(const CharT* name) -> Unit {
    if constexpr (std::is_same_v<CharT, char>)
      _putenv_s(name, "");
    else
      _wputenv_s(name, L"");
  }
#else
  /**
   * @brief Safely retrieves an environment variable.
   * @tparam CharT Character type (char only for POSIX)
   * @param name The name of the environment variable to retrieve.
   * @return A Result containing the value of the environment variable.
   */
  template <typename CharT>
  [[nodiscard]] inline fn GetEnv(const CharT* name) -> Result<const CharT*> {
    static_assert(std::is_same_v<CharT, char>, "Only char is supported on POSIX systems");

    const CharT* value = std::getenv(name);

    if (!value)
      ERR(NotFound, "Environment variable not found");

    return value;
  }

  /**
   * @brief Safely sets an environment variable.
   * @tparam CharT Character type (char only for POSIX)
   * @param name The name of the environment variable to set.
   * @param value The value to set the environment variable to.
   */
  template <typename CharT>
  inline fn SetEnv(const CharT* name, const CharT* value) -> Unit {
    static_assert(std::is_same_v<CharT, char>, "Only char is supported on POSIX systems");
    setenv(name, value, 1);
  }

  /**
   * @brief Safely unsets an environment variable.
   * @tparam CharT Character type (char only for POSIX)
   * @param name The name of the environment variable to unset.
   */
  template <typename CharT>
  inline fn UnsetEnv(const CharT* name) -> Unit {
    static_assert(std::is_same_v<CharT, char>, "Only char is supported on POSIX systems");
    unsetenv(name);
  }
#endif
} // namespace draconis::utils::env
</file>

<file path="meson.options">
# ===================================================================== #
#                    Draconis++ Global Configuration                    #
#                                                                       #
#       Additional configuration can be found in `config.toml` or       #
#  `include/Config.hpp`, depending on the `precompiled_config` option.  #
# ===================================================================== #

option('build_examples', type: 'boolean', value: true)
option('build_tests', type: 'boolean', value: true)
option(
  'build_switch_example',
  type: 'boolean',
  value: false,
  description: 'Build the Nintendo Switch example if devkitPro is available',
)

# Note: These are primarily intended for use with Nix.
option('build_for_musl', type: 'boolean', value: false)
option('use_linked_pci_ids', type: 'boolean', value: false)

# Note: Enabling this disables runtime TOML parsing and configuration overriding.
option('precompiled_config', type: 'boolean', value: false)

# Linux-specific
option(
  'pugixml',
  type: 'feature',
  value: 'auto',
  description: 'Use pugixml to parse XBPS package metadata on Void Linux',
)

# Linux/BSD-specific
option(
  'xcb',
  type: 'feature',
  value: 'enabled',
  description: 'Use libxcb to get the X11 window manager/display(s)',
)

# Linux/BSD-specific
option(
  'wayland',
  type: 'feature',
  value: 'enabled',
  description: 'Use wayland-client to get the Wayland compositor/display(s)',
)

# Note: Requires DBus on Linux/BSD and MediaRemote.framework (private API) on macOS.
option(
  'nowplaying',
  type: 'feature',
  value: 'enabled',
  description: 'Enable nowplaying functionality',
)

option(
  'weather',
  type: 'feature',
  value: 'enabled',
  description: 'Enable fetching weather data',
)

option(
  'packagecount',
  type: 'feature',
  value: 'enabled',
  description: 'Enable getting package count',
)

option(
  'caching',
  type: 'feature',
  value: 'enabled',
  description: 'Enable caching functionality',
)
</file>

<file path="src/Lib/Services/Weather/MetNoService.cpp">
#if DRAC_ENABLE_WEATHER

  #include "MetNoService.hpp"

  #include "Drac++/Utils/CacheManager.hpp"
  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Types.hpp"

  #include "DataTransferObjects.hpp"
  #include "WeatherUtils.hpp"
  #include "Wrappers/Curl.hpp"

using namespace draconis::utils::types;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;
using draconis::services::weather::MetNoService;
using draconis::services::weather::Report;
using draconis::services::weather::UnitSystem;

MetNoService::MetNoService(const f64 lat, const f64 lon, const UnitSystem units)
  : m_lat(lat), m_lon(lon), m_units(units) {}

fn MetNoService::getWeatherInfo() const -> Result<Report> {
  using glz::error_ctx, glz::read, glz::error_code;

  return GetCacheManager()->getOrSet<Report>(
    "metno_weather",
    [&]() -> Result<Report> {
      String responseBuffer;

      Curl::Easy curl({
        .url                = std::format("https://api.met.no/weatherapi/locationforecast/2.0/compact?lat={:.4f}&lon={:.4f}", m_lat, m_lon),
        .writeBuffer        = &responseBuffer,
        .timeoutSecs        = 10L,
        .connectTimeoutSecs = 5L,
        .userAgent          = String("draconisplusplus/" DRAC_VERSION " git.pupbrained.xyz/draconisplusplus"),
      });

      if (!curl) {
        if (const Option<DracError>& initError = curl.getInitializationError())
          ERR_FROM(*initError);

        ERR(ApiUnavailable, "Failed to initialize cURL (Easy handle is invalid after construction)");
      }

      if (Result res = curl.perform(); !res)
        ERR_FROM(res.error());

      draconis::services::weather::dto::metno::Response apiResp {};

      if (error_ctx errc = read<glz::opts { .error_on_unknown_keys = false }>(apiResp, responseBuffer); errc.ec != error_code::none)
        ERR_FMT(ParseError, "Failed to parse JSON response: {}", format_error(errc, responseBuffer.data()));

      if (apiResp.properties.timeseries.empty())
        ERR(ParseError, "No timeseries data in met.no response");

      const auto& [time, data] = apiResp.properties.timeseries.front();

      f64 temp = data.instant.details.airTemperature;

      if (m_units == UnitSystem::Imperial)
        temp = temp * 9.0 / 5.0 + 32.0;

      String symbolCode = data.next1Hours ? data.next1Hours->summary.symbolCode : "";

      if (!symbolCode.empty()) {
        const String strippedSymbol = draconis::services::weather::utils::StripTimeOfDayFromSymbol(symbolCode);

        if (auto iter = draconis::services::weather::utils::GetMetnoSymbolDescriptions().find(strippedSymbol); iter != draconis::services::weather::utils::GetMetnoSymbolDescriptions().end())
          symbolCode = iter->second;
      }

      if (Result<usize> timestamp = draconis::services::weather::utils::ParseIso8601ToEpoch(time); !timestamp)
        ERR_FROM(timestamp.error());

      Report out = {
        .temperature = temp,
        .name        = None,
        .description = symbolCode,
      };

      return out;
    }
  );
}

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Services/Weather/WeatherUtils.cpp">
#if DRAC_ENABLE_WEATHER

  #include "WeatherUtils.hpp"

  #include <charconv> // std::from_chars
  #include <ctime>    // std::tm, timegm, _mkgmtime
  #include <format>   // std::format

  #ifdef __HAIKU__
    #define _DEFAULT_SOURCE // exposes timegm
  #endif

  #ifdef __SWITCH__
// timegm is not available on Switch, provide a simple implementation
inline time_t timegm(struct tm* tm) {
  // Simple implementation: assume UTC timezone
  return mktime(tm);
}
  #endif

  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Types.hpp"

using namespace draconis::utils::types;
using enum draconis::utils::error::DracErrorCode;

namespace draconis::services::weather::utils {
  fn StripTimeOfDayFromSymbol(const StringView symbol) -> String {
    static constexpr Array<StringView, 3> SUFFIXES = { "_day", "_night", "_polartwilight" };

    for (const StringView& suffix : SUFFIXES)
      if (symbol.size() > suffix.size() && symbol.ends_with(suffix))
        return String(symbol.substr(0, symbol.size() - suffix.size()));

    return String(symbol);
  }

  fn ParseIso8601ToEpoch(StringView iso8601) -> Result<time_t> {
    const usize stringLen = iso8601.size();

    // Supported lengths:
    // 20: "YYYY-MM-DDTHH:MM:SSZ"
    // 16: "YYYY-MM-DDTHH:MM" (seconds assumed 00, UTC assumed)
    if (stringLen != 20 && stringLen != 16)
      ERR_FMT(ParseError, "Invalid ISO8601 string: '{}' (expected format 'YYYY-MM-DDTHH:MM[:SSZ]')", stringLen);

    std::tm timeStruct = {};
    i32     year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0; // Default second to 0

    auto parseInt = [](const StringView sview, i32& out_val) -> bool {
      auto [ptr, ec] = std::from_chars(sview.data(), sview.data() + sview.size(), out_val);
      return ec == std::errc() && ptr == sview.data() + sview.size();
    };

    // Common parsing for YYYY-MM-DDTHH:MM
    // Structure: YYYY-MM-DDTHH:MM
    // Indices:   0123456789012345
    if (
      !parseInt(iso8601.substr(0, 4), year) || // YYYY
      iso8601[4] != '-' ||
      !parseInt(iso8601.substr(5, 2), month) || // MM
      iso8601[7] != '-' ||
      !parseInt(iso8601.substr(8, 2), day) || // DD
      iso8601[10] != 'T' ||
      !parseInt(iso8601.substr(11, 2), hour) || // HH
      iso8601[13] != ':' ||
      !parseInt(iso8601.substr(14, 2), minute) // MM
    )
      ERR_FMT(ParseError, "Failed to parse common date/time components from ISO8601 string: '{}'", iso8601);

    if (stringLen == 20) // Format: YYYY-MM-DDTHH:MM:SSZ
      if (iso8601[16] != ':' || !parseInt(iso8601.substr(17, 2), second) || iso8601[19] != 'Z')
        ERR_FMT(ParseError, "Failed to parse seconds or UTC zone from 20-character ISO8601 string: '{}'", iso8601);

    timeStruct.tm_year  = year - 1900;
    timeStruct.tm_mon   = month - 1;
    timeStruct.tm_mday  = day;
    timeStruct.tm_hour  = hour;
    timeStruct.tm_min   = minute;
    timeStruct.tm_sec   = second;
    timeStruct.tm_isdst = 0;

  #ifdef _WIN32
    time_t epochTime = _mkgmtime(&timeStruct);

    if (epochTime == -1)
      ERR(ParseError, "Failed to convert time to epoch using _mkgmtime (invalid date components or out of range)");

    return static_cast<usize>(epochTime);
  #else
    time_t epochTime = timegm(&timeStruct);

    if (epochTime == static_cast<time_t>(-1))
      ERR(ParseError, "Failed to convert time to epoch using timegm (invalid date components or out of range)");

    return epochTime;
  #endif
  }

  fn GetMetnoSymbolDescriptions() -> const std::unordered_map<StringView, StringView>& {
    static const std::unordered_map<StringView, StringView> MAP = {
      // Clear / Fair
      {             "clearsky",               "clear sky" },
      {                 "fair",                    "fair" },
      {         "partlycloudy",           "partly cloudy" },
      {               "cloudy",                  "cloudy" },
      {                  "fog",                     "fog" },

      // Rain
      {            "lightrain",              "light rain" },
      {     "lightrainshowers",      "light rain showers" },
      {  "lightrainandthunder",  "light rain and thunder" },
      {                 "rain",                    "rain" },
      {          "rainshowers",            "rain showers" },
      {       "rainandthunder",        "rain and thunder" },
      {            "heavyrain",              "heavy rain" },
      {     "heavyrainshowers",      "heavy rain showers" },
      {  "heavyrainandthunder",  "heavy rain and thunder" },

      // Sleet
      {           "lightsleet",             "light sleet" },
      {    "lightsleetshowers",     "light sleet showers" },
      { "lightsleetandthunder", "light sleet and thunder" },
      {                "sleet",                   "sleet" },
      {         "sleetshowers",           "sleet showers" },
      {      "sleetandthunder",       "sleet and thunder" },
      {           "heavysleet",             "heavy sleet" },
      {    "heavysleetshowers",     "heavy sleet showers" },
      { "heavysleetandthunder", "heavy sleet and thunder" },

      // Snow
      {            "lightsnow",              "light snow" },
      {     "lightsnowshowers",      "light snow showers" },
      {  "lightsnowandthunder",  "light snow and thunder" },
      {                 "snow",                    "snow" },
      {          "snowshowers",            "snow showers" },
      {       "snowandthunder",        "snow and thunder" },
      {            "heavysnow",              "heavy snow" },
      {     "heavysnowshowers",      "heavy snow showers" },
      {  "heavysnowandthunder",  "heavy snow and thunder" },
    };

    return MAP;
  }

  fn GetOpenmeteoWeatherDescription(const i32 code) -> String {
    // Based on WMO Weather interpretation codes (WW)
    // https://open-meteo.com/en/docs
    if (code == 0)
      return "clear sky";
    if (code == 1)
      return "mainly clear";
    if (code == 2)
      return "partly cloudy";
    if (code == 3)
      return "overcast";
    if (code == 45 || code == 48)
      return "fog";
    if (code >= 51 && code <= 55)
      return "drizzle";
    if (code == 56 || code == 57)
      return "freezing drizzle";
    if (code >= 61 && code <= 65)
      return "rain";
    if (code == 66 || code == 67)
      return "freezing rain";
    if (code >= 71 && code <= 75)
      return "snow fall";
    if (code == 77)
      return "snow grains";
    if (code >= 80 && code <= 82)
      return "rain showers";
    if (code == 85 || code == 86)
      return "snow showers";
    if (code == 95)
      return "thunderstorm";
    if (code >= 96 && code <= 99)
      return "thunderstorm with hail";
    return "unknown";
  }
} // namespace draconis::services::weather::utils

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Tests/CacheManagerTest.cpp">
#include <chrono>
#include <filesystem>
#include <thread>

#include <Drac++/Utils/CacheManager.hpp>
#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Types.hpp>

#include "gtest/gtest.h"

using namespace testing;
using namespace draconis::utils;

using cache::CacheLocation;
using cache::CacheManager;
using cache::CachePolicy;

using types::Err;
using types::i32;
using types::Option;
using types::PCStr;
using types::Result;
using types::String;
using types::Unit;

namespace fs = std::filesystem;
using namespace std::chrono_literals;

class CacheManagerTest : public Test {
 protected:
  // NOLINTBEGIN(*-non-private-member-variables-in-classes)
  fs::path      m_testDir;
  Result<PCStr> m_originalHome;
  // NOLINTEND(*-non-private-member-variables-in-classes)

  fn SetUp() -> Unit override {
    // Ensure we have a clean test environment
    m_testDir = fs::temp_directory_path() / "draconis_cache_test";

    if (fs::exists(m_testDir))
      fs::remove_all(m_testDir);

    fs::create_directories(m_testDir);

    // Clean up any existing temp directory cache files from previous test runs
    // This is needed because TempDirectoryCache test uses /tmp/temp_key
    fs::path tempKeyFile = fs::temp_directory_path() / "temp_key";
    if (fs::exists(tempKeyFile))
      fs::remove(tempKeyFile);

    // Set environment variable for test
    m_originalHome = env::GetEnv("HOME");

    env::SetEnv(
#ifdef _WIN32
      L"HOME",
#else
      "HOME",
#endif
      m_testDir.c_str()
    );
  }

  fn TearDown() -> Unit override {
    // Restore original environment
    if (m_originalHome)
      env::SetEnv("HOME", *m_originalHome);
    else
      env::UnsetEnv("HOME");

    // Clean up test directory
    if (fs::exists(m_testDir))
      fs::remove_all(m_testDir);
  }

  // Helper function to create a fetcher that counts calls
  static auto createCountingFetcher(i32& counter, i32 value) {
    return [&counter, value]() -> Result<i32> {
      counter++;
      return value;
    };
  }

  // Helper function to create a fetcher that simulates failure
  static auto createFailingFetcher() {
    return []() -> Result<i32> { ERR(error::DracErrorCode::Other, "Fetch failed"); };
  }

  // Helper function to create a fetcher with delay
  static auto createDelayedFetcher(i32 value, std::chrono::milliseconds delay) {
    return [value, delay]() -> Result<i32> {
      std::this_thread::sleep_for(delay);
      return value;
    };
  }
};

// Default constructor should not throw
TEST_F(CacheManagerTest, DefaultConstructor) {
  CacheManager cache;
}

// Basic memory cache tests
TEST_F(CacheManagerTest, MemoryCacheHit) {
  CacheManager cache;
  cache.setGlobalPolicy(CachePolicy::inMemory());

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch
  ASSERT_TRUE(cache.getOrSet<i32>("test_key", fetcher).has_value());
  EXPECT_EQ(*cache.getOrSet<i32>("test_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Second call should use cache
  EXPECT_EQ(*cache.getOrSet<i32>("test_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1); // Fetcher should not be called again
}

TEST_F(CacheManagerTest, DifferentKeysInMemory) {
  CacheManager cache;
  cache.setGlobalPolicy(CachePolicy::inMemory());

  i32 fetchCount1 = 0, fetchCount2 = 0;

  // First key
  auto fetcher1 = createCountingFetcher(fetchCount1, 42);
  EXPECT_EQ(*cache.getOrSet<i32>("key1", fetcher1), 42);

  // Second key
  auto fetcher2 = createCountingFetcher(fetchCount2, 84);
  EXPECT_EQ(*cache.getOrSet<i32>("key2", fetcher2), 84);

  // Both should be cached independently
  EXPECT_EQ(*cache.getOrSet<i32>("key1", fetcher1), 42);
  EXPECT_EQ(*cache.getOrSet<i32>("key2", fetcher2), 84);
}

TEST_F(CacheManagerTest, FetcherFailure) {
  CacheManager cache;
  cache.setGlobalPolicy(CachePolicy::inMemory());

  auto failingFetcher = createFailingFetcher();
  auto result         = cache.getOrSet<i32>("error_key", failingFetcher);

  EXPECT_FALSE(result.has_value());
  EXPECT_EQ(result.error().code, error::DracErrorCode::Other);
  EXPECT_EQ(result.error().message, "Fetch failed");
}

// Test with custom struct
struct TestData {
  i32    value;
  String name;

  bool operator==(const TestData& other) const {
    return value == other.value && name == other.name;
  }
};

namespace glz {
  template <>
  struct meta<TestData> {
    using T = TestData;

    static constexpr auto value = glz::object(
      "value",
      &TestData::value,
      "name",
      &TestData::name
    );
  };
} // namespace glz

TEST_F(CacheManagerTest, DifferentTypes) {
  CacheManager cache;
  cache.setGlobalPolicy(CachePolicy::inMemory());

  // Test with integer
  i32 intFetchCount = 0;
  EXPECT_EQ(*cache.getOrSet<i32>("int_key", createCountingFetcher(intFetchCount, 42)), 42);

  // Test with string
  i32  strFetchCount = 0;
  auto stringFetcher = [&strFetchCount]() -> Result<String> {
    strFetchCount++;
    return "cached string";
  };

  EXPECT_EQ(*cache.getOrSet<String>("string_key", stringFetcher), "cached string");
  EXPECT_EQ(strFetchCount, 1);

  i32  structFetchCount = 0;
  auto structFetcher    = [&structFetchCount]() -> Result<TestData> {
    structFetchCount++;
    return TestData { .value = 100, .name = "test struct" };
  };

  auto result = cache.getOrSet<TestData>("struct_key", structFetcher);
  ASSERT_TRUE(result.has_value());
  EXPECT_EQ(result->value, 100);
  EXPECT_EQ(result->name, "test struct");
  EXPECT_EQ(structFetchCount, 1);

  // Cached fetch should not increment counter
  auto cachedResult = cache.getOrSet<TestData>("struct_key", structFetcher);
  ASSERT_TRUE(cachedResult.has_value());
  EXPECT_EQ(cachedResult->value, 100);
  EXPECT_EQ(cachedResult->name, "test struct");
  EXPECT_EQ(structFetchCount, 1);
}

TEST_F(CacheManagerTest, PolicyOverride) {
  CacheManager cache;

  // Set global policy to persistent
  cache.setGlobalPolicy({ .location = CacheLocation::Persistent, .ttl = std::chrono::hours(24) });

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // Override with in-memory policy for this specific call
  Result<i32> result = cache.getOrSet<i32>("override_key", CachePolicy::inMemory(), fetcher);

  EXPECT_EQ(*result, 42);
  EXPECT_EQ(fetchCount, 1);

  // Should be cached in memory
  EXPECT_EQ(*cache.getOrSet<i32>("override_key", CachePolicy::inMemory(), fetcher), 42);
  EXPECT_EQ(fetchCount, 1);
}

// File cache tests
TEST_F(CacheManagerTest, TempDirectoryCache) {
  CacheManager cache;
  cache.setGlobalPolicy({ .location = CacheLocation::TempDirectory, .ttl = std::chrono::hours(24) });

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch and store in temp directory
  EXPECT_EQ(*cache.getOrSet<i32>("temp_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Create a new cache manager to simulate application restart
  CacheManager newCache;
  newCache.setGlobalPolicy({ .location = CacheLocation::TempDirectory, .ttl = std::chrono::hours(24) });

  // Should read from cache file without fetching
  EXPECT_EQ(*newCache.getOrSet<i32>("temp_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1); // Fetcher should not be called again
}

TEST_F(CacheManagerTest, PersistentDirectoryCache) {
  CacheManager cache;
  cache.setGlobalPolicy({ .location = CacheLocation::Persistent, .ttl = std::chrono::hours(24) });

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch and store in persistent directory
  EXPECT_EQ(*cache.getOrSet<i32>("persistent_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Verify cache file exists in the expected location
  fs::path cacheDir  = fs::path(m_testDir) / ".cache" / "draconis++";
  fs::path cacheFile = cacheDir / "persistent_key";
  ASSERT_TRUE(fs::exists(cacheFile));

  // Create a new cache manager to simulate application restart
  CacheManager newCache;
  newCache.setGlobalPolicy({ .location = CacheLocation::Persistent, .ttl = std::chrono::hours(24) });

  // Should read from cache file without fetching
  EXPECT_EQ(*newCache.getOrSet<i32>("persistent_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1); // Fetcher should not be called again
}

TEST_F(CacheManagerTest, CrossCacheLocationRetrieval) {
  // Test that caches with different locations don't interfere

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // Create and populate in-memory cache
  {
    CacheManager memoryCache;
    memoryCache.setGlobalPolicy(CachePolicy::inMemory());
    EXPECT_EQ(*memoryCache.getOrSet<i32>("cross_location_key", fetcher), 42);
    EXPECT_EQ(fetchCount, 1);
  }

  // Create file cache and verify it doesn't see memory-only cache
  CacheManager fileCache;
  fileCache.setGlobalPolicy({ .location = CacheLocation::Persistent, .ttl = std::chrono::hours(24) });

  EXPECT_EQ(*fileCache.getOrSet<i32>("cross_location_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 2); // Should fetch again because memory-only cache isn't persisted

  // Create a new file cache to verify persistence
  CacheManager newFileCache;
  newFileCache.setGlobalPolicy({ .location = CacheLocation::Persistent, .ttl = std::chrono::hours(24) });

  EXPECT_EQ(*newFileCache.getOrSet<i32>("cross_location_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 2); // Should read from persistent cache
}

// TTL and expiration tests
TEST_F(CacheManagerTest, MemoryCacheTTL) {
  using namespace std::chrono_literals;

  CacheManager cache;
  cache.setGlobalPolicy({ .location = CacheLocation::InMemory, .ttl = 1s }); // Use 1 second instead of 100ms

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch
  EXPECT_EQ(*cache.getOrSet<i32>("ttl_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Call before TTL expiration should use cache
  EXPECT_EQ(*cache.getOrSet<i32>("ttl_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Wait for TTL to expire
  std::this_thread::sleep_for(1100ms); // Wait slightly longer than 1 second

  // Call after TTL expiration should fetch again
  EXPECT_EQ(*cache.getOrSet<i32>("ttl_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 2);
}

TEST_F(CacheManagerTest, PersistentCacheTTL) {
  using namespace std::chrono_literals;

  CacheManager cache;
  cache.setGlobalPolicy({ .location = CacheLocation::Persistent, .ttl = 1s }); // Use 1 second instead of 100ms

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch
  EXPECT_EQ(*cache.getOrSet<i32>("persistent_ttl_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Call before TTL expiration should use cache
  EXPECT_EQ(*cache.getOrSet<i32>("persistent_ttl_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Wait for TTL to expire
  std::this_thread::sleep_for(1100ms); // Wait slightly longer than 1 second

  // Call after TTL expiration should fetch again
  EXPECT_EQ(*cache.getOrSet<i32>("persistent_ttl_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 2);
}

TEST_F(CacheManagerTest, NeverExpire) {
  CacheManager cache;
  cache.setGlobalPolicy(CachePolicy::neverExpire());

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch
  EXPECT_EQ(*cache.getOrSet<i32>("never_expire_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);

  // Wait some time
  std::this_thread::sleep_for(200ms);

  // Should still use cache since it never expires
  EXPECT_EQ(*cache.getOrSet<i32>("never_expire_key", fetcher), 42);
  EXPECT_EQ(fetchCount, 1);
}

TEST_F(CacheManagerTest, TTLOverride) {
  using namespace std::chrono_literals;

  CacheManager cache;
  cache.setGlobalPolicy({ .location = CacheLocation::InMemory, .ttl = 1h }); // Long global TTL

  i32  fetchCount = 0;
  auto fetcher    = createCountingFetcher(fetchCount, 42);

  // First call should fetch
  Result<i32> result = cache.getOrSet<i32>(
    "ttl_override_key",
    CachePolicy { .location = CacheLocation::InMemory, .ttl = 1s }, // Override with 1 second TTL
    fetcher
  );

  EXPECT_EQ(*result, 42);
  EXPECT_EQ(fetchCount, 1);

  // Wait for override TTL to expire
  std::this_thread::sleep_for(1100ms); // Wait slightly longer than 1 second

  // Should fetch again because we used the override TTL
  result = cache.getOrSet<i32>("ttl_override_key", CachePolicy { .location = CacheLocation::InMemory, .ttl = 1s }, fetcher);

  EXPECT_EQ(*result, 42);
  EXPECT_EQ(fetchCount, 2);
}

fn main(i32 argc, char** argv) -> i32 {
  InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
</file>

<file path="src/Lib/Wrappers/DBus.hpp">
#pragma once

#if (defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)) && DRAC_ENABLE_NOWPLAYING

  #include <cstring>
  #include <dbus/dbus.h> // DBus Library
  #include <type_traits> // std::is_convertible_v
  #include <utility>     // std::exchange, std::forward

  #include <Drac++/Utils/Error.hpp>
  #include <Drac++/Utils/Types.hpp>

namespace DBus {
  namespace {
    using enum draconis::utils::error::DracErrorCode;

    using draconis::utils::types::i32;
    using draconis::utils::types::None;
    using draconis::utils::types::Option;
    using draconis::utils::types::RawPointer;
    using draconis::utils::types::Result;
    using draconis::utils::types::String;
    using draconis::utils::types::Unit;
  } // namespace

  /**
   * @brief RAII wrapper for DBusError. Automatically initializes and frees the error.
   */
  class Error {
    DBusError m_err {};                ///< The D-Bus error object
    bool      m_isInitialized = false; ///< Flag indicating if the error is initialized

   public:
    /**
     * @brief Constructor
     *
     * Initializes the D-Bus error object.
     */
    Error()
      : m_isInitialized(true) {
      dbus_error_init(&m_err);
    }

    /**
     * @brief Destructor
     *
     * Frees the D-Bus error object if it was initialized.
     */
    ~Error() {
      if (m_isInitialized)
        dbus_error_free(&m_err);
    }

    // Non-copyable
    Error(const Error&)                = delete;
    fn operator=(const Error&)->Error& = delete;

    /**
     * @brief Move constructor
     *
     * Transfers ownership of the D-Bus error object.
     *
     * @param other The other Error object to move from
     */
    Error(Error&& other) noexcept
      : m_err(other.m_err), m_isInitialized(other.m_isInitialized) {
      other.m_isInitialized = false;
      dbus_error_init(&other.m_err);
    }

    /**
     * @brief Move assignment operator
     *
     * Transfers ownership of the D-Bus error object.
     *
     * @param other The other Error object to move from
     * @return A reference to this object
     */
    fn operator=(Error&& other) noexcept -> Error& {
      if (this != &other) {
        if (m_isInitialized)
          dbus_error_free(&m_err);

        m_err           = other.m_err;
        m_isInitialized = other.m_isInitialized;

        other.m_isInitialized = false;
        dbus_error_init(&other.m_err);
      }
      return *this;
    }

    /**
     * @brief Checks if the error is set.
     * @return True if the error is set and initialized, false otherwise.
     */
    [[nodiscard]] fn isSet() const -> bool {
      return m_isInitialized && dbus_error_is_set(&m_err);
    }

    /**
     * @brief Gets the error message.
     * @return The error message string, or "" if not set or not initialized.
     */
    [[nodiscard]] fn message() const -> const char* {
      return isSet() ? m_err.message : "";
    }

    /**
     * @brief Gets the error name.
     * @return The error name string (e.g., "org.freedesktop.DBus.Error.Failed"), or "" if not set or not initialized.
     */
    [[nodiscard]] fn name() const -> const char* {
      return isSet() ? m_err.name : "";
    }

    /**
     * @brief Gets a pointer to the underlying DBusError. Use with caution.
     * @return Pointer to the DBusError struct.
     */
    [[nodiscard]] fn get() -> DBusError* {
      return &m_err;
    }

    /**
     * @brief Gets a const pointer to the underlying DBusError.
     * @return Const pointer to the DBusError struct.
     */
    [[nodiscard]] fn get() const -> const DBusError* {
      return &m_err;
    }
  };

  /**
   * @brief RAII wrapper for DBusMessageIter. Automatically frees the iterator.
   *
   * This class provides a convenient way to manage the lifetime of a D-Bus message iterator.
   */
  class MessageIter {
    DBusMessageIter m_iter {};         ///< The D-Bus message iterator
    bool            m_isValid = false; ///< Flag indicating if the iterator is valid

    // Allows the Message class to access private members of this class.
    friend class Message;

    /**
     * @brief Constructor
     *
     * Initializes the D-Bus message iterator.
     *
     * @param iter The D-Bus message iterator to wrap
     * @param isValid Flag indicating if the iterator is valid
     */
    explicit MessageIter(const DBusMessageIter& iter, const bool isValid)
      : m_iter(iter), m_isValid(isValid) {}

    /**
     * @brief Destructor
     *
     * Frees the D-Bus message iterator if it was initialized.
     *
     * @param value Pointer to the value to be freed
     *
     * @note This function is unsafe and should not be called directly.
     */
    fn getBasic(RawPointer value) -> Unit {
      if (m_isValid)
        dbus_message_iter_get_basic(&m_iter, value);
    }

   public:
    // Non-copyable
    MessageIter(const MessageIter&)                = delete;
    fn operator=(const MessageIter&)->MessageIter& = delete;

    // Non-movable
    MessageIter(MessageIter&&)                = delete;
    fn operator=(MessageIter&&)->MessageIter& = delete;

    // Destructor
    ~MessageIter() = default;

    /**
     * @brief Checks if the iterator is validly initialized.
     */
    [[nodiscard]] fn isValid() const -> bool {
      return m_isValid;
    }

    /**
     * @brief Gets the D-Bus type code of the current argument.
     * @return The D-Bus type code, or DBUS_TYPE_INVALID otherwise.
     */
    [[nodiscard]] fn getArgType() -> i32 {
      return m_isValid ? dbus_message_iter_get_arg_type(&m_iter) : DBUS_TYPE_INVALID;
    }

    /**
     * @brief Gets the element type of the container pointed to by the iterator.
     * Only valid if the iterator points to an ARRAY or VARIANT.
     * @return The D-Bus type code of the elements, or DBUS_TYPE_INVALID otherwise.
     */
    [[nodiscard]] fn getElementType() -> i32 {
      return m_isValid ? dbus_message_iter_get_element_type(&m_iter) : DBUS_TYPE_INVALID;
    }

    /**
     * @brief Advances the iterator to the next argument.
     * @return True if successful (moved to a next element), false if at the end or iterator is invalid.
     */
    fn next() -> bool {
      return m_isValid && dbus_message_iter_next(&m_iter);
    }

    /**
     * @brief Recurses into a container-type argument (e.g., array, struct, variant).
     * @return A new MessageIterGuard for the sub-container. The returned iterator might be invalid
     * if the current element is not a container or the main iterator is invalid.
     */
    [[nodiscard]] fn recurse() -> MessageIter {
      if (!m_isValid)
        return MessageIter({}, false);

      DBusMessageIter subIter;
      dbus_message_iter_recurse(&m_iter, &subIter);

      return MessageIter(subIter, true);
    }

    /**
     * @brief Helper to safely get a string argument from the iterator.
     * @return An Option containing the string value if the current arg is a valid string, or None otherwise.
     */
    [[nodiscard]] fn getString() -> Option<String> {
      if (m_isValid && getArgType() == DBUS_TYPE_STRING) {
        const char* strPtr = nullptr;

        // ReSharper disable once CppRedundantCastExpression
        getBasic(static_cast<RawPointer>(&strPtr));

        if (strPtr)
          return String(strPtr);
      }

      return None;
    }
  };

  /**
   * @brief RAII wrapper for DBusMessage. Automatically unrefs.
   */
  class Message {
    DBusMessage* m_msg = nullptr; ///< The D-Bus message object

   public:
    /**
     * @brief Constructor
     *
     * Initializes the D-Bus message object.
     *
     * @param msg The D-Bus message object to wrap
     */
    explicit Message(DBusMessage* msg = nullptr)
      : m_msg(msg) {}

    /**
     * @brief Destructor
     *
     * Frees the D-Bus message object if it was initialized.
     */
    ~Message() {
      if (m_msg)
        dbus_message_unref(m_msg);
    }

    // Non-copyable
    Message(const Message&)                = delete;
    fn operator=(const Message&)->Message& = delete;

    /**
     * @brief Move constructor
     *
     * Transfers ownership of the D-Bus message object.
     *
     * @param other The other Message object to move from
     */
    Message(Message&& other) noexcept
      : m_msg(std::exchange(other.m_msg, nullptr)) {}

    /**
     * @brief Move assignment operator
     *
     * Transfers ownership of the D-Bus message object.
     *
     * @param other The other Message object to move from
     * @return A reference to this object
     */
    fn operator=(Message&& other) noexcept -> Message& {
      if (this != &other) {
        if (m_msg)
          dbus_message_unref(m_msg);
        m_msg = std::exchange(other.m_msg, nullptr);
      }
      return *this;
    }

    /**
     * @brief Gets the underlying DBusMessage pointer. Use with caution.
     * @return The raw DBusMessage pointer, or nullptr if not holding a message.
     */
    [[nodiscard]] fn get() const -> DBusMessage* {
      return m_msg;
    }

    /**
     * @brief Initializes a message iterator for reading arguments from this message.
     * @return A MessageIterGuard. Check iter.isValid() before use.
     */
    [[nodiscard]] fn iterInit() const -> MessageIter {
      if (!m_msg)
        return MessageIter({}, false);

      DBusMessageIter iter;
      const bool      isValid = dbus_message_iter_init(m_msg, &iter);
      return MessageIter(iter, isValid);
    }

    /**
     * @brief Appends arguments of basic types to the message.
     * @tparam Args Types of the arguments to append.
     * @param args The arguments to append.
     * @return True if all arguments were appended successfully, false otherwise (e.g., allocation error).
     */
    template <typename... Args>
    [[nodiscard]] fn appendArgs(Args&&... args) -> bool {
      if (!m_msg)
        return false;

      DBusMessageIter iter;
      dbus_message_iter_init_append(m_msg, &iter);

      bool success = true;
      ((success = success && appendArgInternal(iter, std::forward<Args>(args))), ...); // NOLINT
      return success;
    }

    /**
     * @brief Creates a new D-Bus method call message.
     * @param destination Service name (e.g., "org.freedesktop.Notifications"). Can be null.
     * @param path Object path (e.g., "/org/freedesktop/Notifications"). Must not be null.
     * @param interface Interface name (e.g., "org.freedesktop.Notifications"). Can be null.
     * @param method Method name (e.g., "Notify"). Must not be null.
     * @return Result containing a MessageGuard on success, or DracError on failure.
     */
    static fn newMethodCall(const char* destination, const char* path, const char* interface, const char* method)
      -> Result<Message> {
      DBusMessage* rawMsg = dbus_message_new_method_call(destination, path, interface, method);

      if (!rawMsg)
        ERR(OutOfMemory, "dbus_message_new_method_call failed (allocation failed?)");

      return Message(rawMsg);
    }

   private:
    /**
     * @brief Appends a single argument to the message.
     * @tparam T Type of the argument to append.
     * @param iter The D-Bus message iterator.
     * @param arg The argument to append.
     * @return True if the argument was appended successfully, false otherwise (e.g., allocation error).
     */
    template <typename T>
    fn appendArgInternal(DBusMessageIter& iter, T&& arg) -> bool {
      using DecayedT = std::decay_t<T>;

      if constexpr (std::is_convertible_v<DecayedT, const char*>) {
        const char* valuePtr = static_cast<const char*>(std::forward<T>(arg));
        return dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, static_cast<const RawPointer>(&valuePtr));
      } else {
        static_assert(!sizeof(T*), "Unsupported type passed to appendArgs");
        return false;
      }
    }
  };

  /**
   * @brief RAII wrapper for DBusConnection. Automatically unrefs the connection.
   *
   * This class provides a convenient way to manage the lifetime of a D-Bus connection.
   */
  class Connection {
    DBusConnection* m_conn = nullptr; ///< The D-Bus connection object

   public:
    /**
     * @brief Constructor
     *
     * Initializes the D-Bus connection object.
     *
     * @param conn The D-Bus connection object to wrap
     */
    explicit Connection(DBusConnection* conn = nullptr)
      : m_conn(conn) {}

    /**
     * @brief Destructor
     *
     * Frees the D-Bus connection object if it was initialized.
     */
    ~Connection() {
      if (m_conn)
        dbus_connection_unref(m_conn);
    }

    // Non-copyable
    Connection(const Connection&)                = delete;
    fn operator=(const Connection&)->Connection& = delete;

    /**
     * @brief Move constructor
     *
     * Transfers ownership of the D-Bus connection object.
     *
     * @param other The other Connection object to move from
     */
    Connection(Connection&& other) noexcept
      : m_conn(std::exchange(other.m_conn, nullptr)) {}

    /**
     * @brief Move assignment operator
     *
     * Transfers ownership of the D-Bus connection object.
     *
     * @param other The other Connection object to move from
     * @return A reference to this object
     */
    fn operator=(Connection&& other) noexcept -> Connection& {
      if (this != &other) {
        if (m_conn)
          dbus_connection_unref(m_conn);

        m_conn = std::exchange(other.m_conn, nullptr);
      }
      return *this;
    }

    /**
     * @brief Gets the underlying DBusConnection pointer. Use with caution.
     * @return The raw DBusConnection pointer, or nullptr if not holding a connection.
     */
    [[nodiscard]] fn get() const -> DBusConnection* {
      return m_conn;
    }

    /**
     * @brief Sends a message and waits for a reply, blocking execution.
     * @param message The D-Bus message guard to send.
     * @param timeout_milliseconds Timeout duration in milliseconds.
     * @return Result containing the reply MessageGuard on success, or DracError on failure.
     */
    [[nodiscard]] fn sendWithReplyAndBlock(const Message& message, const i32 timeout_milliseconds = 1000) const
      -> Result<Message> {
      if (!m_conn || !message.get())
        ERR(InvalidArgument, "Invalid connection or message provided to sendWithReplyAndBlock");

      Error        err;
      DBusMessage* rawReply =
        dbus_connection_send_with_reply_and_block(m_conn, message.get(), timeout_milliseconds, err.get());

      if (err.isSet()) {
        if (const char* errName = err.name()) {
          if (strcmp(errName, DBUS_ERROR_TIMEOUT) == 0 || strcmp(errName, DBUS_ERROR_NO_REPLY) == 0)
            ERR(Timeout, err.message());

          if (strcmp(errName, DBUS_ERROR_SERVICE_UNKNOWN) == 0)
            ERR(NotFound, err.message());

          if (strcmp(errName, DBUS_ERROR_ACCESS_DENIED) == 0)
            ERR(PermissionDenied, err.message());
        }

        ERR(PlatformSpecific, err.message());
      }

      if (!rawReply)
        ERR(ApiUnavailable, "dbus_connection_send_with_reply_and_block returned null without setting error (likely timeout or disconnected)");

      return Message(rawReply);
    }

    /**
     * @brief Connects to a D-Bus bus type (Session or System).
     * @param bus_type The type of bus (DBUS_BUS_SESSION or DBUS_BUS_SYSTEM).
     * @return Result containing a ConnectionGuard on success, or DracError on failure.
     */
    static fn busGet(const DBusBusType bus_type) -> Result<Connection> {
      Error           err;
      DBusConnection* rawConn = dbus_bus_get(bus_type, err.get());

      if (err.isSet())
        ERR(ApiUnavailable, err.message());

      if (!rawConn)
        ERR(ApiUnavailable, "dbus_bus_get returned null without setting error");

      return Connection(rawConn);
    }
  };
} // namespace DBus

#endif // (__linux__ || __FreeBSD__ || __DragonFly__ || __NetBSD__) && DRAC_ENABLE_NOWPLAYING
</file>

<file path="src/Lib/Wrappers/XCB.hpp">
#pragma once

#if DRAC_USE_XCB

  #include <xcb/randr.h> // XCB RandR extension
  #include <xcb/xcb.h>   // XCB library

  #include <Drac++/Utils/Types.hpp>

namespace XCB {
  namespace {
    using draconis::utils::types::i32;
    using draconis::utils::types::PCStr;
    using draconis::utils::types::RawPointer;
    using draconis::utils::types::u16;
    using draconis::utils::types::u32;
    using draconis::utils::types::u8;
    using draconis::utils::types::Unit;
  } // namespace

  using Connection = xcb_connection_t;
  using Setup      = xcb_setup_t;
  using Screen     = xcb_screen_t;
  using Window     = xcb_window_t;
  using Atom       = xcb_atom_t;

  using GenericError  = xcb_generic_error_t;
  using IntAtomCookie = xcb_intern_atom_cookie_t;
  using IntAtomReply  = xcb_intern_atom_reply_t;
  using GetPropCookie = xcb_get_property_cookie_t;
  using GetPropReply  = xcb_get_property_reply_t;

  using RandrOutput                          = xcb_randr_output_t;
  using RandrCrtc                            = xcb_randr_crtc_t;
  using RandrModeInfo                        = xcb_randr_mode_info_t;
  using RandrModeInfoIterator                = xcb_randr_mode_info_iterator_t;
  using QueryExtensionCookie                 = xcb_query_extension_cookie_t;
  using QueryExtensionReply                  = xcb_query_extension_reply_t;
  using RandrGetScreenResourcesCurrentCookie = xcb_randr_get_screen_resources_current_cookie_t;
  using RandrGetScreenResourcesCurrentReply  = xcb_randr_get_screen_resources_current_reply_t;
  using RandrGetOutputPrimaryCookie          = xcb_randr_get_output_primary_cookie_t;
  using RandrGetOutputPrimaryReply           = xcb_randr_get_output_primary_reply_t;
  using RandrGetOutputInfoCookie             = xcb_randr_get_output_info_cookie_t;
  using RandrGetOutputInfoReply              = xcb_randr_get_output_info_reply_t;
  using RandrGetCrtcInfoCookie               = xcb_randr_get_crtc_info_cookie_t;
  using RandrGetCrtcInfoReply                = xcb_randr_get_crtc_info_reply_t;
  using Timestamp                            = xcb_timestamp_t;

  constexpr Atom      ATOM_WINDOW  = XCB_ATOM_WINDOW;  ///< Window atom
  constexpr Timestamp CURRENT_TIME = XCB_CURRENT_TIME; ///< Current time for XCB requests
  constexpr u32       NONE         = XCB_NONE;         ///< None value for XCB requests

  /**
   * @brief Enum representing different types of connection errors
   *
   * This enum defines the possible types of errors that can occur when
   * establishing or maintaining an XCB connection. Each error type
   * corresponds to a specific error code defined in the XCB library.
   */
  enum ConnError : u8 {
    Generic         = XCB_CONN_ERROR,                   ///< Generic connection error
    ExtNotSupported = XCB_CONN_CLOSED_EXT_NOTSUPPORTED, ///< Extension not supported
    MemInsufficient = XCB_CONN_CLOSED_MEM_INSUFFICIENT, ///< Memory insufficient
    ReqLenExceed    = XCB_CONN_CLOSED_REQ_LEN_EXCEED,   ///< Request length exceed
    ParseErr        = XCB_CONN_CLOSED_PARSE_ERR,        ///< Parse error
    InvalidScreen   = XCB_CONN_CLOSED_INVALID_SCREEN,   ///< Invalid screen
    FdPassingFailed = XCB_CONN_CLOSED_FDPASSING_FAILED, ///< FD passing failed
  };

  /**
   * @brief Connect to an XCB display
   *
   * This function establishes a connection to an XCB display. It takes a
   * display name and a pointer to an integer that will store the screen
   * number.
   *
   * @param displayname The name of the display to connect to
   * @param screenp Pointer to an integer that will store the screen number
   * @return A pointer to the connection object
   */
  inline fn Connect(PCStr displayname, i32* screenp) -> Connection* {
    return xcb_connect(displayname, screenp);
  }

  /**
   * @brief Disconnect from an XCB display
   *
   * This function disconnects from an XCB display. It takes a pointer to
   * the connection object.
   *
   * @param conn The connection object to disconnect from
   */
  inline fn Disconnect(Connection* conn) -> Unit {
    xcb_disconnect(conn);
  }

  /**
   * @brief Check if a connection has an error
   *
   * This function checks if a connection has an error. It takes a pointer
   * to the connection object.
   *
   * @param conn The connection object to check
   * @return 1 if the connection has an error, 0 otherwise
   */
  inline fn ConnectionHasError(Connection* conn) -> i32 {
    return xcb_connection_has_error(conn);
  }

  /**
   * @brief Intern an atom
   *
   * This function interns an atom. It takes a connection object, a flag
   *
   * @param conn The connection object to intern the atom on
   * @param only_if_exists The flag to check if the atom exists
   * @param name_len The length of the atom name
   * @param name The name of the atom
   * @return The cookie for the atom
   */
  inline fn InternAtom(Connection* conn, const u8 only_if_exists, const u16 name_len, PCStr name) -> IntAtomCookie {
    return xcb_intern_atom(conn, only_if_exists, name_len, name);
  }

  /**
   * @brief Get the reply for an interned atom
   *
   * This function gets the reply for an interned atom. It takes a connection
   * object, a cookie, and a pointer to a generic error.
   *
   * @param conn The connection object
   * @param cookie The cookie for the atom
   * @param err The pointer to the generic error
   * @return The reply for the atom
   */
  inline fn InternAtomReply(Connection* conn, const IntAtomCookie cookie, GenericError** err) -> IntAtomReply* {
    return xcb_intern_atom_reply(conn, cookie, err);
  }

  /**
   * @brief Get a property
   *
   * This function gets a property. It takes a connection object, a flag,
   * a window, a property, a type, a long offset, and a long length.
   *
   * @param conn The connection object
   * @param _delete The flag
   * @param window The window
   * @param property The property
   * @param type The type
   */
  inline fn GetProperty(
    Connection*  conn,
    const u8     _delete,
    const Window window,
    const Atom   property,
    const Atom   type,
    const u32    long_offset,
    const u32    long_length
  ) -> GetPropCookie {
    return xcb_get_property(conn, _delete, window, property, type, long_offset, long_length);
  }

  /**
   * @brief Get the reply for a property
   *
   * This function gets the reply for a property. It takes a connection
   * object, a cookie, and a pointer to a generic error.
   *
   * @param conn The connection object
   * @param cookie The cookie for the property
   * @param err The pointer to the generic error
   * @return The reply for the property
   */
  inline fn GetPropertyReply(Connection* conn, const GetPropCookie cookie, GenericError** err) -> GetPropReply* {
    return xcb_get_property_reply(conn, cookie, err);
  }

  /**
   * @brief Get the value length for a property
   *
   * @param reply The reply for the property
   * @return The value length for the property
   */
  inline fn GetPropertyValueLength(const GetPropReply* reply) -> i32 {
    return xcb_get_property_value_length(reply);
  }

  /**
   * @brief Get the value for a property
   *
   * @param reply The reply for the property
   * @return The value for the property
   */
  inline fn GetPropertyValue(const GetPropReply* reply) -> RawPointer {
    return xcb_get_property_value(reply);
  }

  /**
   * @brief Query an XCB extension
   *
   * @param conn The connection object
   * @param len The length of the extension name
   * @param name The name of the extension
   * @return The cookie for the extension query
   */
  inline fn QueryExtension(Connection* conn, const u16 len, PCStr name) -> QueryExtensionCookie {
    return xcb_query_extension(conn, len, name);
  }

  /**
   * @brief Get the reply for an XCB extension query
   *
   * @param conn The connection object
   * @param cookie The cookie for the extension query
   * @param err The pointer to the generic error
   * @return The reply for the extension query
   */
  inline fn GetQueryExtensionReply(Connection* conn, const QueryExtensionCookie cookie, GenericError** err) -> QueryExtensionReply* {
    return xcb_query_extension_reply(conn, cookie, err);
  }

  /**
   * @brief Get the current screen resources
   *
   * @param conn The connection object
   * @param window The window
   * @return The cookie for the screen resources query
   */
  inline fn GetScreenResourcesCurrent(Connection* conn, const Window window) -> RandrGetScreenResourcesCurrentCookie {
    return xcb_randr_get_screen_resources_current(conn, window);
  }

  /**
   * @brief Get the reply for the current screen resources
   *
   * @param conn The connection object
   * @param cookie The cookie for the screen resources query
   * @param err The pointer to the generic error
   * @return The reply for the screen resources query
   */
  inline fn GetScreenResourcesCurrentReply(Connection* conn, const RandrGetScreenResourcesCurrentCookie cookie, GenericError** err) -> RandrGetScreenResourcesCurrentReply* {
    return xcb_randr_get_screen_resources_current_reply(conn, cookie, err);
  }

  /**
   * @brief Get the outputs from the screen resources reply
   *
   * @param reply The reply for the screen resources query
   * @return The outputs from the screen resources reply
   */
  inline fn GetScreenResourcesCurrentOutputs(const RandrGetScreenResourcesCurrentReply* reply) -> RandrOutput* {
    return xcb_randr_get_screen_resources_current_outputs(reply);
  }

  /**
   * @brief Get the length of the outputs from the screen resources reply
   *
   * @param reply The reply for the screen resources query
   * @return The length of the outputs from the screen resources reply
   */
  inline fn GetScreenResourcesCurrentOutputsLength(const RandrGetScreenResourcesCurrentReply* reply) -> i32 {
    return xcb_randr_get_screen_resources_current_outputs_length(reply);
  }

  /**
   * @brief Get the modes iterator from the screen resources reply
   *
   * @param reply The reply for the screen resources query
   * @return The modes iterator from the screen resources reply
   */
  inline fn GetScreenResourcesCurrentModesIterator(const RandrGetScreenResourcesCurrentReply* reply) -> RandrModeInfoIterator {
    return xcb_randr_get_screen_resources_current_modes_iterator(reply);
  }

  /**
   * @brief Get the next mode info from the modes iterator
   *
   * @param iter The modes iterator
   */
  inline fn ModeInfoNext(RandrModeInfoIterator* iter) -> Unit {
    xcb_randr_mode_info_next(iter);
  }

  /**
   * @brief Get the primary output
   *
   * @param conn The connection object
   * @param window The window
   * @return The cookie for the primary output query
   */
  inline fn GetOutputPrimary(Connection* conn, const Window window) -> RandrGetOutputPrimaryCookie {
    return xcb_randr_get_output_primary(conn, window);
  }

  /**
   * @brief Get the reply for the primary output
   *
   * @param conn The connection object
   * @param cookie The cookie for the primary output query
   * @param err The pointer to the generic error
   * @return The reply for the primary output query
   */
  inline fn GetOutputPrimaryReply(Connection* conn, const RandrGetOutputPrimaryCookie cookie, GenericError** err) -> RandrGetOutputPrimaryReply* {
    return xcb_randr_get_output_primary_reply(conn, cookie, err);
  }

  /**
   * @brief Get the output info
   *
   * @param conn The connection object
   * @param output The output
   * @param timestamp The timestamp
   * @return The cookie for the output info query
   */
  inline fn GetOutputInfo(Connection* conn, const RandrOutput output, const Timestamp timestamp) -> RandrGetOutputInfoCookie {
    return xcb_randr_get_output_info(conn, output, timestamp);
  }

  /**
   * @brief Get the reply for the output info
   *
   * @param conn The connection object
   * @param cookie The cookie for the output info query
   * @param err The pointer to the generic error
   * @return The reply for the output info query
   */
  inline fn GetOutputInfoReply(Connection* conn, const RandrGetOutputInfoCookie cookie, GenericError** err) -> RandrGetOutputInfoReply* {
    return xcb_randr_get_output_info_reply(conn, cookie, err);
  }

  /**
   * @brief Get the CRTC info
   *
   * @param conn The connection object
   * @param crtc The CRTC
   * @param timestamp The timestamp
   * @return The cookie for the CRTC info query
   */
  inline fn GetCrtcInfo(Connection* conn, const RandrCrtc crtc, const Timestamp timestamp) -> RandrGetCrtcInfoCookie {
    return xcb_randr_get_crtc_info(conn, crtc, timestamp);
  }

  /**
   * @brief Get the reply for the CRTC info
   *
   * @param conn The connection object
   * @param cookie The cookie for the CRTC info query
   * @param err The pointer to the generic error
   * @return The reply for the CRTC info query
   */
  inline fn GetCrtcInfoReply(Connection* conn, const RandrGetCrtcInfoCookie cookie, GenericError** err) -> RandrGetCrtcInfoReply* {
    return xcb_randr_get_crtc_info_reply(conn, cookie, err);
  }

  /**
   * RAII wrapper for X11 Display connections
   * Automatically handles resource acquisition and cleanup
   */
  class DisplayGuard {
    Connection* m_connection = nullptr; ///< The connection to the display

   public:
    /**
     * Opens an XCB connection
     * @param name Display name (nullptr for default)
     */
    explicit DisplayGuard(const PCStr name = nullptr)
      : m_connection(Connect(name, nullptr)) {}

    ~DisplayGuard() {
      if (m_connection)
        Disconnect(m_connection);
    }

    // Non-copyable
    DisplayGuard(const DisplayGuard&)                = delete;
    fn operator=(const DisplayGuard&)->DisplayGuard& = delete;

    // Movable
    DisplayGuard(DisplayGuard&& other) noexcept
      : m_connection(std::exchange(other.m_connection, nullptr)) {}

    /**
     * Move assignment operator
     * @param other The other display guard
     * @return The moved display guard
     */
    fn operator=(DisplayGuard&& other) noexcept -> DisplayGuard& {
      if (this != &other) {
        if (m_connection)
          Disconnect(m_connection);

        m_connection = std::exchange(other.m_connection, nullptr);
      }
      return *this;
    }

    /**
     * @brief Check if the display guard is valid
     * @return True if the display guard is valid, false otherwise
     */
    [[nodiscard]] explicit operator bool() const {
      return m_connection && !ConnectionHasError(m_connection);
    }

    /**
     * @brief Get the connection to the display
     * @return The connection to the display
     */
    [[nodiscard]] fn get() const -> Connection* {
      return m_connection;
    }

    /**
     * @brief Get the setup for the display
     * @return The setup for the display
     */
    [[nodiscard]] fn setup() const -> const Setup* {
      return m_connection ? xcb_get_setup(m_connection) : nullptr;
    }

    /**
     * @brief Get the root screen for the display
     * @return The root screen for the display
     */
    [[nodiscard]] fn rootScreen() const -> Screen* {
      const Setup* setup = this->setup();

      return setup ? xcb_setup_roots_iterator(setup).data : nullptr;
    }
  };

  /**
   * RAII wrapper for XCB replies
   * Handles automatic cleanup of various XCB reply objects
   */
  template <typename T>
  class ReplyGuard {
    T* m_reply = nullptr; ///< The reply to the XCB request

   public:
    /**
     * @brief Default constructor
     */
    ReplyGuard() = default;

    /**
     * @brief Constructor with a reply
     * @param reply The reply to the XCB request
     */
    explicit ReplyGuard(T* reply)
      : m_reply(reply) {}

    /**
     * @brief Destructor
     */
    ~ReplyGuard() {
      if (m_reply)
        free(m_reply);
    }

    // Non-copyable
    ReplyGuard(const ReplyGuard&)                = delete;
    fn operator=(const ReplyGuard&)->ReplyGuard& = delete;

    // Movable
    ReplyGuard(ReplyGuard&& other) noexcept
      : m_reply(std::exchange(other.m_reply, nullptr)) {}

    /**
     * @brief Move assignment operator
     * @param other The other reply guard
     * @return The moved reply guard
     */
    fn operator=(ReplyGuard&& other) noexcept -> ReplyGuard& {
      if (this != &other) {
        if (m_reply)
          free(m_reply);

        m_reply = std::exchange(other.m_reply, nullptr);
      }
      return *this;
    }

    /**
     * @brief Check if the reply guard is valid
     * @return True if the reply guard is valid, false otherwise
     */
    [[nodiscard]] explicit operator bool() const {
      return m_reply != nullptr;
    }

    /**
     * @brief Get the reply
     * @return The reply
     */
    [[nodiscard]] fn get() const -> T* {
      return m_reply;
    }

    /**
     * @brief Get the reply
     * @return The reply
     */
    [[nodiscard]] fn operator->() const->T* {
      return m_reply;
    }

    /**
     * @brief Dereference the reply
     * @return The reply
     */
    [[nodiscard]] fn operator*() const->T& {
      return *m_reply;
    }
  };
} // namespace XCB

#endif // DRAC_USE_XCB
</file>

<file path="include/Drac++/Services/Weather.hpp">
#pragma once

#if DRAC_ENABLE_WEATHER

  #include <glaze/core/common.hpp> // object
  #include <glaze/core/meta.hpp>   // Object
  #include <matchit.hpp>
  #include <variant>

  #include "../Utils/CacheManager.hpp"
  #include "../Utils/Types.hpp"

namespace draconis::services::weather {
  namespace {
    using utils::cache::CacheManager;

    using utils::types::f64;
    using utils::types::None;
    using utils::types::Option;
    using utils::types::Result;
    using utils::types::String;
    using utils::types::u8;
    using utils::types::UniquePointer;
  } // namespace

  inline fn GetCacheManager() -> UniquePointer<CacheManager>& {
    static UniquePointer<CacheManager> CacheManager;
    return CacheManager;
  }

  /**
   * @brief Specifies the weather service provider.
   * @see config::DRAC_WEATHER_PROVIDER in `config(.example).hpp`.
   */
  enum class Provider : u8 {
    OpenWeatherMap, ///< OpenWeatherMap API. Requires an API key. @see config::DRAC_API_KEY
    OpenMeteo,      ///< OpenMeteo API. Does not require an API key.
    MetNo,          ///< Met.no API. Does not require an API key.
  };

  /**
   * @brief Specifies the unit system for weather information.
   * @see config::DRAC_WEATHER_UNIT in `config(.example).hpp`.
   */
  enum class UnitSystem : u8 {
    Metric,   ///< Metric units (Celsius, kph, etc.).
    Imperial, ///< Imperial units (Fahrenheit, mph, etc.).
  };

  /**
   * @struct Report
   * @brief Represents a weather report.
   *
   * Contains temperature, conditions, and timestamp.
   */
  struct Report {
    f64            temperature; ///< Degrees (C/F)
    Option<String> name;        ///< Optional town/city name (may be missing for some providers)
    String         description; ///< Weather description (e.g., "clear sky", "rain")
  };

  struct Coords {
    f64 lat;
    f64 lon;
  };

  /**
   * @brief Location information from IP geolocation
   */
  struct IPLocationInfo {
    Coords coords;
    String city;
    String region;
    String country;
    String locationName; // Formatted location string
  };

  using Location = std::variant<String, Coords>;

  class IWeatherService {
   public:
    IWeatherService(const IWeatherService&) = delete;
    IWeatherService(IWeatherService&&)      = delete;

    fn operator=(const IWeatherService&)->IWeatherService& = delete;
    fn operator=(IWeatherService&&)->IWeatherService&      = delete;

    virtual ~IWeatherService() = default;

    [[nodiscard]] virtual fn getWeatherInfo() const -> Result<Report> = 0;

   protected:
    IWeatherService() = default;
  };

  fn CreateWeatherService(Provider provider, const Location& location, UnitSystem units, const Option<String>& apiKey = None) -> UniquePointer<IWeatherService>;

  /**
   * @brief Convert a place name to coordinates using Nominatim
   * @param placeName The name of the place (e.g., "New York, NY", "London, UK")
   * @return Coordinates if found, error otherwise
   */
  fn Geocode(const String& placeName) -> Result<Coords>;

  /**
   * @brief Get detailed current location information from IP address
   * @return Location info with coordinates and place names if found, error otherwise
   */
  fn GetCurrentLocationInfoFromIP() -> Result<IPLocationInfo>;
} // namespace draconis::services::weather

template <>
struct glz::meta<draconis::services::weather::Report> {
  using T = draconis::services::weather::Report;

  // clang-format off
  static constexpr detail::Object value = object(
    "temperature", &T::temperature,
    "name",        &T::name,
    "description", &T::description
  );
  // clang-format on
}; // namespace glz

template <>
struct std::formatter<draconis::services::weather::UnitSystem> {
  static constexpr auto parse(std::format_parse_context& ctx) {
    return ctx.begin();
  }

  static fn format(draconis::services::weather::UnitSystem unit, std::format_context& ctx) {
    using matchit::match, matchit::is, matchit::_;

    return std::format_to(ctx.out(), "{}", match(unit)(is | draconis::services::weather::UnitSystem::Metric = "metric", is | draconis::services::weather::UnitSystem::Imperial = "imperial"));
  }
};

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="include/Drac++/Utils/Error.hpp">
#pragma once

#include <matchit.hpp>     // matchit::{match, is, or_, _}
#include <source_location> // std::source_location

#ifdef _WIN32
  // ReSharper disable once CppUnusedIncludeDirective
  #include <guiddef.h>    // GUID
  #include <winerror.h>   // error values
  #include <winrt/base.h> // winrt::hresult_error
#endif

#include "Types.hpp"

namespace draconis::utils::error {
  namespace {
    using types::String;
    using types::u32;
    using types::u8;
  } // namespace

  /**
   * @enum DracErrorCode
   * @brief Error codes for general OS-level operations.
   */
  enum class DracErrorCode : u8 {
    ApiUnavailable,     ///< A required OS service/API is unavailable or failed unexpectedly at runtime.
    ConfigurationError, ///< Configuration or environment issue.
    CorruptedData,      ///< Data present but corrupt or inconsistent.
    InternalError,      ///< An error occurred within the application's OS abstraction code logic.
    InvalidArgument,    ///< An invalid argument was passed to a function or method.
    IoError,            ///< General I/O error (filesystem, pipes, etc.).
    NetworkError,       ///< A network-related error occurred (e.g., DNS resolution, connection failure).
    NotFound,           ///< A required resource (file, registry key, device, API endpoint) was not found.
    NotSupported,       ///< The requested operation is not supported on this platform, version, or configuration.
    Other,              ///< A generic or unclassified error originating from the OS or an external library.
    OutOfMemory,        ///< The system ran out of memory or resources to complete the operation.
    ParseError,         ///< Failed to parse data obtained from the OS (e.g., file content, API output).
    PermissionDenied,   ///< Insufficient permissions to perform the operation.
    PermissionRequired, ///< Operation requires elevated privileges.
    PlatformSpecific,   ///< An unmapped error specific to the underlying OS platform occurred (check message).
    ResourceExhausted,  ///< System resource limit reached (not memory).
    Timeout,            ///< An operation timed out (e.g., waiting for IPC reply).
    UnavailableFeature, ///< Feature not present on this hardware/OS.
  };

  /**
   * @struct DracError
   * @brief Holds structured information about an OS-level error.
   *
   * Used as the error type in Result for many os:: functions.
   */
  struct DracError {
    String               message;  ///< A descriptive error message, potentially including platform details.
    std::source_location location; ///< The source location where the error occurred (file, line, function).
    DracErrorCode        code;     ///< The general category of the error.

    DracError(const DracErrorCode errc, String msg, const std::source_location& loc = std::source_location::current())
      : message(std::move(msg)), location(loc), code(errc) {}
  };
} // namespace draconis::utils::error

#define ERR(errc, msg)          return ::draconis::utils::types::Err(::draconis::utils::error::DracError(errc, msg))
#define ERR_FROM(err)           return ::draconis::utils::types::Err(::draconis::utils::error::DracError(err))
#define ERR_FMT(errc, fmt, ...) return ::draconis::utils::types::Err(::draconis::utils::error::DracError(errc, std::format(fmt, __VA_ARGS__)))
</file>

<file path="nix/musl.nix">
{
  pkgs,
  nixpkgs,
  self,
  lib,
  ...
}: let
  muslPkgs = import nixpkgs {
    system = "x86_64-linux-musl";
    overlays = [
      (final: prev: {
        mimalloc = prev.mimalloc.overrideAttrs (oldAttrs: {
          cmakeFlags =
            (oldAttrs.cmakeFlags or [])
            ++ [(final.lib.cmakeBool "MI_LIBC_MUSL" true)];

          postPatch = ''
            sed -i '\|<linux/prctl.h>|s|^|// |' src/prim/unix/prim.c
          '';
        });
      })
    ];
  };

  llvmPackages = muslPkgs.llvmPackages_20;

  stdenv =
    muslPkgs.stdenvAdapters.useMoldLinker
    llvmPackages.libcxxStdenv;

  glaze = (muslPkgs.glaze.override {inherit stdenv;}).overrideAttrs (oldAttrs: rec {
    version = "5.5.4";

    src = pkgs.fetchFromGitHub {
      owner = "stephenberry";
      repo = "glaze";
      tag = "v${version}";
      hash = "sha256-v6/IJlwc+nYgTAn8DJcbRC+qhZtUR6xu45dwm7rueV8=";
    };

    cmakeFlags =
      (oldAttrs.cmakeFlags or [])
      ++ [
        "-Dglaze_DEVELOPER_MODE=OFF"
        "-Dglaze_BUILD_EXAMPLES=OFF"
      ];

    doCheck = false;

    enableAvx2 = stdenv.hostPlatform.isx86;
  });

  mkOverridden = buildSystem: pkg: ((pkg.override {inherit stdenv;}).overrideAttrs (oldAttrs: {
    "${buildSystem}Flags" =
      (oldAttrs."${buildSystem}Flags" or [])
      ++ (
        if buildSystem == "meson"
        then ["-Ddefault_library=static"]
        else if buildSystem == "cmake"
        then [
          "-D${muslPkgs.lib.toUpper pkg.pname}_BUILD_EXAMPLES=OFF"
          "-D${muslPkgs.lib.toUpper pkg.pname}_BUILD_TESTS=OFF"
          "-DBUILD_SHARED_LIBS=OFF"
        ]
        else throw "Invalid build system: ${buildSystem}"
      );
  }));

  deps = with pkgs.pkgsStatic; [
    curlMinimal
    dbus
    glaze
    (mkOverridden "cmake" gtest)
    llvmPackages_20.libcxx
    magic-enum
    openssl
    sqlite
    wayland
    xorg.libXau
    xorg.libXdmcp
    xorg.libxcb

    (mkOverridden "cmake" pugixml)
    (mkOverridden "cmake" sqlitecpp)
    (mkOverridden "meson" tomlplusplus)
  ];

  mkDraconisPackage = {native}:
    stdenv.mkDerivation {
      name =
        "draconis++-musl"
        + (
          if native
          then "-native"
          else "-generic"
        );
      version = "0.1.0";
      src = self;

      nativeBuildInputs = with pkgs;
        [
          cmake
          meson
          ninja
          pkg-config
        ]
        ++ lib.optional stdenv.isLinux xxd;

      mesonFlags = [
        "-Dbuild_for_musl=true"
        "-Dbuild_examples=false"
        "-Dbuild_switch_example=false"
        "-Duse_linked_pci_ids=true"
      ];

      buildInputs = deps;

      configurePhase = ''
        meson setup build --buildtype=release $mesonFlags
      '';

      buildPhase = ''
        cp ${pkgs.pciutils}/share/pci.ids pci.ids
        chmod +w pci.ids
        objcopy -I binary -O default pci.ids pci_ids.o
        rm pci.ids

        export LDFLAGS="$LDFLAGS $PWD/pci_ids.o"

        meson compile -C build
      '';

      checkPhase = ''
        meson test -C build --print-errorlogs
      '';

      installPhase = ''
        mkdir -p $out/bin $out/lib
        mv build/src/CLI/draconis++ $out/bin/draconis++
        mv build/src/Lib/libdrac++.a $out/lib/
        mkdir -p $out/include
        cp -r include/Drac++ $out/include/
      '';

      NIX_ENFORCE_NO_NATIVE =
        if native
        then 0
        else 1;

      meta.staticExecutable = true;
    };
in {
  "musl-generic" = mkDraconisPackage {native = false;};
  "musl-native" = mkDraconisPackage {native = true;};
}
</file>

<file path="src/Lib/OS/macOS/Bridge.hpp">
/**
 * @file Bridge.hpp
 * @brief Provides a C++ bridge to Objective-C macOS frameworks.
 *
 * This file declares functions that wrap macOS-specific APIs, allowing them
 * to be called from C++ code. This is necessary for interacting with frameworks
 * like Metal and MediaRemote.
 */

#pragma once

#ifdef __APPLE__

  #include <Drac++/Utils/DataTypes.hpp>
  #include <Drac++/Utils/Error.hpp>
  #include <Drac++/Utils/Types.hpp>

namespace draconis::core::system::macOS {
  namespace {
    using draconis::utils::types::MediaInfo;
    using draconis::utils::types::OSInfo;
    using draconis::utils::types::Result;
    using draconis::utils::types::String;
  } // namespace

  /**
   * @brief Fetches the currently playing song's title and artist from macOS.
   * @return A Result containing a MediaInfo struct on success, or a DracError on failure.
   *
   * @note This function dynamically loads the private MediaRemote.framework to access
   * the MRMediaRemoteGetNowPlayingInfo function. This is an unsupported Apple API and
   * could break in future macOS updates.
   *
   * The retrieval is asynchronous, so this function uses a dispatch_semaphore to
   * block and wait for the result from the callback.
   */
  fn GetNowPlayingInfo() -> Result<MediaInfo>;

  /**
   * @brief Gets the model name of the primary system GPU.
   * @return A Result containing the GPU name as a String on success, or a DracError on failure.
   *
   * This function uses the Metal framework, which is Apple's modern graphics API,
   * to identify the default graphics device.
   */
  fn GetGPUModel() -> Result<String>;

  /**
   * @brief Gets the version of the macOS operating system.
   * @return A Result containing the version as a String on success, or a DracError on failure.
   *
   * @note When using Nix to build the draconis++ library, the Apple SDK available in nixpkgs
   * returns 16, while the actual Tahoe SDK returns 26. To get around that, we simply add 10
   * to the displayed major version.
   */
  fn GetOSVersion() -> Result<OSInfo>;
} // namespace draconis::core::system::macOS

#endif
</file>

<file path="src/Lib/OS/macOS/Bridge.mm">
/**
 * @file Bridge.mm
 * @brief macOS-specific implementations for retrieving system information.
 *
 * This file contains functions that interact with private and public macOS frameworks
 * (MediaRemote and Metal) to fetch details about the currently playing media and the system's GPU.
 * This implementation is conditionally compiled and should only be included on Apple platforms.
 */

#ifdef __APPLE__

  #include "Bridge.hpp"

  #include <Metal/Metal.h>       // For MTLDevice to identify the GPU.
  #include <dispatch/dispatch.h> // For Grand Central Dispatch (GCD) semaphores and queues.

  #include <Drac++/Utils/Error.hpp>

using namespace draconis::utils::types;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;

// Forward-declare the function pointer type for the private MediaRemote API.
using MRMediaRemoteGetNowPlayingInfoFn =
  void (*)(dispatch_queue_t queue, void (^handler)(NSDictionary* information));

namespace draconis::core::system::macOS {
  fn GetNowPlayingInfo() -> Result<MediaInfo> {
    @autoreleasepool {
      // Since MediaRemote.framework is private, we cannot link against it directly.
      // Instead, it must be loaded at runtime using CFURL and CFBundle.
      CFURLRef urlRef = CFURLCreateWithFileSystemPath(
        kCFAllocatorDefault,
        CFSTR("/System/Library/PrivateFrameworks/MediaRemote.framework"),
        kCFURLPOSIXPathStyle,
        false
      );

      if (!urlRef)
        return Err(DracError(NotFound, "Failed to create CFURL for MediaRemote.framework"));

      // Create a bundle from the URL (basically an in-memory representation of the framework).
      CFBundleRef bundleRef = CFBundleCreate(kCFAllocatorDefault, urlRef);
      CFRelease(urlRef); // urlRef is no longer needed after bundle creation.

      if (!bundleRef)
        return Err(DracError(ApiUnavailable, "Failed to create bundle for MediaRemote.framework"));

      // Ensure CFRelease is called even if an error occurs.
      SharedPointer<std::remove_pointer_t<CFBundleRef>> managedBundle(bundleRef, [](CFBundleRef bundle) {
        if (bundle)
          CFRelease(bundle);
      });

      // Get a pointer to the MRMediaRemoteGetNowPlayingInfo function from the bundle.
      auto mrMediaRemoteGetNowPlayingInfo = std::bit_cast<MRMediaRemoteGetNowPlayingInfoFn>(
        CFBundleGetFunctionPointerForName(bundleRef, CFSTR("MRMediaRemoteGetNowPlayingInfo"))
      );

      if (!mrMediaRemoteGetNowPlayingInfo)
        return Err(DracError(ApiUnavailable, "Failed to get MRMediaRemoteGetNowPlayingInfo function pointer"));

      // A semaphore is used to make this asynchronous call behave synchronously.
      // Wait on the semaphore until the callback signals that it has completed.
      __block Result<MediaInfo>  result;
      const dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

      mrMediaRemoteGetNowPlayingInfo(
        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
        ^(NSDictionary* information) {
          if (!information) {
            result = Err(DracError(NotFound, "No media is currently playing"));
          } else {
            // Extract the title and artist from the dictionary. These keys are also from the private framework.
            const NSString* const title  = [information objectForKey:@"kMRMediaRemoteNowPlayingInfoTitle"];
            const NSString* const artist = [information objectForKey:@"kMRMediaRemoteNowPlayingInfoArtist"];

            result = MediaInfo(
              title ? Some([title UTF8String]) : None,
              artist ? Some([artist UTF8String]) : None
            );
          }

          // Signal the semaphore to unblock the waiting thread.
          dispatch_semaphore_signal(semaphore);
        }
      );

      // Block this thread indefinitely until the callback signals completion.
      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
      return result;
    }
  }

  fn GetGPUModel() -> Result<String> {
    @autoreleasepool {
      // Get the default Metal device, which typically corresponds to the active, primary GPU.
      id<MTLDevice> device = MTLCreateSystemDefaultDevice();

      if (!device)
        return Err(DracError(ApiUnavailable, "Failed to get default Metal device. No Metal-compatible GPU found."));

      NSString* gpuName = device.name;
      if (!gpuName)
        return Err(DracError(NotFound, "Failed to get GPU name from Metal device."));

      return [gpuName UTF8String];
    }
  }

  fn GetOSVersion() -> Result<OSInfo> {
    @autoreleasepool {
      using matchit::match, matchit::is, matchit::_;

      // NSProcessInfo is the easiest/fastest way to get the OS version.
      NSProcessInfo*           processInfo = [NSProcessInfo processInfo];
      NSOperatingSystemVersion version     = [processInfo operatingSystemVersion];

      return OSInfo(
        "macOS",
        std::format(
          "{}.{} {}",
          version.majorVersion,
          version.minorVersion,
          match(version.majorVersion)(
            is | 11 = "Big Sur",
            is | 12 = "Monterey",
            is | 13 = "Ventura",
            is | 14 = "Sonoma",
            is | 15 = "Sequoia",
            is | 26 = "Tahoe",
            is | _  = "Unknown"
          )
        ),
        "macos"
      );
    }
  }
} // namespace draconis::core::system::macOS

#endif
</file>

<file path="src/Lib/Services/Weather/OpenMeteoService.cpp">
#if DRAC_ENABLE_WEATHER

  #include "OpenMeteoService.hpp"

  #include "Drac++/Utils/CacheManager.hpp"
  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Types.hpp"

  #include "DataTransferObjects.hpp"
  #include "WeatherUtils.hpp"
  #include "Wrappers/Curl.hpp"

using namespace draconis::utils::types;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;
using draconis::services::weather::OpenMeteoService;
using draconis::services::weather::Report;
using draconis::services::weather::UnitSystem;

OpenMeteoService::OpenMeteoService(const f64 lat, const f64 lon, const UnitSystem units)
  : m_lat(lat), m_lon(lon), m_units(units) {}

fn OpenMeteoService::getWeatherInfo() const -> Result<Report> {
  using glz::error_ctx, glz::read, glz::error_code;

  return GetCacheManager()->getOrSet<Report>(
    "openmeteo_weather",
    [&]() -> Result<Report> {
      String url = std::format(
        "https://api.open-meteo.com/v1/forecast?latitude={:.4f}&longitude={:.4f}&current_weather=true&temperature_unit={}",
        m_lat,
        m_lon,
        m_units == UnitSystem::Imperial ? "fahrenheit" : "celsius"
      );

      String responseBuffer;

      Curl::Easy curl({
        .url                = url,
        .writeBuffer        = &responseBuffer,
        .timeoutSecs        = 10L,
        .connectTimeoutSecs = 5L,
      });

      if (!curl) {
        if (const Option<DracError>& initError = curl.getInitializationError())
          ERR_FROM(*initError);

        ERR(ApiUnavailable, "Failed to initialize cURL (Easy handle is invalid after construction)");
      }

      if (Result res = curl.perform(); !res)
        ERR_FROM(res.error());

      draconis::services::weather::dto::openmeteo::Response apiResp {};

      if (error_ctx errc = read<glz::opts { .error_on_unknown_keys = false }>(apiResp, responseBuffer.data()); errc.ec != error_code::none)
        ERR_FMT(ParseError, "Failed to parse JSON response: {}", format_error(errc, responseBuffer.data()));

      if (Result<usize> timestamp = draconis::services::weather::utils::ParseIso8601ToEpoch(apiResp.currentWeather.time); !timestamp)
        ERR_FROM(timestamp.error());

      Report out = {
        .temperature = apiResp.currentWeather.temperature,
        .name        = None,
        .description = draconis::services::weather::utils::GetOpenmeteoWeatherDescription(apiResp.currentWeather.weathercode),
      };
      return out;
    }
  );
}

#endif // DRAC_ENABLE_WEATHER
</file>

<file path="src/Lib/Services/Weather/WeatherFactory.cpp">
#include <glaze/core/common.hpp>
#include <glaze/core/meta.hpp>
#include <glaze/json.hpp>

#include "Drac++/Services/Weather.hpp"

#include "Drac++/Utils/CacheManager.hpp"
#include "Drac++/Utils/Error.hpp"
#include "Drac++/Utils/Types.hpp"

#include "Services/Weather/MetNoService.hpp"
#include "Services/Weather/OpenMeteoService.hpp"
#include "Services/Weather/OpenWeatherMapService.hpp"
#include "Wrappers/Curl.hpp"

using namespace draconis::utils::types;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;

// IP API response structure
struct IPApiResponse {
  f64    lat;
  f64    lon;
  String city;
  String regionName;
  String country;
  String status;
  String message;
};

template <>
struct glz::meta<IPApiResponse> {
  using T = IPApiResponse;

  // clang-format off
  static constexpr glz::detail::Object value = glz::object(
    "lat",        &T::lat,
    "lon",        &T::lon,
    "city",       &T::city,
    "regionName", &T::regionName,
    "country",    &T::country,
    "status",     &T::status,
    "message",    &T::message
  );
  // clang-format on
};

// Nominatim API response structure
struct NominatimResult {
  String lat;
  String lon;
  String displayName;
};

template <>
struct glz::meta<NominatimResult> {
  using T = NominatimResult;

  // clang-format off
  static constexpr glz::detail::Object value = glz::object(
    "lat",         &T::lat,
    "lon",         &T::lon,
    "displayName", &T::displayName
  );
  // clang-format on
};

namespace draconis::services::weather {
  fn CreateWeatherService(const Provider provider, const Location& location, UnitSystem units, const Option<String>& apiKey) -> UniquePointer<IWeatherService> {
    using enum Provider;

    if (GetCacheManager() == nullptr) {
      GetCacheManager() = std::make_unique<draconis::utils::cache::CacheManager>();
      GetCacheManager()->setGlobalPolicy({ .location = draconis::utils::cache::CacheLocation::Persistent, .ttl = std::chrono::minutes(15) });
    }

    assert(provider == OpenWeatherMap || provider == OpenMeteo || provider == MetNo);
    assert(apiKey.has_value() || provider != OpenWeatherMap);

    switch (provider) {
      case OpenWeatherMap:
        return std::make_unique<OpenWeatherMapService>(location, *apiKey, units);
      case OpenMeteo:
        return std::make_unique<OpenMeteoService>(std::get<Coords>(location).lat, std::get<Coords>(location).lon, units);
      case MetNo:
        return std::make_unique<MetNoService>(std::get<Coords>(location).lat, std::get<Coords>(location).lon, units);
      default:
        std::unreachable();
    }
  }

  fn Geocode(const String& placeName) -> Result<Coords> {
    Result<String> escapedPlaceName = Curl::Easy::escape(placeName);
    if (!escapedPlaceName)
      ERR_FROM(escapedPlaceName.error());

    String url = std::format("https://nominatim.openstreetmap.org/search?q={}&format=json&limit=1", *escapedPlaceName);

    String responseBuffer;

    Curl::Easy curl({
      .url                = url,
      .writeBuffer        = &responseBuffer,
      .timeoutSecs        = 10L,
      .connectTimeoutSecs = 5L,
      .userAgent          = String("draconisplusplus/" DRAC_VERSION " git.pupbrained.xyz/draconisplusplus"),
    });

    if (!curl) {
      if (const Option<DracError>& initError = curl.getInitializationError())
        ERR_FROM(*initError);

      ERR(ApiUnavailable, "Failed to initialize cURL for Nominatim request");
    }

    if (Result res = curl.perform(); !res)
      ERR_FROM(res.error());

    Vec<NominatimResult> results;

    if (glz::error_ctx errc = glz::read<glz::opts { .error_on_unknown_keys = false }>(results, responseBuffer.data()); errc != glz::error_code::none)
      ERR_FMT(ParseError, "Failed to parse Nominatim JSON response: {}", glz::format_error(errc, responseBuffer.data()));

    if (results.empty())
      ERR_FMT(NotFound, "No results found for place: {}", placeName);

    const auto& result = results.front();

    f64 lat = 0.0, lon = 0.0;

    try {
      lat = std::stod(result.lat);
      lon = std::stod(result.lon);
    } catch (const std::exception& e) {
      ERR_FMT(ParseError, "Failed to parse coordinates from Nominatim response: {}", e.what());
    }

    return Coords { .lat = lat, .lon = lon };
  }

  fn GetCurrentLocationInfoFromIP() -> Result<IPLocationInfo> {
    String responseBuffer;

    Curl::Easy curl({
      .url                = "http://ip-api.com/json/",
      .writeBuffer        = &responseBuffer,
      .timeoutSecs        = 10L,
      .connectTimeoutSecs = 5L,
    });

    if (!curl) {
      if (const Option<DracError>& initError = curl.getInitializationError())
        ERR_FROM(*initError);
      ERR(ApiUnavailable, "Failed to initialize cURL for IP geolocation");
    }

    if (Result res = curl.perform(); !res)
      ERR_FROM(res.error());

    try {
      IPApiResponse        response;
      const glz::error_ctx result = glz::read<glz::opts { .error_on_unknown_keys = false }>(response, responseBuffer);

      if (result)
        ERR_FMT(ParseError, "Failed to parse IP geolocation response: {}", glz::format_error(result, responseBuffer));

      if (response.status != "success") {
        String errorMsg = response.message.empty() ? "Unknown error" : response.message;
        ERR_FMT(ApiUnavailable, "IP geolocation service error: {}", errorMsg);
      }

      if (response.city.empty() && response.regionName.empty() && response.country.empty())
        ERR(ParseError, "IP geolocation response missing location information");

      String locationName;
      if (!response.city.empty() && !response.regionName.empty() && !response.country.empty())
        locationName = response.city + ", " + response.regionName + ", " + response.country;
      else if (!response.city.empty() && !response.country.empty())
        locationName = response.city + ", " + response.country;
      else if (!response.regionName.empty() && !response.country.empty())
        locationName = response.regionName + ", " + response.country;
      else if (!response.country.empty())
        locationName = response.country;
      else
        locationName = "Unknown Location";

      return IPLocationInfo {
        .coords       = { .lat = response.lat, .lon = response.lon },
        .city         = response.city.empty() ? "Unknown" : response.city,
        .region       = response.regionName.empty() ? "Unknown" : response.regionName,
        .country      = response.country.empty() ? "Unknown" : response.country,
        .locationName = locationName
      };
    } catch (const std::exception& e) {
      ERR_FMT(ParseError, "Failed to parse IP geolocation response: {}", e.what());
    }
  }
} // namespace draconis::services::weather
</file>

<file path="include/Drac++/Services/Packages.hpp">
#pragma once

#if DRAC_ENABLE_PACKAGECOUNT

  #include <filesystem> // std::filesystem::path

  #include "../Utils/CacheManager.hpp"
  #include "../Utils/Types.hpp"

namespace draconis::services::packages {
  namespace {
    namespace fs = std::filesystem;

    using utils::cache::CacheManager;

    using utils::types::Map;
    using utils::types::Option;
    using utils::types::Result;
    using utils::types::String;
    using utils::types::u64;
    using utils::types::u8;
  } // namespace

  /**
   * @brief Represents available package managers for package counting.
   *
   * @details This enum is used as a bitmask. Individual values can be combined
   * using the bitwise OR operator (`|`). The availability of specific package managers
   * is conditional on the operating system detected at compile time.
   *
   * @see config::DRAC_ENABLED_PACKAGE_MANAGERS in `config(.example).hpp`.
   * @see draconis::services::packages::operator|
   * @see draconis::services::packages::HasPackageManager
   */
  enum class Manager : u8 {
    NONE  = 0,      ///< No package manager.
    CARGO = 1 << 0, ///< Cargo, the Rust package manager.

  #if defined(__linux__) || defined(__APPLE__)
    NIX = 1 << 1, ///< Nix package manager (available on Linux and macOS).
  #endif

  #ifdef __linux__
    APK    = 1 << 2, ///< apk, the Alpine Linux package manager.
    DPKG   = 1 << 3, ///< dpkg, the Debian package system (used by APT).
    MOSS   = 1 << 4, ///< moss, the package manager for AerynOS.
    PACMAN = 1 << 5, ///< Pacman, the Arch Linux package manager.
    RPM    = 1 << 6, ///< RPM, package manager used by Fedora, RHEL, etc.
    XBPS   = 1 << 7, ///< XBPS, the X Binary Package System (used by Void Linux).
  #elifdef __APPLE__
    HOMEBREW = 1 << 2, ///< Homebrew, package manager for macOS.
    MACPORTS = 1 << 3, ///< MacPorts, package manager for macOS.
  #elifdef _WIN32
    WINGET     = 1 << 1, ///< Winget, the Windows Package Manager.
    CHOCOLATEY = 1 << 2, ///< Chocolatey, package manager for Windows.
    SCOOP      = 1 << 3, ///< Scoop, command-line installer for Windows.
  #elif defined(__FreeBSD__) || defined(__DragonFly__)
    PKGNG = 1 << 1, ///< pkg, package management system for FreeBSD and DragonFly BSD.
  #elifdef __NetBSD__
    PKGSRC = 1 << 1, ///< pkgsrc, package management system for NetBSD.
  #elifdef __HAIKU__
    HAIKUPKG = 1 << 1, ///< haikupkg, package manager for Haiku OS.
  #endif
  };

  /**
   * @brief Combines two PackageManager flags using a bitwise OR operation.
   *
   * @param pmA The first PackageManager flag.
   * @param pmB The second PackageManager flag.
   * @return A new PackageManager value representing the combination of pmA and pmB.
   */
  constexpr fn operator|(Manager pmA, Manager pmB)->Manager {
    return static_cast<Manager>(static_cast<u8>(pmA) | static_cast<u8>(pmB));
  }

  /**
   * @brief Combines two PackageManager flags using a bitwise OR operation and assigns the result to the first flag.
   *
   * @param lhs The first PackageManager flag.
   * @param rhs The second PackageManager flag.
   * @return The first PackageManager flag with the result of the bitwise OR operation.
   */
  constexpr fn operator|=(Manager& lhs, Manager rhs)->Manager& {
    return lhs = lhs | rhs;
  }

  /**
   * @brief Checks if a specific PackageManager flag is set in a given bitmask.
   * @note This is an internal helper function for the PackageCounting service.
   *
   * @param current_flags The bitmask of currently enabled PackageManager flags.
   * @param flag_to_check The specific PackageManager flag to check for.
   * @return `true` if `flag_to_check` is set in `current_flags`, `false` otherwise.
   */
  constexpr fn HasPackageManager(Manager current_flags, Manager flag_to_check) -> bool {
    return (static_cast<u8>(current_flags) & static_cast<u8>(flag_to_check)) != 0;
  }

  /**
   * @struct PackageManagerInfo
   * @brief Holds information needed to query a database-backed package manager.
   */
  struct PackageManagerInfo {
    String   id;         ///< Unique identifier (e.g., "pacman", "dpkg", used for cache key).
    fs::path dbPath;     ///< Filesystem path to the database or primary directory.
    String   countQuery; ///< Query string (e.g., SQL) or specific file/pattern if not DB.
  };

  /**
   * @brief Gets the total package count by querying all relevant package managers.
   * @return Result containing the total package count (u64) on success,
   * or a DracError if aggregation fails (individual errors logged).
   */
  fn GetTotalCount(CacheManager& cache, Manager enabledPackageManagers) -> Result<u64>;

  /**
   * @brief Gets individual package counts from all enabled package managers.
   * @return Result containing a map of package manager names to their counts on success,
   * or a DracError if all package managers fail (individual errors logged).
   */
  fn GetIndividualCounts(CacheManager& cache, Manager enabledPackageManagers) -> Result<Map<String, u64>>;

  /**
   * @brief Gets package count from a database using SQLite.
   * @param cache The CacheManager instance to use for caching.
   * @param pmId Identifier for the package manager (for logging/cache).
   * @param dbPath Path to the SQLite database file.
   * @param countQuery SQL query to count packages (e.g., "SELECT COUNT(*) FROM packages").
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetCountFromDb(CacheManager& cache, const String& pmId, const fs::path& dbPath, const String& countQuery) -> Result<u64>;

  /**
   * @brief Gets package count by iterating entries in a directory, optionally filtering and subtracting.
   * @param cache The CacheManager instance to use for caching.
   * @param pmId Identifier for the package manager (for logging/cache).
   * @param dirPath Path to the directory to iterate.
   * @param fileExtensionFilter Only count files with this extension (e.g., ".list").
   * @param subtractOne Subtract one from the final count.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetCountFromDirectory(
    CacheManager&   cache,
    const String&   pmId,
    const fs::path& dirPath,
    const String&   fileExtensionFilter,
    bool            subtractOne
  ) -> Result<u64>;

  /**
   * @brief Gets package count by iterating entries in a directory, filtering by extension.
   * @param cache The CacheManager instance to use for caching.
   * @param pmId Identifier for the package manager (for logging/cache).
   * @param dirPath Path to the directory to iterate.
   * @param fileExtensionFilter Only count files with this extension (e.g., ".list").
   * @return Result containing the count (u64) or a DracError. Defaults subtractOne to false.
   */
  fn GetCountFromDirectory(CacheManager& cache, const String& pmId, const fs::path& dirPath, const String& fileExtensionFilter) -> Result<u64>;

  /**
   * @brief Gets package count by iterating entries in a directory, optionally subtracting one.
   *
   * @warning This function is prone to misuse due to C++'s implicit conversion rules.
   * A string literal (const char*) can be implicitly converted to bool, causing this
   * overload to be called unintentionally when the user likely intended to call the
   * overload that accepts a file extension filter. Prefer explicit `String` construction
   * for the filter overload.
   *
   * @param cache The CacheManager instance to use for caching.
   * @param pmId Identifier for the package manager (for logging/cache).
   * @param dirPath Path to the directory to iterate.
   * @param subtractOne Subtract one from the final count.
   * @return Result containing the count (u64) or a DracError. Defaults fileExtensionFilter to "".
   */
  fn GetCountFromDirectory(
    CacheManager&   cache,
    const String&   pmId,
    const fs::path& dirPath,
    bool            subtractOne
  ) -> Result<u64>;

  /**
   * @brief Gets package count by iterating all entries in a directory.
   * @param cache The CacheManager instance to use for caching.
   * @param pmId Identifier for the package manager (for logging/cache).
   * @param dirPath Path to the directory to iterate.
   * @return Result containing the count (u64) or a DracError. Defaults filter to "" and subtractOne to false.
   */
  fn GetCountFromDirectory(CacheManager& cache, const String& pmId, const fs::path& dirPath) -> Result<u64>;

  /**
   * @brief Gets package count by iterating entries in a directory without caching (for internal use).
   * @param pmId Identifier for the package manager (for logging).
   * @param dirPath Path to the directory to iterate.
   * @param fileExtensionFilter Only count files with this extension (e.g., ".list").
   * @param subtractOne Subtract one from the final count.
   * @return Result containing the count (u64) or a DracError.
   * @note This function is for internal use to avoid nested cache calls.
   */
  fn GetCountFromDirectoryNoCache(
    const String&         pmId,
    const fs::path&       dirPath,
    const Option<String>& fileExtensionFilter,
    bool                  subtractOne
  ) -> Result<u64>;

  #ifdef __linux__
  /**
   * @brief Counts installed packages using APK.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountApk(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Dpkg.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountDpkg(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Moss.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountMoss(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Pacman.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountPacman(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Rpm.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountRpm(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Xbps.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountXbps(CacheManager& cache) -> Result<u64>;

  /**
   * @brief Counts installed packages in a plist file (used by xbps and potentially others).
   * @param cache The CacheManager instance to use for caching.
   * @param pmId Identifier for the package manager (for logging/cache).
   * @param plistPath Path to the plist file.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetCountFromPlist(CacheManager& cache, const String& pmId, const fs::path& plistPath) -> Result<u64>;
  #elifdef __APPLE__
  /**
   * @brief Counts installed packages using Homebrew.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetHomebrewCount(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using MacPorts.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetMacPortsCount(CacheManager& cache) -> Result<u64>;
  #elifdef _WIN32
  /**
   * @brief Counts installed packages using WinGet.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountWinGet(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Chocolatey.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountChocolatey(CacheManager& cache) -> Result<u64>;
  /**
   * @brief Counts installed packages using Scoop.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountScoop(CacheManager& cache) -> Result<u64>;
  #elif defined(__FreeBSD__) || defined(__DragonFly__)
  /**
   * @brief Counts installed packages using PkgNg.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetPkgNgCount(CacheManager& cache) -> Result<u64>;
  #elifdef __NetBSD__
  /**
   * @brief Counts installed packages using PkgSrc.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetPkgSrcCount(CacheManager& cache) -> Result<u64>;
  #elifdef __HAIKU__
  /**
   * @brief Counts installed packages using Haiku.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn GetSerenityCount(CacheManager& cache) -> Result<u64>;
  #endif

  #if defined(__linux__) || defined(__APPLE__)
  /**
   * @brief Counts installed packages using Nix.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountNix(CacheManager& cache) -> Result<u64>;
  #endif
  /**
   * @brief Counts installed packages using Cargo.
   * @param cache The CacheManager instance to use for caching.
   * @return Result containing the count (u64) or a DracError.
   */
  fn CountCargo(CacheManager& cache) -> Result<u64>;
} // namespace draconis::services::packages

#endif // DRAC_ENABLE_PACKAGECOUNT
</file>

<file path="nix/package.nix">
{
  pkgs,
  lib,
  self,
  ...
}: let
  llvmPackages = pkgs.llvmPackages_20;

  stdenv = with pkgs;
    (
      if hostPlatform.isLinux
      then stdenvAdapters.useMoldLinker
      else lib.id
    )
    llvmPackages.stdenv;

  deps = with pkgs;
    [
      ((glaze.override {enableAvx2 = hostPlatform.isx86;}).overrideAttrs rec {
        version = "5.5.4";

        src = pkgs.fetchFromGitHub {
          owner = "stephenberry";
          repo = "glaze";
          tag = "v${version}";
          hash = "sha256-v6/IJlwc+nYgTAn8DJcbRC+qhZtUR6xu45dwm7rueV8=";
        };
      })
    ]
    ++ (with pkgs.pkgsStatic; [
      curl
      gtest
      magic-enum
      sqlitecpp
      (tomlplusplus.overrideAttrs {
        doCheck = false;
      })
    ])
    ++ darwinPkgs
    ++ linuxPkgs;

  darwinPkgs = lib.optionals stdenv.isDarwin (with pkgs.pkgsStatic; [
    libiconv
    apple-sdk_15
  ]);

  linuxPkgs = lib.optionals stdenv.isLinux (with pkgs;
    [
      valgrind
    ]
    ++ (with pkgsStatic; [
      dbus
      pugixml
      xorg.libxcb
      wayland
    ]));

  mkDraconisPackage = {native}:
    stdenv.mkDerivation {
      name =
        "draconis++"
        + (
          if native
          then "-native"
          else "-generic"
        );
      version = "0.1.0";
      src = self;

      nativeBuildInputs = with pkgs;
        [
          cmake
          meson
          ninja
          pkg-config
        ]
        ++ lib.optional stdenv.isLinux xxd;

      buildInputs = deps;

      mesonFlags = [
        "-Dbuild_examples=false"
        "-Dbuild_switch_example=false"
        (lib.optionalString stdenv.isLinux "-Duse_linked_pci_ids=true")
      ];

      configurePhase = ''
        meson setup build --buildtype=release $mesonFlags
      '';

      buildPhase =
        lib.optionalString stdenv.isLinux ''
          cp ${pkgs.pciutils}/share/pci.ids pci.ids
          chmod +w pci.ids
          objcopy -I binary -O default pci.ids pci_ids.o
          rm pci.ids

          export LDFLAGS="$LDFLAGS $PWD/pci_ids.o"
        ''
        + ''
          meson compile -C build
        '';

      checkPhase = ''
        meson test -C build --print-errorlogs
      '';

      installPhase = ''
        mkdir -p $out/bin $out/lib
        mv build/src/CLI/draconis++ $out/bin/draconis++
        mv build/src/Lib/libdrac++.a $out/lib/
        mkdir -p $out/include
        cp -r include/Drac++ $out/include/
      '';

      NIX_ENFORCE_NO_NATIVE =
        if native
        then 0
        else 1;
    };
in {
  "generic" = mkDraconisPackage {native = false;};
  "native" = mkDraconisPackage {native = true;};
}
</file>

<file path="src/Lib/Wrappers/Wayland.hpp">
#pragma once

#if DRAC_USE_WAYLAND

  #include <cstring>          // std::strcmp
  #include <wayland-client.h> // Wayland client library

  #include <Drac++/Utils/DataTypes.hpp>
  #include <Drac++/Utils/Logging.hpp>
  #include <Drac++/Utils/Types.hpp>

namespace Wayland {
  namespace {
    using draconis::utils::types::CStr;
    using draconis::utils::types::DisplayInfo;
    using draconis::utils::types::f64;
    using draconis::utils::types::i32;
    using draconis::utils::types::PCStr;
    using draconis::utils::types::RawPointer;
    using draconis::utils::types::StringView;
    using draconis::utils::types::u32;
    using draconis::utils::types::Unit;
    using draconis::utils::types::usize;
    using draconis::utils::types::Vec;
  } // namespace

  using Display          = wl_display;
  using Registry         = wl_registry;
  using Output           = wl_output;
  using RegistryListener = wl_registry_listener;
  using OutputListener   = wl_output_listener;
  using Interface        = wl_interface;

  inline const Interface wl_output_interface = ::wl_output_interface;

  constexpr u32 OUTPUT_MODE_CURRENT = WL_OUTPUT_MODE_CURRENT;

  /**
   * @brief Connect to a Wayland display
   *
   * This function establishes a connection to a Wayland display. It takes a
   * display name as an argument.
   *
   * @param name The name of the display to connect to (or nullptr for default)
   * @return A pointer to the Wayland display object
   */
  inline fn Connect(PCStr name) -> Display* {
    return wl_display_connect(name);
  }

  /**
   * @brief Disconnect from a Wayland display
   *
   * This function disconnects from a Wayland display.
   *
   * @param display The Wayland display object to disconnect from
   * @return Unit
   */
  inline fn Disconnect(Display* display) -> Unit {
    wl_display_disconnect(display);
  }

  /**
   * @brief Get the file descriptor for a Wayland display
   *
   * This function retrieves the file descriptor for a Wayland display.
   *
   * @param display The Wayland display object
   * @return The file descriptor for the Wayland display
   */
  inline fn GetFd(Display* display) -> i32 {
    return wl_display_get_fd(display);
  }

  /**
   * @brief Get the registry for a Wayland display
   *
   * @param display The Wayland display object
   * @return The registry for the Wayland display
   */
  inline fn GetRegistry(Display* display) -> Registry* {
    return wl_display_get_registry(display);
  }

  /**
   * @brief Add a listener to a Wayland registry
   *
   * @param registry The Wayland registry object
   * @param listener The listener to add
   * @param data The data to pass to the listener
   * @return 0 on success, -1 on failure
   */
  inline fn AddRegistryListener(Registry* registry, const RegistryListener* listener, RawPointer data) -> i32 {
    return wl_registry_add_listener(registry, listener, data);
  }

  /**
   * @brief Process Wayland events
   *
   * @param display The Wayland display object
   * @return The number of events dispatched
   */
  inline fn Roundtrip(Display* display) -> i32 {
    return wl_display_roundtrip(display);
  }

  /**
   * @brief Bind to a Wayland object
   *
   * @param registry The Wayland registry object
   * @param name The name of the object to bind to
   * @param interface The interface to bind to
   * @param version The version of the interface to bind to
   * @return A pointer to the bound object
   */
  inline fn BindRegistry(Registry* registry, const u32 name, const Interface* interface, const u32 version) -> RawPointer {
    return wl_registry_bind(registry, name, interface, version);
  }

  /**
   * @brief Add a listener to a Wayland output
   *
   * @param output The Wayland output object
   * @param listener The listener to add
   * @param data The data to pass to the listener
   * @return 0 on success, -1 on failure
   */
  inline fn AddOutputListener(Output* output, const OutputListener* listener, RawPointer data) -> i32 {
    return wl_output_add_listener(output, listener, data);
  }

  /**
   * @brief Destroy a Wayland output
   *
   * @param output The Wayland output object
   */
  inline fn DestroyOutput(Output* output) -> Unit {
    wl_output_destroy(output);
  }

  /**
   * @brief Destroy a Wayland registry
   *
   * @param registry The Wayland registry object
   */
  inline fn DestroyRegistry(Registry* registry) -> Unit {
    wl_registry_destroy(registry);
  }

  /**
   * @brief RAII wrapper for Wayland display connections
   *
   * This class manages the connection to a Wayland display. It automatically
   * handles resource acquisition and cleanup.
   */
  class DisplayGuard {
    Display* m_display; ///< The Wayland display object

   public:
    /**
     * @brief Constructor
     *
     * This constructor sets up a custom logging handler for Wayland and
     * establishes a connection to the Wayland display.
     */
    DisplayGuard() {
      wl_log_set_handler_client([](PCStr fmt, va_list args) -> Unit {
        va_list argsCopy;
        va_copy(argsCopy, args);
        i32 size = std::vsnprintf(nullptr, 0, fmt, argsCopy);
        va_end(argsCopy);

        if (size < 0) {
          error_log("Wayland: Internal log formatting error (vsnprintf size check failed).");
          return;
        }

        Vec<CStr> buffer(static_cast<usize>(size) + 1);

        i32 writeSize = std::vsnprintf(buffer.data(), buffer.size(), fmt, args);

        if (writeSize < 0 || writeSize >= static_cast<int>(buffer.size())) {
          error_log("Wayland: Internal log formatting error (vsnprintf write failed).");
          return;
        }

        StringView msgView(buffer.data(), static_cast<usize>(writeSize));

        if (!msgView.empty() && msgView.back() == '\n')
          msgView.remove_suffix(1);

        debug_log("Wayland {}", msgView);
      });

      // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer) - needs to come after wl_log_set_handler_client
      m_display = Connect(nullptr);
    }

    /**
     * @brief Destructor
     *
     * This destructor disconnects from the Wayland display if it is valid.
     */
    ~DisplayGuard() {
      if (m_display)
        Disconnect(m_display);
    }

    // Non-copyable
    DisplayGuard(const DisplayGuard&)                = delete;
    fn operator=(const DisplayGuard&)->DisplayGuard& = delete;

    // Movable
    DisplayGuard(DisplayGuard&& other) noexcept
      : m_display(std::exchange(other.m_display, nullptr)) {}

    /**
     * @brief Move assignment operator
     *
     * This operator transfers ownership of the Wayland display connection.
     *
     * @param other The other DisplayGuard object to move from
     * @return A reference to this object
     */
    fn operator=(DisplayGuard&& other) noexcept -> DisplayGuard& {
      if (this != &other) {
        if (m_display)
          Disconnect(m_display);

        m_display = std::exchange(other.m_display, nullptr);
      }

      return *this;
    }

    /**
     * @brief Check if the display guard is valid
     *
     * This function checks if the display guard is valid (i.e., if it holds a
     * valid Wayland display connection).
     *
     * @return True if the display guard is valid, false otherwise
     */
    [[nodiscard]] explicit operator bool() const {
      return m_display != nullptr;
    }

    /**
     * @brief Get the Wayland display connection
     *
     * This function retrieves the underlying Wayland display connection.
     *
     * @return The Wayland display connection
     */
    [[nodiscard]] fn get() const -> Display* {
      return m_display;
    }

    /**
     * @brief Get the file descriptor for the Wayland display
     *
     * This function retrieves the file descriptor for the Wayland display.
     *
     * @return The file descriptor for the Wayland display
     */
    [[nodiscard]] fn fd() const -> i32 {
      return GetFd(m_display);
    }

    /**
     * @brief Get the registry for the Wayland display
     *
     * @return The registry for the Wayland display
     */
    [[nodiscard]] fn registry() const -> Registry* {
      return GetRegistry(m_display);
    }

    /**
     * @brief Process Wayland events
     *
     * @return The number of events dispatched
     */
    [[nodiscard]] fn roundtrip() const -> i32 {
      return Roundtrip(m_display);
    }
  };

  class DisplayManager {
   public:
    /**
     * @brief Constructor
     *
     * @param display The Wayland display object
     */
    explicit DisplayManager(Display* display)
      : m_display(display) {}

    /**
     * @brief Get information about all displays
     *
     * @return A vector of DisplayInfo objects
     */
    [[nodiscard]] fn getOutputs() -> Vec<DisplayInfo> {
      m_callbackData     = {};
      Registry* registry = GetRegistry(m_display);
      if (!registry)
        return {};

      const static RegistryListener REGISTRY_LISTENER = {
        .global        = registryHandler,
        .global_remove = nullptr,
      };

      AddRegistryListener(registry, &REGISTRY_LISTENER, this);
      Roundtrip(m_display);
      DestroyRegistry(registry);

      Vec<DisplayInfo> displays;
      for (const auto& output : m_callbackData.outputs) {
        displays.emplace_back(
          output.id,
          DisplayInfo::Resolution { .width = output.width, .height = output.height },
          output.refreshRate / 1000.0,
          displays.empty()
        );
      }

      return displays;
    }

    /**
     * @brief Get information about the primary display
     *
     * @return A DisplayInfo object for the primary display
     */
    [[nodiscard]] fn getPrimary() -> DisplayInfo {
      m_primaryDisplayData = {};
      Registry* registry   = GetRegistry(m_display);
      if (!registry)
        return {};

      const static RegistryListener REGISTRY_LISTENER = {
        .global        = primaryRegistry,
        .global_remove = nullptr,
      };

      AddRegistryListener(registry, &REGISTRY_LISTENER, this);
      while (!m_primaryDisplayData.done) {
        if (Roundtrip(m_display) < 0)
          break;
      }
      DestroyRegistry(registry);
      return m_primaryDisplayData.display;
    }

   private:
    Display* m_display; ///< The Wayland display object

    /**
     * @brief Data for display callbacks
     */
    struct CallbackData {
      struct Inner {
        usize id;
        usize width;
        usize height;
        f64   refreshRate;
      };

      Vec<Inner> outputs;
    };

    CallbackData m_callbackData; ///< Data for all outputs

    /**
     * @brief Data for primary display callbacks
     */
    struct PrimaryDisplayData {
      Output*     output = nullptr;
      DisplayInfo display;
      bool        done = false;
    };

    PrimaryDisplayData m_primaryDisplayData; ///< Data for the primary output

    /**
     * @brief Wayland output mode callback
     *
     * @param flags The output mode flags
     * @param width The width of the output
     * @param height The height of the output
     * @param refresh The refresh rate of the output
     */
    fn outputMode(u32 flags, i32 width, i32 height, i32 refresh) -> Unit {
      if (!(flags & WL_OUTPUT_MODE_CURRENT))
        return;

      if (!m_callbackData.outputs.empty()) {
        CallbackData::Inner& currentOutput = m_callbackData.outputs.back();
        currentOutput.width                = width > 0 ? width : 0;
        currentOutput.height               = height > 0 ? height : 0;
        currentOutput.refreshRate          = refresh > 0 ? refresh : 0;
      }
    }

    /**
     * @brief Static Wayland output mode callback
     *
     * @param data The user data
     * @param output The Wayland output object
     * @param flags The output mode flags
     * @param width The width of the output
     * @param height The height of the output
     * @param refresh The refresh rate of the output
     */
    static fn outputMode(RawPointer data, wl_output* /*output*/, u32 flags, i32 width, i32 height, i32 refresh) -> Unit {
      static_cast<DisplayManager*>(data)->outputMode(flags, width, height, refresh);
    }

    /**
     * @brief Wayland registry handler
     *
     * @param registry The Wayland registry object
     * @param objectId The object ID
     * @param interface The interface name
     * @param version The interface version
     */
    fn registryHandler(Registry* registry, u32 objectId, PCStr interface, u32 version) -> Unit {
      if (std::strcmp(interface, "wl_output") != 0)
        return;

      auto* output = static_cast<Output*>(BindRegistry(
        registry,
        objectId,
        &wl_output_interface,
        std::min(version, 2U)
      ));

      if (!output)
        return;

      const static OutputListener OUTPUT_LISTENER = {
        .geometry    = nullptr,
        .mode        = outputMode,
        .done        = nullptr,
        .scale       = nullptr,
        .name        = nullptr,
        .description = nullptr
      };

      m_callbackData.outputs.push_back({ .id = objectId, .width = 0, .height = 0, .refreshRate = 0.0 });
      AddOutputListener(output, &OUTPUT_LISTENER, this);
    }

    /**
     * @brief Static Wayland registry handler
     *
     * @param data The user data
     * @param registry The Wayland registry object
     * @param name The name of the object
     * @param interface The interface name
     * @param version The interface version
     */
    static fn registryHandler(RawPointer data, wl_registry* registry, u32 name, PCStr interface, u32 version) -> Unit {
      static_cast<DisplayManager*>(data)->registryHandler(registry, name, interface, version);
    }

    /**
     * @brief Wayland primary display mode callback
     *
     * @param flags The output mode flags
     * @param width The width of the output
     * @param height The height of the output
     * @param refresh The refresh rate of the output
     */
    fn primaryMode(u32 flags, i32 width, i32 height, i32 refresh) -> Unit {
      if (!(flags & WL_OUTPUT_MODE_CURRENT) || m_primaryDisplayData.done)
        return;

      m_primaryDisplayData.display.resolution  = { .width = static_cast<usize>(width), .height = static_cast<usize>(height) };
      m_primaryDisplayData.display.refreshRate = refresh > 0 ? refresh / 1000 : 0;
    }

    /**
     * @brief Static Wayland primary display mode callback
     *
     * @param data The user data
     * @param output The Wayland output object
     * @param flags The output mode flags
     * @param width The width of the output
     * @param height The height of the output
     * @param refresh The refresh rate of the output
     */
    static fn primaryMode(RawPointer data, wl_output* /*output*/, u32 flags, i32 width, i32 height, i32 refresh) -> Unit {
      static_cast<DisplayManager*>(data)->primaryMode(flags, width, height, refresh);
    }

    /**
     * @brief Wayland primary display done callback
     */
    fn primaryDone() -> Unit {
      if (m_primaryDisplayData.display.resolution.width > 0)
        m_primaryDisplayData.done = true;
    }

    /**
     * @brief Static Wayland primary display done callback
     *
     * @param data The user data
     * @param wl_output The Wayland output object
     */
    static fn primaryDone(RawPointer data, wl_output* /*wl_output*/) -> Unit {
      static_cast<DisplayManager*>(data)->primaryDone();
    }

    static fn primaryScale(RawPointer /*data*/, wl_output* /*wl_output*/, i32 /*scale*/) -> Unit {}
    static fn primaryGeometry(void* /*data*/, struct wl_output* /*wl_output*/, int32_t /*x*/, int32_t /*y*/, int32_t /*physical_width*/, int32_t /*physical_height*/, int32_t /*subpixel*/, const char* /*make*/, const char* /*model*/, int32_t /*transform*/) -> Unit {}

    /**
     * @brief Wayland primary display registry handler
     *
     * @param registry The Wayland registry object
     * @param name The name of the object
     * @param interface The interface name
     * @param version The interface version
     */
    fn primaryRegistry(Registry* registry, u32 name, PCStr interface, u32 version) -> Unit {
      if (m_primaryDisplayData.output != nullptr || std::strcmp(interface, "wl_output") != 0)
        return;

      m_primaryDisplayData.display.id        = name;
      m_primaryDisplayData.display.isPrimary = true;

      m_primaryDisplayData.output = static_cast<Output*>(BindRegistry(
        registry,
        name,
        &wl_output_interface,
        std::min(version, 2U)
      ));

      if (!m_primaryDisplayData.output)
        return;

      const static OutputListener LISTENER = {
        .geometry    = primaryGeometry,
        .mode        = primaryMode,
        .done        = primaryDone,
        .scale       = primaryScale,
        .name        = nullptr,
        .description = nullptr
      };

      AddOutputListener(m_primaryDisplayData.output, &LISTENER, this);
    }

    /**
     * @brief Static Wayland primary display registry handler
     *
     * @param data The user data
     * @param registry The Wayland registry object
     * @param name The name of the object
     * @param interface The interface name
     * @param version The interface version
     */
    static fn primaryRegistry(RawPointer data, wl_registry* registry, u32 name, PCStr interface, u32 version) -> Unit {
      static_cast<DisplayManager*>(data)->primaryRegistry(registry, name, interface, version);
    }
  };
} // namespace Wayland

#endif // DRAC_USE_WAYLAND
</file>

<file path="include/Drac++/Utils/Logging.hpp">
#pragma once

#include <chrono>     // std::chrono::{days, floor, seconds, system_clock}
#include <ctime>      // localtime_r/s, strftime, time_t, tm
#include <filesystem> // std::filesystem::path
#include <format>     // std::format
#include <utility>    // std::forward

#ifdef __cpp_lib_print
  #include <print> // std::print
#else
  #include <iostream> // std::cout, std::cerr
#endif

#ifndef NDEBUG
  #include <source_location> // std::source_location
#endif

#include "Error.hpp"
#include "Types.hpp"

namespace draconis::utils::logging {
  namespace {
    using types::Array;
    using types::LockGuard;
    using types::Mutex;
    using types::PCStr;
    using types::String;
    using types::StringView;
    using types::u64;
    using types::u8;
    using types::usize;
  } // namespace

  inline fn GetLogMutex() -> Mutex& {
    static Mutex LogMutexInstance;
    return LogMutexInstance;
  }

  enum class LogColor : u8 {
    Black         = 0,
    Red           = 1,
    Green         = 2,
    Yellow        = 3,
    Blue          = 4,
    Magenta       = 5,
    Cyan          = 6,
    White         = 7,
    Gray          = 8,
    BrightRed     = 9,
    BrightGreen   = 10,
    BrightYellow  = 11,
    BrightBlue    = 12,
    BrightMagenta = 13,
    BrightCyan    = 14,
    BrightWhite   = 15,
  };

  constexpr LogColor DEBUG_COLOR      = LogColor::Cyan;
  constexpr LogColor INFO_COLOR       = LogColor::Green;
  constexpr LogColor WARN_COLOR       = LogColor::Yellow;
  constexpr LogColor ERROR_COLOR      = LogColor::Red;
  constexpr LogColor DEBUG_INFO_COLOR = LogColor::White;

  struct LogLevelConst {
    // clang-format off
    static constexpr Array<StringView, 16> COLOR_CODE_LITERALS = {
      "\033[38;5;0m",  "\033[38;5;1m",  "\033[38;5;2m",  "\033[38;5;3m",
      "\033[38;5;4m",  "\033[38;5;5m",  "\033[38;5;6m",  "\033[38;5;7m",
      "\033[38;5;8m",  "\033[38;5;9m",  "\033[38;5;10m", "\033[38;5;11m",
      "\033[38;5;12m", "\033[38;5;13m", "\033[38;5;14m", "\033[38;5;15m",
    };
    // clang-format on

    static constexpr const char* RESET_CODE   = "\033[0m";
    static constexpr const char* BOLD_START   = "\033[1m";
    static constexpr const char* BOLD_END     = "\033[22m";
    static constexpr const char* ITALIC_START = "\033[3m";
    static constexpr const char* ITALIC_END   = "\033[23m";

    static constexpr StringView DEBUG_STR = "DEBUG";
    static constexpr StringView INFO_STR  = "INFO ";
    static constexpr StringView WARN_STR  = "WARN ";
    static constexpr StringView ERROR_STR = "ERROR";

    static constexpr PCStr TIMESTAMP_FORMAT = "%X";
    static constexpr PCStr LOG_FORMAT       = "{} {} {}";

#ifndef NDEBUG
    static constexpr PCStr DEBUG_INFO_FORMAT = "{}{}{}\n";
    static constexpr PCStr FILE_LINE_FORMAT  = "{}:{}";
    static constexpr PCStr DEBUG_LINE_PREFIX = "           ╰──── ";
#endif
  };

  /**
   * @enum LogLevel
   * @brief Represents different log levels.
   */
  enum class LogLevel : u8 {
    Debug,
    Info,
    Warn,
    Error,
  };

  inline fn GetRuntimeLogLevel() -> LogLevel& {
    static LogLevel RuntimeLogLevel = LogLevel::Info;
    return RuntimeLogLevel;
  }

  inline fn SetRuntimeLogLevel(const LogLevel level) {
    GetRuntimeLogLevel() = level;
  }

  /**
   * @brief Directly applies ANSI color codes to text
   * @param text The text to colorize
   * @param color The color
   * @return Styled string with ANSI codes
   */
  inline fn Colorize(const StringView text, const LogColor color) -> String {
    return std::format("{}{}{}", LogLevelConst::COLOR_CODE_LITERALS.at(static_cast<usize>(color)), text, LogLevelConst::RESET_CODE);
  }

  /**
   * @brief Make text bold with ANSI codes
   * @param text The text to make bold
   * @return Bold text
   */
  inline fn Bold(const StringView text) -> String {
    return std::format("{}{}{}", LogLevelConst::BOLD_START, text, LogLevelConst::BOLD_END);
  }

  /**
   * @brief Make text italic with ANSI codes
   * @param text The text to make italic
   * @return Italic text
   */
  inline fn Italic(const StringView text) -> String {
    return std::format("{}{}{}", LogLevelConst::ITALIC_START, text, LogLevelConst::ITALIC_END);
  }

  /**
   * @brief Returns the pre-formatted and styled log level strings.
   * @note Uses function-local static for lazy initialization to avoid
   * static initialization order issues and CERT-ERR58-CPP warnings.
   */
  inline fn GetLevelInfo() -> const Array<String, 4>& {
    static const Array<String, 4> LEVEL_INFO_INSTANCE = {
      Bold(Colorize(LogLevelConst::DEBUG_STR, DEBUG_COLOR)),
      Bold(Colorize(LogLevelConst::INFO_STR, INFO_COLOR)),
      Bold(Colorize(LogLevelConst::WARN_STR, WARN_COLOR)),
      Bold(Colorize(LogLevelConst::ERROR_STR, ERROR_COLOR)),
    };
    return LEVEL_INFO_INSTANCE;
  }

  /**
   * @brief Returns the LogColor for a log level
   * @param level The log level
   * @return The LogColor for the log level
   */
  constexpr fn GetLevelColor(const LogLevel level) -> LogColor {
    using namespace matchit;
    using enum LogLevel;

    return match(level)(
      is | Debug = DEBUG_COLOR,
      is | Info  = INFO_COLOR,
      is | Warn  = WARN_COLOR,
      is | Error = ERROR_COLOR
    );
  }

  /**
   * @brief Returns string representation of a log level
   * @param level The log level
   * @return String representation
   */
  constexpr fn GetLevelString(const LogLevel level) -> StringView {
    using namespace matchit;
    using enum LogLevel;

    return match(level)(
      is | Debug = LogLevelConst::DEBUG_STR,
      is | Info  = LogLevelConst::INFO_STR,
      is | Warn  = LogLevelConst::WARN_STR,
      is | Error = LogLevelConst::ERROR_STR
    );
  }

  /**
   * @brief Returns whether a log level should use stderr
   * @param level The log level
   * @return true if the level should use stderr, false for stdout
   */
  constexpr fn ShouldUseStderr(const LogLevel level) -> bool {
    return level == LogLevel::Warn || level == LogLevel::Error;
  }

  /**
   * @brief Helper function to print formatted text with automatic std::print/std::cout selection
   * @tparam Args Parameter pack for format arguments
   * @param level The log level to determine output stream
   * @param fmt The format string
   * @param args The arguments for the format string
   */
  template <typename... Args>
  inline fn Print(const LogLevel level, std::format_string<Args...> fmt, Args&&... args) {
#ifdef __cpp_lib_print
    if (ShouldUseStderr(level)) {
      std::print(stderr, fmt, std::forward<Args>(args)...);
    } else {
      std::print(fmt, std::forward<Args>(args)...);
    }
#else
    if (ShouldUseStderr(level)) {
      std::cerr << std::format(fmt, std::forward<Args>(args)...);
    } else {
      std::cout << std::format(fmt, std::forward<Args>(args)...);
    }
#endif
  }

  /**
   * @brief Helper function to print pre-formatted text with automatic std::print/std::cout selection
   * @param level The log level to determine output stream
   * @param text The pre-formatted text to print
   */
  inline fn Print(const LogLevel level, const StringView text) {
#ifdef __cpp_lib_print
    if (ShouldUseStderr(level)) {
      std::print(stderr, "{}", text);
    } else {
      std::print("{}", text);
    }
#else
    if (ShouldUseStderr(level)) {
      std::cerr << text;
    } else {
      std::cout << text;
    }
#endif
  }

  /**
   * @brief Helper function to print formatted text with newline with automatic std::print/std::cout selection
   * @tparam Args Parameter pack for format arguments
   * @param level The log level to determine output stream
   * @param fmt The format string
   * @param args The arguments for the format string
   */
  template <typename... Args>
  inline fn Println(const LogLevel level, std::format_string<Args...> fmt, Args&&... args) {
#ifdef __cpp_lib_print
    if (ShouldUseStderr(level)) {
      std::println(stderr, fmt, std::forward<Args>(args)...);
    } else {
      std::println(fmt, std::forward<Args>(args)...);
    }
#else
    if (ShouldUseStderr(level)) {
      std::cerr << std::format(fmt, std::forward<Args>(args)...) << '\n';
    } else {
      std::cout << std::format(fmt, std::forward<Args>(args)...) << '\n';
    }
#endif
  }

  /**
   * @brief Helper function to print pre-formatted text with newline with automatic std::print/std::cout selection
   * @param level The log level to determine output stream
   * @param text The pre-formatted text to print
   */
  inline fn Println(const LogLevel level, const StringView text) {
#ifdef __cpp_lib_print
    if (ShouldUseStderr(level)) {
      std::println(stderr, "{}", text);
    } else {
      std::println("{}", text);
    }
#else
    if (ShouldUseStderr(level)) {
      std::cerr << text << '\n';
    } else {
      std::cout << text << '\n';
    }
#endif
  }

  /**
   * @brief Helper function to print just a newline with automatic std::print/std::cout selection
   * @param level The log level to determine output stream
   */
  inline fn Println(const LogLevel level) {
#ifdef __cpp_lib_print
    if (ShouldUseStderr(level)) {
      std::println(stderr);
    } else {
      std::println();
    }
#else
    if (ShouldUseStderr(level)) {
      std::cerr << '\n';
    } else {
      std::cout << '\n';
    }
#endif
  }

  // Backward compatibility overloads that default to stdout
  template <typename... Args>
  inline fn Print(std::format_string<Args...> fmt, Args&&... args) {
    Print(LogLevel::Info, fmt, std::forward<Args>(args)...);
  }

  inline fn Print(const StringView text) {
    Print(LogLevel::Info, text);
  }

  template <typename... Args>
  inline fn Println(std::format_string<Args...> fmt, Args&&... args) {
    Println(LogLevel::Info, fmt, std::forward<Args>(args)...);
  }

  inline fn Println(const StringView text) {
    Println(LogLevel::Info, text);
  }

  inline fn Println() {
    Println(LogLevel::Info);
  }

  /**
   * @brief Returns a HH:MM:SS timestamp string for the provided epoch time.
   *        The value is cached per-thread and only recomputed when the seconds
   *        value changes, greatly reducing the cost when many log calls land
   *        in the same second.
   * @param tt The epoch time (seconds since epoch).
   * @return StringView pointing to a thread-local null-terminated buffer.
   */
  inline fn GetCachedTimestamp(const std::time_t timeT) -> StringView {
    thread_local auto           LastTt   = static_cast<std::time_t>(-1);
    thread_local Array<char, 9> TsBuffer = { '\0' };

    if (timeT != LastTt) {
      std::tm localTm {};

#ifdef _WIN32
      if (localtime_s(&localTm, &timeT) == 0)
#else
      if (localtime_r(&timeT, &localTm) != nullptr)
#endif
      {
        if (std::strftime(TsBuffer.data(), TsBuffer.size(), LogLevelConst::TIMESTAMP_FORMAT, &localTm) == 0)
          std::copy_n("??:??:??", 9, TsBuffer.data());
      } else
        std::copy_n("??:??:??", 9, TsBuffer.data()); // fallback

      LastTt = timeT;
    }

    return { TsBuffer.data(), 8 };
  }

  /**
   * @brief Logs a message with the specified log level, source location, and format string.
   * @tparam Args Parameter pack for format arguments.
   * @param level The log level (DEBUG, INFO, WARN, ERROR).
   * @param loc The source location of the log message (only in Debug builds).
   * @param fmt The format string.
   * @param args The arguments for the format string.
   */
  template <typename... Args>
  fn LogImpl(
    const LogLevel level,
#ifndef NDEBUG
    const std::source_location& loc,
#endif
    std::format_string<Args...> fmt,
    Args&&... args
  ) {
    using namespace std::chrono;
    using std::filesystem::path;

    if (level < GetRuntimeLogLevel())
      return;

    const auto        nowTp = system_clock::now();
    const std::time_t nowTt = system_clock::to_time_t(nowTp);

    const StringView timestamp = GetCachedTimestamp(nowTt);

    const String message          = std::format(fmt, std::forward<Args>(args)...);
    const String coloredTimestamp = Colorize(std::format("[{}]", timestamp), DEBUG_INFO_COLOR);

#ifndef NDEBUG
    const String fileLine      = std::format(LogLevelConst::FILE_LINE_FORMAT, path(loc.file_name()).lexically_normal().string(), loc.line());
    const String fullDebugLine = std::format("{}{}", LogLevelConst::DEBUG_LINE_PREFIX, fileLine);
#endif

    {
      const LockGuard lock(GetLogMutex());

      Println(level, LogLevelConst::LOG_FORMAT, coloredTimestamp, GetLevelInfo().at(static_cast<usize>(level)), message);

#ifndef NDEBUG
      Print(level, Italic(Colorize(fullDebugLine, DEBUG_INFO_COLOR)));
      Println(level, LogLevelConst::RESET_CODE);
#else
      Print(level, LogLevelConst::RESET_CODE);
#endif
    }
  }

  template <typename ErrorType>
  fn LogError(const LogLevel level, const ErrorType& error_obj) {
    using DecayedErrorType = std::decay_t<ErrorType>;

#ifndef NDEBUG
    std::source_location logLocation;
#endif

    String errorMessagePart;

    if constexpr (std::is_same_v<DecayedErrorType, error::DracError>) {
#ifndef NDEBUG
      logLocation = error_obj.location;
#endif
      errorMessagePart = error_obj.message;
    } else {
#ifndef NDEBUG
      logLocation = std::source_location::current();
#endif
      if constexpr (std::is_base_of_v<std::exception, DecayedErrorType>)
        errorMessagePart = error_obj.what();
      else if constexpr (requires { error_obj.message; })
        errorMessagePart = error_obj.message;
      else
        errorMessagePart = "Unknown error type logged";
    }

#ifndef NDEBUG
    LogImpl(level, logLocation, "{}", errorMessagePart);
#else
    LogImpl(level, "{}", errorMessagePart);
#endif
  }

#define debug_at(error_obj) ::draconis::utils::logging::LogError(::draconis::utils::logging::LogLevel::Debug, error_obj)
#define info_at(error_obj)  ::draconis::utils::logging::LogError(::draconis::utils::logging::LogLevel::Info, error_obj)
#define warn_at(error_obj)  ::draconis::utils::logging::LogError(::draconis::utils::logging::LogLevel::Warn, error_obj)
#define error_at(error_obj) ::draconis::utils::logging::LogError(::draconis::utils::logging::LogLevel::Error, error_obj)

#ifdef NDEBUG
  #define debug_log(fmt, ...) ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Debug, fmt __VA_OPT__(, ) __VA_ARGS__)
  #define info_log(fmt, ...)  ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Info, fmt __VA_OPT__(, ) __VA_ARGS__)
  #define warn_log(fmt, ...)  ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Warn, fmt __VA_OPT__(, ) __VA_ARGS__)
  #define error_log(fmt, ...) ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Error, fmt __VA_OPT__(, ) __VA_ARGS__)
#else
  #define debug_log(fmt, ...) \
    ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Debug, std::source_location::current(), fmt __VA_OPT__(, ) __VA_ARGS__)
  #define info_log(fmt, ...) \
    ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Info, std::source_location::current(), fmt __VA_OPT__(, ) __VA_ARGS__)
  #define warn_log(fmt, ...) \
    ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Warn, std::source_location::current(), fmt __VA_OPT__(, ) __VA_ARGS__)
  #define error_log(fmt, ...) \
    ::draconis::utils::logging::LogImpl(::draconis::utils::logging::LogLevel::Error, std::source_location::current(), fmt __VA_OPT__(, ) __VA_ARGS__)
#endif
} // namespace draconis::utils::logging
</file>

<file path="src/CLI/Core/SystemInfo.hpp">
#pragma once

#include <glaze/glaze.hpp>

#include <Drac++/Core/System.hpp>

#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Types.hpp>

#include "Config/Config.hpp"

namespace draconis::core::system {
  namespace {
    using config::Config;

    using utils::types::CPUArch;
    using utils::types::Frequencies;
    using utils::types::MediaInfo;
    using utils::types::OSInfo;
    using utils::types::ResourceUsage;
    using utils::types::Result;
    using utils::types::String;
    using utils::types::u64;
    using utils::types::usize;

    using std::chrono::seconds;
  } // namespace

  /**
   * @brief Utility struct for storing system information.
   */
  struct SystemInfo {
    Result<String>        date;
    Result<String>        host;
    Result<String>        kernelVersion;
    Result<OSInfo>        operatingSystem;
    Result<ResourceUsage> memInfo;
    Result<String>        desktopEnv;
    Result<String>        windowMgr;
    Result<ResourceUsage> diskUsage;
    Result<String>        shell;
    Result<String>        cpuModel;
    Result<CPUCores>      cpuCores;
    Result<String>        gpuModel;
    Result<seconds>       uptime;
#if DRAC_ENABLE_PACKAGECOUNT
    Result<u64> packageCount;
#endif
#if DRAC_ENABLE_NOWPLAYING
    Result<MediaInfo> nowPlaying;
#endif

    explicit SystemInfo(utils::cache::CacheManager& cache, const Config& config);
  };

  struct JsonInfo {
    std::optional<String>        date;
    std::optional<String>        host;
    std::optional<String>        kernelVersion;
    std::optional<OSInfo>        operatingSystem;
    std::optional<ResourceUsage> memInfo;
    std::optional<String>        desktopEnv;
    std::optional<String>        windowMgr;
    std::optional<ResourceUsage> diskUsage;
    std::optional<String>        shell;
    std::optional<String>        cpuModel;
    std::optional<CPUCores>      cpuCores;
    std::optional<String>        gpuModel;
    std::optional<i64>           uptimeSeconds;
#if DRAC_ENABLE_PACKAGECOUNT
    std::optional<u64> packageCount;
#endif
#if DRAC_ENABLE_NOWPLAYING
    std::optional<MediaInfo> nowPlaying;
#endif
#if DRAC_ENABLE_WEATHER
    std::optional<services::weather::Report> weather;
#endif
  };

} // namespace draconis::core::system

namespace glz {
  template <>
  struct meta<draconis::utils::types::ResourceUsage> {
    using T = draconis::utils::types::ResourceUsage;

    static constexpr detail::Object value = object("usedBytes", &T::usedBytes, "totalBytes", &T::totalBytes);
  };

#if DRAC_ENABLE_NOWPLAYING
  template <>
  struct meta<draconis::utils::types::MediaInfo> {
    using T = draconis::utils::types::MediaInfo;

    static constexpr detail::Object value = object("title", &T::title, "artist", &T::artist);
  };
#endif

  template <>
  struct meta<draconis::core::system::JsonInfo> {
    using T = draconis::core::system::JsonInfo;

    // clang-format off
  static constexpr detail::Object value = object(
#if DRAC_ENABLE_PACKAGECOUNT
    "packageCount",    &T::packageCount,
#endif
#if DRAC_ENABLE_NOWPLAYING
    "nowPlaying",      &T::nowPlaying,
#endif
#if DRAC_ENABLE_WEATHER
    "weather",         &T::weather,
#endif
    "date",            &T::date,
    "host",            &T::host,
    "kernelVersion",   &T::kernelVersion,
    "operatingSystem", &T::operatingSystem,
    "memInfo",         &T::memInfo,
    "desktopEnv",      &T::desktopEnv,
    "windowMgr",       &T::windowMgr,
    "diskUsage",       &T::diskUsage,
    "shell",           &T::shell,
    "cpuModel",        &T::cpuModel,
    "cpuCores",        &T::cpuCores,
    "gpuModel",        &T::gpuModel,
    "uptimeSeconds",   &T::uptimeSeconds
  );
    // clang-format on
  };
} // namespace glz
</file>

<file path="flake.lock">
{
  "nodes": {
    "devkitNix": {
      "inputs": {
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1753062483,
        "narHash": "sha256-ZRur48eZ28sohy1TTi/B7frMw8ugtiDvFd0hYHUeSjU=",
        "owner": "bandithedoge",
        "repo": "devkitNix",
        "rev": "8f0f3c02412d6d46624b14148f99821629bafd69",
        "type": "github"
      },
      "original": {
        "owner": "bandithedoge",
        "repo": "devkitNix",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1752900028,
        "narHash": "sha256-dPALCtmik9Wr14MGqVXm+OQcv7vhPBXcWNIOThGnB/Q=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "6b4955211758ba47fac850c040a27f23b9b4008f",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1752900028,
        "narHash": "sha256-dPALCtmik9Wr14MGqVXm+OQcv7vhPBXcWNIOThGnB/Q=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "6b4955211758ba47fac850c040a27f23b9b4008f",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_3": {
      "locked": {
        "lastModified": 1747958103,
        "narHash": "sha256-qmmFCrfBwSHoWw7cVK4Aj+fns+c54EBP8cGqp/yK410=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "fe51d34885f7b5e3e7b59572796e1bcb427eccb1",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixpkgs-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "devkitNix": "devkitNix",
        "nixpkgs": "nixpkgs_2",
        "treefmt-nix": "treefmt-nix",
        "utils": "utils"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "systems_2": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "treefmt-nix": {
      "inputs": {
        "nixpkgs": "nixpkgs_3"
      },
      "locked": {
        "lastModified": 1753006367,
        "narHash": "sha256-tzbhc4XttkyEhswByk5R38l+ztN9UDbnj0cTcP6Hp9A=",
        "owner": "numtide",
        "repo": "treefmt-nix",
        "rev": "421b56313c65a0815a52b424777f55acf0b56ddf",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "treefmt-nix",
        "type": "github"
      }
    },
    "utils": {
      "inputs": {
        "systems": "systems_2"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="src/CLI/Config/Config.cpp">
#include "Config.hpp"

#include <Drac++/Utils/Logging.hpp>

#if !DRAC_PRECOMPILED_CONFIG
  #include <filesystem>                // std::filesystem::{path, operator/, exists, create_directories}
  #include <fstream>                   // std::{ifstream, ofstream, operator<<}
  #include <system_error>              // std::error_code
  #include <toml++/impl/node_view.hpp> // toml::node_view
  #include <toml++/impl/parser.hpp>    // toml::{parse_file, parse_result}
  #include <toml++/impl/table.hpp>     // toml::table

  #include <Drac++/Services/Packages.hpp>

  #include <Drac++/Utils/Env.hpp>
  #include <Drac++/Utils/Types.hpp>

namespace fs = std::filesystem;
#else
  #include <Drac++/Services/Weather.hpp>

  #include "../config.hpp" // user-defined config
#endif

#if !DRAC_PRECOMPILED_CONFIG
using namespace draconis::utils::types;
using draconis::utils::env::GetEnv;

namespace {
  fn GetConfigPath() -> fs::path {
    Vec<fs::path> possiblePaths;

  #ifdef _WIN32
    if (Result<String> result = GetEnv("LOCALAPPDATA"))
      possiblePaths.emplace_back(fs::path(*result) / "draconis++" / "config.toml");

    if (Result<String> result = GetEnv("USERPROFILE")) {
      possiblePaths.emplace_back(fs::path(*result) / ".config" / "draconis++" / "config.toml");
      possiblePaths.emplace_back(fs::path(*result) / "AppData" / "Local" / "draconis++" / "config.toml");
    }

    if (Result<String> result = GetEnv("APPDATA"))
      possiblePaths.emplace_back(fs::path(*result) / "draconis++" / "config.toml");
  #else
    if (Result<String> result = GetEnv("XDG_CONFIG_HOME"))
      possiblePaths.emplace_back(fs::path(*result) / "draconis++" / "config.toml");

    if (Result<String> result = GetEnv("HOME")) {
      possiblePaths.emplace_back(fs::path(*result) / ".config" / "draconis++" / "config.toml");
      possiblePaths.emplace_back(fs::path(*result) / ".draconis++" / "config.toml");
    }
  #endif

    possiblePaths.emplace_back(fs::path(".") / "config.toml");

    for (const fs::path& path : possiblePaths)
      if (std::error_code errc; fs::exists(path, errc) && !errc)
        return path;

    if (!possiblePaths.empty()) {
      const fs::path defaultDir = possiblePaths[0].parent_path();

      if (std::error_code errc; !fs::exists(defaultDir, errc) || errc) {
        create_directories(defaultDir, errc);
      }

      return possiblePaths[0];
    }

    warn_log("Could not determine a preferred config path. Falling back to './config.toml'");
    return fs::path(".") / "config.toml";
  }

  fn CreateDefaultConfig(const fs::path& configPath) -> bool {
    try {
      std::error_code errc;
      create_directories(configPath.parent_path(), errc);

      if (errc) {
        error_log("Failed to create config directory: {}", errc.message());
        return false;
      }

      const String defaultName   = draconis::config::General::getDefaultName();
      String       configContent = std::format(R"toml(# Draconis++ Configuration File

# General settings
[general]
name = "{}" # Your display name
)toml",
                                         defaultName);

  #if DRAC_ENABLE_NOWPLAYING
      configContent += R"toml(
# Now Playing integration
[now_playing]
enabled = true # Set to true to enable media integration
)toml";
  #endif

  #if DRAC_ENABLE_WEATHER
      configContent += R"toml(
# Weather settings
[weather]
enabled = false        # Set to true to enable weather display
show_town_name = false # Show location name in weather display
api_key = ""           # Your weather API key
units = "metric"       # Use "metric" for °C or "imperial" for °F
location = "London"    # Your city name

# Alternatively, you can specify coordinates instead of a city name:
# [weather.location]
# lat = 51.5074
# lon = -0.1278
)toml";
  #endif

  #if DRAC_ENABLE_PACKAGECOUNT
      configContent += R"toml(
# Package counting settings
[packages]
enabled = [] # List of package managers to count, e.g. ["cargo", "nix", "pacman"]

# Possible values depend on your OS: cargo, nix, apk, dpkg, moss, pacman, rpm, xbps, homebrew, macports, winget, chocolatey, scoop, pkgng, pkgsrc, haikupkg
# If you don't want to count any package managers, leave the list empty.
)toml";
  #endif

      std::ofstream file(configPath);
      file << configContent;

      info_log("Created default config file at {}", configPath.string());
      return true;
    } catch (const fs::filesystem_error& fsErr) {
      error_log("Filesystem error during default config creation: {}", fsErr.what());
      return false;
    } catch (const Exception& e) {
      error_log("Failed to create default config file: {}", e.what());
      return false;
    } catch (...) {
      error_log("An unexpected error occurred during default config creation.");
      return false;
    }
  }
} // namespace

#endif // !DRAC_PRECOMPILED_CONFIG

namespace draconis::config {
  fn Config::getInstance() -> Config {
#if DRAC_PRECOMPILED_CONFIG
    using namespace draconis::config;

    Config cfg;
    cfg.general.name = DRAC_USERNAME;

  #if DRAC_ENABLE_WEATHER
    using namespace draconis::services::weather;
    using enum draconis::services::weather::Provider;

    cfg.weather.enabled      = true;
    cfg.weather.apiKey       = DRAC_API_KEY;
    cfg.weather.showTownName = DRAC_SHOW_TOWN_NAME;
    cfg.weather.units        = DRAC_WEATHER_UNIT;
    cfg.weather.location     = DRAC_LOCATION;

    if constexpr (DRAC_WEATHER_PROVIDER == OpenWeatherMap) {
      if (!cfg.weather.apiKey) {
        error_log("OpenWeatherMap requires an API key.");
        cfg.weather.enabled = false;
      }

      cfg.weather.service = CreateWeatherService(
        OpenWeatherMap,
        DRAC_LOCATION,
        cfg.weather.units,
        cfg.weather.apiKey
      );
    } else if constexpr (DRAC_WEATHER_PROVIDER == OpenMeteo) {
      if (std::holds_alternative<Coords>(DRAC_LOCATION)) {
        const auto& coords = std::get<Coords>(DRAC_LOCATION);

        cfg.weather.service = CreateWeatherService(
          OpenMeteo,
          coords,
          cfg.weather.units
        );
      } else {
        error_log("Precompiled OpenMeteo requires coordinates, but DRAC_LOCATION is not Coords.");
        cfg.weather.enabled = false;
      }
    } else if constexpr (DRAC_WEATHER_PROVIDER == MetNo) {
      if (std::holds_alternative<Coords>(DRAC_LOCATION)) {
        const auto& coords = std::get<Coords>(DRAC_LOCATION);

        cfg.weather.service = CreateWeatherService(
          MetNo,
          coords,
          cfg.weather.units
        );
      } else {
        error_log("Precompiled MetNo requires coordinates, but DRAC_LOCATION is not Coords.");
        cfg.weather.enabled = false;
      }
    } else {
      error_log("Unknown precompiled weather provider specified in DRAC_WEATHER_PROVIDER.");
      cfg.weather.enabled = false;
    }

    if (cfg.weather.enabled && !cfg.weather.service) {
      error_log("Failed to initialize precompiled weather service for the configured provider.");
      cfg.weather.enabled = false;
    }
  #endif // DRAC_ENABLE_WEATHER

  #if DRAC_ENABLE_PACKAGECOUNT
    cfg.enabledPackageManagers = config::DRAC_ENABLED_PACKAGE_MANAGERS;
  #endif

  #if DRAC_ENABLE_NOWPLAYING
    cfg.nowPlaying.enabled = true;
  #endif

    debug_log("Using precompiled configuration.");
    return cfg;
#else
    try {
      const fs::path configPath = GetConfigPath();

      std::error_code errc;

      const bool exists = fs::exists(configPath, errc);

      if (!exists) {
        info_log("Config file not found at {}, creating defaults.", configPath.string());

        if (!CreateDefaultConfig(configPath))
          return {};
      }

      const toml::table parsedConfig = toml::parse_file(configPath.string());

      debug_log("Config loaded from {}", configPath.string());

      return Config(parsedConfig);
    } catch (const Exception& e) {
      debug_log("Config loading failed: {}, using defaults", e.what());
      return {};
    } catch (...) {
      error_log("An unexpected error occurred during config loading. Using in-memory defaults.");
      return {};
    }
#endif // DRAC_PRECOMPILED_CONFIG
  }

#if !DRAC_PRECOMPILED_CONFIG
  Config::Config(const toml::table& tbl) {
    const toml::node_view genTbl = tbl["general"];
    this->general                = genTbl.is_table() ? General::fromToml(*genTbl.as_table()) : General {};

    if (!this->general.name)
      this->general.name = General::getDefaultName();

  #if DRAC_ENABLE_NOWPLAYING
    const toml::node_view npTbl = tbl["now_playing"];
    this->nowPlaying            = npTbl.is_table() ? NowPlaying::fromToml(*npTbl.as_table()) : NowPlaying {};
  #endif

  #if DRAC_ENABLE_WEATHER
    const toml::node_view wthTbl = tbl["weather"];
    this->weather                = wthTbl.is_table() ? Weather::fromToml(*wthTbl.as_table()) : Weather {};
  #endif

  #if DRAC_ENABLE_PACKAGECOUNT
    const toml::node_view pkgTbl = tbl["packages"];

    if (pkgTbl.is_table()) {
      const auto enabledNode = pkgTbl["enabled"];

      if (enabledNode.is_array()) {
        using enum draconis::services::packages::Manager;

        this->enabledPackageManagers = NONE;

        for (const auto& elem : *enabledNode.as_array()) {
          if (auto valOpt = elem.value<String>()) {
            String val = *valOpt;

            if (val == "cargo")
              this->enabledPackageManagers |= CARGO;
    #if defined(__linux__) || defined(__APPLE__)
            else if (val == "nix")
              this->enabledPackageManagers |= NIX;
    #endif
    #ifdef __linux__
            else if (val == "apk")
              this->enabledPackageManagers |= APK;
            else if (val == "dpkg")
              this->enabledPackageManagers |= DPKG;
            else if (val == "moss")
              this->enabledPackageManagers |= MOSS;
            else if (val == "pacman")
              this->enabledPackageManagers |= PACMAN;
            else if (val == "rpm")
              this->enabledPackageManagers |= RPM;
            else if (val == "xbps")
              this->enabledPackageManagers |= XBPS;
    #endif
    #ifdef __APPLE__
            else if (val == "homebrew")
              this->enabledPackageManagers |= HOMEBREW;
            else if (val == "macports")
              this->enabledPackageManagers |= MACPORTS;
    #endif
    #ifdef _WIN32
            else if (val == "winget")
              this->enabledPackageManagers |= WINGET;
            else if (val == "chocolatey")
              this->enabledPackageManagers |= CHOCOLATEY;
            else if (val == "scoop")
              this->enabledPackageManagers |= SCOOP;
    #endif
    #if defined(__FreeBSD__) || defined(__DragonFly__)
            else if (val == "pkgng")
              this->enabledPackageManagers |= PKGNG;
    #endif
    #ifdef __NetBSD__
            else if (val == "pkgsrc")
              this->enabledPackageManagers |= PKGSRC;
    #endif
    #ifdef __HAIKU__
            else if (val == "haikupkg")
              this->enabledPackageManagers |= HAIKUPKG;
    #endif
            else
              warn_log("Unknown package manager in config: {}", val);
          }
        }
      }
    }
  #endif
  }
#endif
} // namespace draconis::config
</file>

<file path="examples/vulkan_app/main.cpp">
#include <algorithm> // std::{clamp, ranges::find_if}
#include <chrono>    // std::chrono::{duration_cast, seconds, steady_clock, time_point}

#include <Drac++/Core/System.hpp>
#include <Drac++/Services/Packages.hpp>

#include <Drac++/Utils/CacheManager.hpp>
#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_vulkan.h"

#define VULKAN_HPP_NO_EXCEPTIONS
#define VULKAN_HPP_DISPATCH_LOADER_DYNAMIC 1
#include <vulkan/vulkan.hpp>

// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE

using namespace draconis::utils::types;
using enum draconis::utils::error::DracErrorCode;

namespace {
  fn cleanupSwapChain(const vk::Device device, Vec<vk::ImageView>& swapChainImageViews, const vk::CommandPool commandPool, Vec<vk::CommandBuffer>& commandBuffers) -> Unit {
    if (!commandBuffers.empty()) {
      device.freeCommandBuffers(commandPool, commandBuffers);
      commandBuffers.clear();
    }

    for (vk::ImageView imageView : swapChainImageViews)
      if (imageView)
        device.destroyImageView(imageView);

    swapChainImageViews.clear();
  }

  fn recreateSwapChain(GLFWwindow* window, vk::Device device, vk::PhysicalDevice physicalDevice, vk::SurfaceKHR surface, vk::SwapchainKHR& swapChain, Vec<vk::Image>& swapChainImages, vk::SurfaceFormatKHR& surfaceFormat, vk::Extent2D& swapChainExtent, Vec<vk::ImageView>& swapChainImageViews, vk::CommandPool commandPool, Vec<vk::CommandBuffer>& commandBuffers, vk::PresentModeKHR& presentMode) -> Result<> {
    i32 width = 0, height = 0;
    glfwGetFramebufferSize(window, &width, &height);

    while (width == 0 || height == 0) {
      glfwGetFramebufferSize(window, &width, &height);
      glfwWaitEvents();
    }

    info_log("Recreating swapchain with dimensions: {}x{}", width, height);

    if (device.waitIdle() != vk::Result::eSuccess)
      ERR(Other, "failed to wait for device idle before recreation!");

    vk::SwapchainKHR oldSwapChain = swapChain;
    swapChain                     = VK_NULL_HANDLE;

    if (oldSwapChain)
      cleanupSwapChain(device, swapChainImageViews, commandPool, commandBuffers);

    swapChainImages.clear();

    vk::ResultValue<vk::SurfaceCapabilitiesKHR> capabilitiesResult = physicalDevice.getSurfaceCapabilitiesKHR(surface);
    if (capabilitiesResult.result != vk::Result::eSuccess)
      ERR(Other, "failed to get surface capabilities");

    vk::SurfaceCapabilitiesKHR capabilities = capabilitiesResult.value;

    info_log("Surface capabilities - min: {}x{}, max: {}x{}, current: {}x{}", capabilities.minImageExtent.width, capabilities.minImageExtent.height, capabilities.maxImageExtent.width, capabilities.maxImageExtent.height, capabilities.currentExtent.width, capabilities.currentExtent.height);

    {
      using matchit::match, matchit::is, matchit::_;

      // clang-format off
      swapChainExtent = match(capabilities.currentExtent.width)(
        is | std::numeric_limits<u32>::max() = vk::Extent2D {
          std::clamp(static_cast<u32>(width), capabilities.minImageExtent.width, capabilities.maxImageExtent.width),
          std::clamp(static_cast<u32>(height), capabilities.minImageExtent.height, capabilities.maxImageExtent.height)
        },
        is | _ = capabilities.currentExtent
      );
      // clang-format on
    }

    info_log("Using swapchain extent: {}x{}", swapChainExtent.width, swapChainExtent.height);

    vk::ResultValue<Vec<vk::SurfaceFormatKHR>> formatsResult = physicalDevice.getSurfaceFormatsKHR(surface);
    if (formatsResult.result != vk::Result::eSuccess)
      ERR(Other, "failed to get surface formats");

    surfaceFormat = formatsResult.value[0];

    vk::ResultValue<Vec<vk::PresentModeKHR>> presentModesResult = physicalDevice.getSurfacePresentModesKHR(surface);
    if (presentModesResult.result != vk::Result::eSuccess)
      ERR(Other, "failed to get surface present modes");

    presentMode = vk::PresentModeKHR::eFifo;
    for (const vk::PresentModeKHR& availablePresentMode : presentModesResult.value) {
      if (availablePresentMode == vk::PresentModeKHR::eMailbox) {
        presentMode = availablePresentMode;
        break;
      }
    }

    u32 imageCount = capabilities.minImageCount + 1;
    if (capabilities.maxImageCount > 0 && imageCount > capabilities.maxImageCount)
      imageCount = capabilities.maxImageCount;

    info_log("Using {} swapchain images", imageCount);

    vk::SwapchainCreateInfoKHR createInfo;
    createInfo.sType            = vk::StructureType::eSwapchainCreateInfoKHR;
    createInfo.surface          = surface;
    createInfo.minImageCount    = imageCount;
    createInfo.imageFormat      = surfaceFormat.format;
    createInfo.imageColorSpace  = surfaceFormat.colorSpace;
    createInfo.imageExtent      = swapChainExtent;
    createInfo.imageArrayLayers = 1;
    createInfo.imageUsage       = vk::ImageUsageFlagBits::eColorAttachment;
    createInfo.imageSharingMode = vk::SharingMode::eExclusive;
    createInfo.preTransform     = capabilities.currentTransform;
    createInfo.compositeAlpha   = vk::CompositeAlphaFlagBitsKHR::eOpaque;
    createInfo.presentMode      = presentMode;
    createInfo.clipped          = VK_TRUE;
    createInfo.oldSwapchain     = oldSwapChain;

    vk::ResultValue<vk::SwapchainKHR> swapChainResult = device.createSwapchainKHR(createInfo);
    if (swapChainResult.result != vk::Result::eSuccess)
      ERR(Other, "failed to create swapchain!");

    swapChain = swapChainResult.value;

    vk::ResultValue<Vec<vk::Image>> imagesResult = device.getSwapchainImagesKHR(swapChain);
    if (imagesResult.result != vk::Result::eSuccess)
      ERR(Other, "failed to get swapchain images!");

    swapChainImages = imagesResult.value;

    info_log("Created {} swapchain images", swapChainImages.size());

    swapChainImageViews.resize(swapChainImages.size());
    for (size_t i = 0; i < swapChainImages.size(); i++) {
      vk::ImageViewCreateInfo imageViewCreateInfo;
      imageViewCreateInfo.sType                           = vk::StructureType::eImageViewCreateInfo;
      imageViewCreateInfo.image                           = swapChainImages[i];
      imageViewCreateInfo.viewType                        = vk::ImageViewType::e2D;
      imageViewCreateInfo.format                          = surfaceFormat.format;
      imageViewCreateInfo.components.r                    = vk::ComponentSwizzle::eIdentity;
      imageViewCreateInfo.components.g                    = vk::ComponentSwizzle::eIdentity;
      imageViewCreateInfo.components.b                    = vk::ComponentSwizzle::eIdentity;
      imageViewCreateInfo.components.a                    = vk::ComponentSwizzle::eIdentity;
      imageViewCreateInfo.subresourceRange.aspectMask     = vk::ImageAspectFlagBits::eColor;
      imageViewCreateInfo.subresourceRange.baseMipLevel   = 0;
      imageViewCreateInfo.subresourceRange.levelCount     = 1;
      imageViewCreateInfo.subresourceRange.baseArrayLayer = 0;
      imageViewCreateInfo.subresourceRange.layerCount     = 1;

      vk::ResultValue<vk::ImageView> imageViewResult = device.createImageView(imageViewCreateInfo);
      if (imageViewResult.result != vk::Result::eSuccess)
        ERR(Other, "failed to create image views!");

      swapChainImageViews[i] = imageViewResult.value;
    }

    vk::ResultValue<Vec<vk::CommandBuffer>> buffersResult = device.allocateCommandBuffers({ commandPool, vk::CommandBufferLevel::ePrimary, static_cast<u32>(swapChainImageViews.size()) });
    if (buffersResult.result != vk::Result::eSuccess)
      ERR(Other, "failed to allocate command buffers!");

    commandBuffers = buffersResult.value;

    info_log("Successfully recreated swapchain");

    return {};
  }
} // namespace

fn main() -> i32 {
  static vk::detail::DynamicLoader Loader;

  VULKAN_HPP_DEFAULT_DISPATCHER.init(Loader.getProcAddress<PFN_vkGetInstanceProcAddr>("vkGetInstanceProcAddr"));

  if (!glfwInit()) {
    error_log("Failed to initialize GLFW");
    return EXIT_FAILURE;
  }

  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  GLFWwindow* window = glfwCreateWindow(1280, 720, "Vulkan Example", nullptr, nullptr);

  if (!window) {
    error_log("Failed to create GLFW window");
    glfwTerminate();
    return EXIT_FAILURE;
  }

  bool framebufferWasResized = false;

  glfwSetWindowUserPointer(window, &framebufferWasResized);

  glfwSetFramebufferSizeCallback(window, [](GLFWwindow* windowInner, i32, i32) {
    bool* framebufferWasResizedInner = static_cast<bool*>(glfwGetWindowUserPointer(windowInner));
    *framebufferWasResizedInner      = true;
  });

  vk::ApplicationInfo appInfo("Vulkan Example", 1, "Draconis++ Example", 1, VK_API_VERSION_1_3);

  u32    glfwExtensionCount = 0;
  PCStr* glfwExtensions     = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

  Vec<PCStr> extensions;
  extensions.reserve(glfwExtensionCount);
  for (Span<PCStr> glfwExts(glfwExtensions, glfwExtensionCount); PCStr ext : glfwExts)
    extensions.push_back(ext);

#ifdef __APPLE__
  extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
#endif

  vk::InstanceCreateInfo createInfo;
  createInfo.pApplicationInfo = &appInfo;
#ifdef __APPLE__
  createInfo.flags = vk::InstanceCreateFlagBits::eEnumeratePortabilityKHR;
#endif
  createInfo.enabledExtensionCount   = static_cast<uint32_t>(extensions.size());
  createInfo.ppEnabledExtensionNames = extensions.data();

  vk::ResultValue<vk::Instance> instanceResult = vk::createInstance(createInfo);

  if (instanceResult.result != vk::Result::eSuccess) {
    error_log("Failed to create Vulkan instance: {}", vk::to_string(instanceResult.result));
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  vk::Instance instance = instanceResult.value;

  VULKAN_HPP_DEFAULT_DISPATCHER.init(instance);

  info_log("Vulkan instance created.");

  vk::SurfaceKHR surface;

  // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
  if (glfwCreateWindowSurface(instance, window, nullptr, reinterpret_cast<VkSurfaceKHR*>(&surface)) != VK_SUCCESS) {
    error_log("Failed to create window surface!");
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  vk::ResultValue<Vec<vk::PhysicalDevice>> physicalDevicesResult = instance.enumeratePhysicalDevices();
  if (physicalDevicesResult.result != vk::Result::eSuccess) {
    error_log("Failed to find GPUs with Vulkan support!");
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  vk::PhysicalDevice physicalDevice = physicalDevicesResult.value.front();

  Vec<vk::QueueFamilyProperties> queueFamilyProperties = physicalDevice.getQueueFamilyProperties();

  const auto graphicsQueueFamilyIndex = std::ranges::distance(queueFamilyProperties.begin(), std::ranges::find_if(queueFamilyProperties, [](const vk::QueueFamilyProperties& qfp) {
                                                                return static_cast<bool>(qfp.queueFlags & vk::QueueFlagBits::eGraphics);
                                                              }));

  f32 queuePriority = 1.0F;

  vk::DeviceQueueCreateInfo deviceQueueCreateInfo(vk::DeviceQueueCreateFlags(), static_cast<u32>(graphicsQueueFamilyIndex), 1, &queuePriority);

  const Vec<PCStr> deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME,
    VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME
  };

  vk::DeviceCreateInfo deviceCreateInfo(vk::DeviceCreateFlags(), deviceQueueCreateInfo);
  deviceCreateInfo.enabledExtensionCount   = static_cast<u32>(deviceExtensions.size());
  deviceCreateInfo.ppEnabledExtensionNames = deviceExtensions.data();

  vk::PhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeature;
  dynamicRenderingFeature.dynamicRendering = VK_TRUE;
  deviceCreateInfo.pNext                   = &dynamicRenderingFeature;

  vk::ResultValue<vk::Device> deviceResult = physicalDevice.createDevice(deviceCreateInfo);

  if (deviceResult.result != vk::Result::eSuccess) {
    error_log("Failed to create logical device!");
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  vk::Device device = deviceResult.value;
  VULKAN_HPP_DEFAULT_DISPATCHER.init(device);

  vk::SwapchainKHR     swapChain;
  Vec<vk::Image>       swapChainImages;
  vk::SurfaceFormatKHR surfaceFormat;
  vk::Extent2D         swapChainExtent;
  Vec<vk::ImageView>   swapChainImageViews;
  vk::PresentModeKHR   presentMode = vk::PresentModeKHR::eFifo;

  vk::ResultValue<vk::CommandPool> poolResult = device.createCommandPool({ {}, static_cast<u32>(graphicsQueueFamilyIndex) });

  if (poolResult.result != vk::Result::eSuccess) {
    error_log("Failed to create command pool!");
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  vk::CommandPool commandPool = poolResult.value;

  Vec<vk::CommandBuffer> commandBuffers;

  if (Result<> result = recreateSwapChain(window, device, physicalDevice, surface, swapChain, swapChainImages, surfaceFormat, swapChainExtent, swapChainImageViews, commandPool, commandBuffers, presentMode); !result) {
    error_log("Failed to recreate swap chain! {}", result.error().message);
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  vk::Queue graphicsQueue = device.getQueue(static_cast<u32>(graphicsQueueFamilyIndex), 0);

  IMGUI_CHECKVERSION();
  ImGui::CreateContext();
  ImGui::StyleColorsDark();

  ImGui_ImplGlfw_InitForVulkan(window, true);
  ImGui_ImplVulkan_InitInfo initInfo = {};
  initInfo.Instance                  = static_cast<VkInstance>(instance);
  initInfo.PhysicalDevice            = static_cast<VkPhysicalDevice>(physicalDevice);
  initInfo.Device                    = static_cast<VkDevice>(device);
  initInfo.QueueFamily               = static_cast<u32>(graphicsQueueFamilyIndex);
  initInfo.Queue                     = static_cast<VkQueue>(graphicsQueue);
  initInfo.PipelineCache             = VK_NULL_HANDLE;
  initInfo.UseDynamicRendering       = VK_TRUE;
  initInfo.Allocator                 = nullptr;
  initInfo.MinImageCount             = 2;
  initInfo.ImageCount                = static_cast<u32>(swapChainImages.size());
  initInfo.CheckVkResultFn           = nullptr;

  vk::PipelineRenderingCreateInfoKHR pipelineRenderingCreateInfo = {};
  pipelineRenderingCreateInfo.sType                              = vk::StructureType::ePipelineRenderingCreateInfoKHR;
  pipelineRenderingCreateInfo.colorAttachmentCount               = 1;
  pipelineRenderingCreateInfo.pColorAttachmentFormats            = &surfaceFormat.format;
  initInfo.PipelineRenderingCreateInfo                           = pipelineRenderingCreateInfo;

  // clang-format off
  Array<vk::DescriptorPoolSize, 11> poolSizes = {{
    { vk::DescriptorType::eCombinedImageSampler, 1000 },
    { vk::DescriptorType::eInputAttachment, 1000 },
    { vk::DescriptorType::eSampledImage, 1000 },
    { vk::DescriptorType::eSampler, 1000 },
    { vk::DescriptorType::eStorageBuffer, 1000 },
    { vk::DescriptorType::eStorageBufferDynamic, 1000 },
    { vk::DescriptorType::eStorageImage, 1000 },
    { vk::DescriptorType::eStorageTexelBuffer, 1000 },
    { vk::DescriptorType::eUniformBuffer, 1000 },
    { vk::DescriptorType::eUniformBufferDynamic, 1000 },
    { vk::DescriptorType::eUniformTexelBuffer, 1000 },
  }};
  // clang-format on

  vk::DescriptorPoolCreateInfo poolInfo = {};
  poolInfo.flags                        = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet;
  poolInfo.maxSets                      = 1000 * poolSizes.size();
  poolInfo.poolSizeCount                = static_cast<u32>(poolSizes.size());
  poolInfo.pPoolSizes                   = poolSizes.data();

  vk::ResultValue<vk::DescriptorPool> imguiPoolResult = device.createDescriptorPool(poolInfo);
  if (imguiPoolResult.result != vk::Result::eSuccess) {
    error_log("Failed to create imgui descriptor pool!");
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  initInfo.DescriptorPool = imguiPoolResult.value;

  ImGui_ImplVulkan_LoadFunctions([](const PCStr function_name, void* vulkan_instance) {
    return VULKAN_HPP_DEFAULT_DISPATCHER.vkGetInstanceProcAddr(static_cast<VkInstance>(vulkan_instance), function_name);
  });

  ImGui_ImplVulkan_Init(&initInfo);
  ImGui_ImplVulkan_CreateFontsTexture();

  std::chrono::time_point lastUpdateTime = std::chrono::steady_clock::now();
  Result<String>          host;
  Result<String>          kernelVersion;
  Result<OSInfo>          osInfo;
  Result<String>          cpuModel;
  Result<String>          gpuModel;
  Result<ResourceUsage>   memInfo;
  Result<String>          desktopEnv;
  Result<String>          windowMgr;
  Result<ResourceUsage>   diskUsage;
  Result<String>          shell;
#if DRAC_ENABLE_PACKAGECOUNT
  Result<u64> packageCount;
#endif
#if DRAC_ENABLE_NOWPLAYING
  Result<MediaInfo> nowPlaying;
#endif

  draconis::utils::cache::CacheManager cacheManager;

  while (!glfwWindowShouldClose(window)) {
    glfwPollEvents();

    if (const std::chrono::time_point now = std::chrono::steady_clock::now();
        std::chrono::duration_cast<std::chrono::seconds>(now - lastUpdateTime).count() >= 1) {
      using namespace draconis::core::system;
      using namespace draconis::services::packages;

      host          = GetHost(cacheManager);
      kernelVersion = GetKernelVersion(cacheManager);
      osInfo        = GetOperatingSystem(cacheManager);
      cpuModel      = GetCPUModel(cacheManager);
      gpuModel      = GetGPUModel(cacheManager);
      memInfo       = GetMemInfo(cacheManager);
      desktopEnv    = GetDesktopEnvironment(cacheManager);
      windowMgr     = GetWindowManager(cacheManager);
      diskUsage     = GetDiskUsage(cacheManager);
      shell         = GetShell(cacheManager);
#if DRAC_ENABLE_PACKAGECOUNT
      packageCount = GetTotalCount(cacheManager, Manager::CARGO);
#endif
#if DRAC_ENABLE_NOWPLAYING
      nowPlaying = GetNowPlaying();
#endif
      lastUpdateTime = now;
    }

    if (framebufferWasResized) {
      if (Result<> result = recreateSwapChain(
            window,
            device,
            physicalDevice,
            surface,
            swapChain,
            swapChainImages,
            surfaceFormat,
            swapChainExtent,
            swapChainImageViews,
            commandPool,
            commandBuffers,
            presentMode
          );
          !result) {
        error_log("Failed to recreate swap chain! {}", result.error().message);
        glfwDestroyWindow(window);
        glfwTerminate();
        return EXIT_FAILURE;
      }
      framebufferWasResized = false;
    }

    ImGui_ImplVulkan_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();
    ImGui::Begin("Draconis++");
    {
      ImGui::TextUnformatted(std::format("Host: {}", host.value_or("N/A")).c_str());
      ImGui::TextUnformatted(std::format("Kernel: {}", kernelVersion.value_or("N/A")).c_str());

      if (osInfo)
        ImGui::TextUnformatted(std::format("OS: {} {}", osInfo->name, osInfo->version).c_str());
      else
        ImGui::TextUnformatted("OS: N/A");

      ImGui::TextUnformatted(std::format("CPU: {}", cpuModel.value_or("N/A")).c_str());
      ImGui::TextUnformatted(std::format("GPU: {}", gpuModel.value_or("N/A")).c_str());

      if (memInfo)
        ImGui::TextUnformatted(std::format("Memory: {} / {}", BytesToGiB(memInfo->usedBytes), BytesToGiB(memInfo->totalBytes)).c_str());
      else
        ImGui::TextUnformatted("Memory: N/A");

      ImGui::TextUnformatted(std::format("DE: {}", desktopEnv.value_or("N/A")).c_str());
      ImGui::TextUnformatted(std::format("WM: {}", windowMgr.value_or("N/A")).c_str());

      if (diskUsage)
        ImGui::TextUnformatted(std::format("Disk: {} / {}", BytesToGiB(diskUsage->usedBytes), BytesToGiB(diskUsage->totalBytes)).c_str());
      else
        ImGui::TextUnformatted("Disk: N/A");

      ImGui::TextUnformatted(std::format("Shell: {}", shell.value_or("N/A")).c_str());

#if DRAC_ENABLE_PACKAGECOUNT
      ImGui::TextUnformatted(std::format("Packages: {}", packageCount.value_or(0)).c_str());
#endif

#if DRAC_ENABLE_NOWPLAYING
      if (nowPlaying) {
        const MediaInfo& nowPlayingInfo = *nowPlaying;
        ImGui::TextUnformatted(std::format("Now Playing: {} - {}", nowPlayingInfo.artist.value_or("N/A"), nowPlayingInfo.title.value_or("N/A")).c_str());
      } else
        ImGui::TextUnformatted("Now Playing: N/A");
#endif
    }
    ImGui::End();

    ImGui::Begin("Vulkan & GLFW Info");
    {
      ImGui::TextUnformatted(std::format("FPS: {:.1f}", ImGui::GetIO().Framerate).c_str());
      ImGui::Separator();
      const vk::PhysicalDeviceProperties props = physicalDevice.getProperties();
      ImGui::TextUnformatted(std::format("GLFW Version: {}", glfwGetVersionString()).c_str());
      ImGui::Separator();
      ImGui::TextUnformatted(std::format("Vulkan API Version: {}.{}.{}", VK_API_VERSION_MAJOR(props.apiVersion), VK_API_VERSION_MINOR(props.apiVersion), VK_API_VERSION_PATCH(props.apiVersion)).c_str());
      ImGui::TextUnformatted(std::format("Device: {}", props.deviceName.data()).c_str());
      ImGui::TextUnformatted(std::format("Driver Version: {}", props.driverVersion).c_str());
      ImGui::Separator();
      ImGui::TextUnformatted(std::format("Swapchain Extent: {}x{}", swapChainExtent.width, swapChainExtent.height).c_str());
      ImGui::TextUnformatted(std::format("Swapchain Images: {}", swapChainImages.size()).c_str());
      ImGui::TextUnformatted(std::format("Surface Format: {}", vk::to_string(surfaceFormat.format)).c_str());
      ImGui::TextUnformatted(std::format("Color Space: {}", vk::to_string(surfaceFormat.colorSpace)).c_str());
      ImGui::TextUnformatted(std::format("Present Mode: {}", vk::to_string(presentMode)).c_str());
    }
    ImGui::End();

    ImGui::Render();

    vk::ResultValue<u32> acquireResult = device.acquireNextImageKHR(swapChain, std::numeric_limits<u64>::max(), VK_NULL_HANDLE, VK_NULL_HANDLE);

    if (acquireResult.result == vk::Result::eErrorOutOfDateKHR) {
      if (Result<> result = recreateSwapChain(
            window,
            device,
            physicalDevice,
            surface,
            swapChain,
            swapChainImages,
            surfaceFormat,
            swapChainExtent,
            swapChainImageViews,
            commandPool,
            commandBuffers,
            presentMode
          );
          !result) {
        error_log("Failed to recreate swap chain! {}", result.error().message);
        glfwDestroyWindow(window);
        glfwTerminate();
        return EXIT_FAILURE;
      }
      continue;
    }

    if (acquireResult.result != vk::Result::eSuccess && acquireResult.result != vk::Result::eSuboptimalKHR) {
      error_log("Failed to acquire swap chain image!");
      glfwDestroyWindow(window);
      glfwTerminate();
      return EXIT_FAILURE;
    }

    u32 imageIndex = acquireResult.value;

    if (commandBuffers[imageIndex].begin(vk::CommandBufferBeginInfo()) != vk::Result::eSuccess) {
      error_log("Failed to begin command buffer!");
      glfwDestroyWindow(window);
      glfwTerminate();
      return EXIT_FAILURE;
    }

    vk::ClearValue clearColor(std::array<float, 4> { 0.1F, 0.1F, 0.1F, 1.0F });

    vk::RenderingAttachmentInfo colorAttachment;
    colorAttachment.imageView   = swapChainImageViews[imageIndex];
    colorAttachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
    colorAttachment.loadOp      = vk::AttachmentLoadOp::eClear;
    colorAttachment.storeOp     = vk::AttachmentStoreOp::eStore;
    colorAttachment.clearValue  = clearColor;

    vk::RenderingInfo renderingInfo;
    renderingInfo.renderArea           = vk::Rect2D({ 0, 0 }, swapChainExtent);
    renderingInfo.layerCount           = 1;
    renderingInfo.colorAttachmentCount = 1;
    renderingInfo.pColorAttachments    = &colorAttachment;

    commandBuffers[imageIndex].beginRendering(renderingInfo);
    ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), commandBuffers[imageIndex]);
    commandBuffers[imageIndex].endRendering();

    if (commandBuffers[imageIndex].end() != vk::Result::eSuccess) {
      error_log("Failed to end command buffer!");
      glfwDestroyWindow(window);
      glfwTerminate();
      return EXIT_FAILURE;
    }

    vk::SubmitInfo submitInfo(0, nullptr, nullptr, 1, &commandBuffers[imageIndex]);
    if (vk::Result submitResult = graphicsQueue.submit(submitInfo, nullptr); submitResult != vk::Result::eSuccess) {
      error_log("Failed to submit draw command buffer!");
      glfwDestroyWindow(window);
      glfwTerminate();
      return EXIT_FAILURE;
    }

    vk::PresentInfoKHR presentInfo;
    presentInfo.sType          = vk::StructureType::ePresentInfoKHR;
    presentInfo.swapchainCount = 1;
    presentInfo.pSwapchains    = &swapChain;
    presentInfo.pImageIndices  = &imageIndex;

    if (vk::Result presentResult = graphicsQueue.presentKHR(presentInfo); presentResult == vk::Result::eErrorOutOfDateKHR || presentResult == vk::Result::eSuboptimalKHR) {
      if (Result<> result = recreateSwapChain(
            window,
            device,
            physicalDevice,
            surface,
            swapChain,
            swapChainImages,
            surfaceFormat,
            swapChainExtent,
            swapChainImageViews,
            commandPool,
            commandBuffers,
            presentMode
          );
          !result) {
        error_log("Failed to recreate swap chain! {}", result.error().message);
        glfwDestroyWindow(window);
        glfwTerminate();
        return EXIT_FAILURE;
      }
    } else if (presentResult != vk::Result::eSuccess) {
      error_log("Unexpected present result: {}", vk::to_string(presentResult));
      glfwDestroyWindow(window);
      glfwTerminate();
      return EXIT_FAILURE;
    }

    if (graphicsQueue.waitIdle() != vk::Result::eSuccess) {
      error_log("Failed to wait for graphics queue idle!");
      glfwDestroyWindow(window);
      glfwTerminate();
      return EXIT_FAILURE;
    }
  }

  if (device.waitIdle() != vk::Result::eSuccess) {
    error_log("Failed to wait for device idle!");
    glfwDestroyWindow(window);
    glfwTerminate();
    return EXIT_FAILURE;
  }

  ImGui_ImplVulkan_Shutdown();
  ImGui_ImplGlfw_Shutdown();
  ImGui::DestroyContext();

  cleanupSwapChain(device, swapChainImageViews, commandPool, commandBuffers);
  device.destroyDescriptorPool(imguiPoolResult.value);
  device.freeCommandBuffers(commandPool, commandBuffers);
  device.destroyCommandPool(commandPool);
  device.destroy();
  instance.destroySurfaceKHR(surface);
  instance.destroy();

  glfwDestroyWindow(window);
  glfwTerminate();

  return EXIT_SUCCESS;
}
</file>

<file path="nix/module.nix">
{self}: {
  config,
  lib,
  pkgs,
  ...
}:
with lib; let
  cfg = config.programs.draconisplusplus;

  tomlFormat = pkgs.formats.toml {};

  defaultPackage = self.packages.${pkgs.system}.default;

  apiKey =
    if cfg.weatherApiKey == null
    then "std::nullopt"
    else cfg.weatherApiKey;

  location =
    if isAttrs cfg.location
    then
      # cpp
      "services::weather::Coords { .lat = ${toString cfg.location.lat}, .lon = ${toString cfg.location.lon} }"
    else "${cfg.location}";

  configHpp =
    pkgs.writeText "config.hpp"
    # cpp
    ''
      #pragma once

      #if DRAC_PRECOMPILED_CONFIG

      #if DRAC_ENABLE_WEATHER
        #include <Drac++/Services/Weather.hpp>
      #endif

      #if DRAC_ENABLE_PACKAGECOUNT
        #include <Drac++/Services/Packages.hpp>
      #endif

      namespace draconis::config {
        constexpr const char* DRAC_USERNAME = "${cfg.username}";

        #if DRAC_ENABLE_WEATHER
        constexpr services::weather::Provider DRAC_WEATHER_PROVIDER = services::weather::Provider::${cfg.weatherProvider};
        constexpr services::weather::UnitSystem DRAC_WEATHER_UNIT = services::weather::UnitSystem::${cfg.weatherUnit};
        constexpr bool DRAC_SHOW_TOWN_NAME = ${toString cfg.showTownName};
        constexpr std::optional<std::string> DRAC_API_KEY = ${apiKey};
        constexpr services::weather::Location DRAC_LOCATION = ${location};
        #endif

        #if DRAC_ENABLE_PACKAGECOUNT
        constexpr services::packages::Manager DRAC_ENABLED_PACKAGE_MANAGERS = ${builtins.concatStringsSep " | " (map (pkg: "services::packages::Manager::" + lib.toUpper pkg) cfg.packageManagers)};
        #endif
      }

      #endif
    '';

  draconisWithOverrides = cfg.package.overrideAttrs (oldAttrs: {
    postPatch = ''
      cp ${configHpp} ./config.hpp
    '';

    mesonFlags =
      (oldAttrs.mesonFlags or [])
      ++ [
        (lib.optionalString (cfg.configFormat == "hpp") "-Dprecompiled_config=true")
        (lib.optionalString cfg.usePugixml "-Dpugixml=enabled")
        (lib.optionalString cfg.enableNowPlaying "-Dnowplaying=enabled")
        (lib.optionalString cfg.enableWeather "-Dweather=enabled")
        (lib.optionalString cfg.enablePackageCount "-Dpackagecount=enabled")
        (lib.optionalString cfg.enableCaching "-Dcaching=enabled")
      ];
  });

  draconisPkg = draconisWithOverrides;
in {
  options.programs.draconisplusplus = {
    enable = mkEnableOption "draconis++";

    package = mkOption {
      type = types.package;
      default = defaultPackage;
      description = "The base draconis++ package.";
    };

    configFormat = mkOption {
      type = types.enum ["toml" "hpp"];
      default = "toml";
      description = "The configuration format to use.";
    };

    location = mkOption {
      type = types.oneOf [
        types.str
        (types.submodule {
          options = {
            lat = mkOption {
              type = types.float;
              description = "Latitude";
            };

            lon = mkOption {
              type = types.float;
              description = "Longitude";
            };
          };
        })
      ];

      default = {
        lat = 40.7128;
        lon = -74.0060;
      };

      description = ''
        Specifies the location for weather data. This can be either a city name
        (as a string) or an attribute set with `lat` and `lon` coordinates.
        Using a city name is only supported by the OpenWeatherMap provider.
      '';

      example = literalExpression ''
        "New York" or { lat = 40.7128; lon = -74.0060; }
      '';
    };

    weatherProvider = mkOption {
      type = types.enum ["OpenMeteo" "MetNo" "OpenWeatherMap"];
      default = "OpenMeteo";
      description = "The weather provider to use.";
    };

    weatherApiKey = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "API key, only required for OpenWeatherMap.";
    };

    usePugixml = mkOption {
      type = types.bool;
      default = false;
      description = "Use pugixml to parse XBPS package metadata. Required for package count functionality on Void Linux.";
    };

    enableNowPlaying = mkOption {
      type = types.bool;
      default = true;
      description = "Enable nowplaying functionality.";
    };

    enableWeather = mkOption {
      type = types.bool;
      default = true;
      description = "Enable fetching weather data.";
    };

    enablePackageCount = mkOption {
      type = types.bool;
      default = true;
      description = "Enable getting package count.";
    };

    enableCaching = mkOption {
      type = types.bool;
      default = true;
      description = "Enable caching functionality.";
    };

    username = mkOption {
      type = types.str;
      default = config.home.username // "User";
      description = "Username to display in the application.";
    };

    showTownName = mkOption {
      type = types.bool;
      default = true;
      description = "Show town name in weather display.";
    };

    weatherUnit = mkOption {
      type = types.enum ["Metric" "Imperial"];
      default = "Metric";
      description = "Unit for temperature display.";
    };

    packageManagers = mkOption {
      type = types.listOf (types.enum (
        ["cargo" "nix"]
        ++ lib.optionals pkgs.stdenv.isLinux ["apk" "dpkg" "moss" "pacman" "rpm" "xbps"]
        ++ lib.optionals pkgs.stdenv.isDarwin ["homebrew" "macports"]
      ));
      default = [];
      description = "List of package managers to check for package counts.";
    };
  };

  config = mkIf cfg.enable {
    home.packages = [draconisPkg];

    xdg.configFile."draconis++/config.toml" = mkIf (cfg.configFormat == "toml") {
      source = tomlFormat.generate "config.toml" {
        location =
          if lib.isAttrs cfg.location
          then {inherit (cfg.location) lat lon;}
          else {name = cfg.location;};
        weather = {
          inherit (cfg) weatherProvider weatherApiKey;
        };
      };
    };

    assertions = [
      {
        assertion = !(lib.isString cfg.location && cfg.weatherProvider != "OpenWeatherMap");
        message = "A town/city name for the location can only be used with the OpenWeatherMap provider.";
      }
      {
        assertion = !(cfg.weatherApiKey != null && cfg.weatherProvider != "OpenWeatherMap");
        message = "An API key should not be provided when using the OpenMeteo or MetNo providers.";
      }
      {
        assertion = !(cfg.usePugixml && !cfg.enablePackageCount);
        message = "usePugixml should only be enabled when enablePackageCount is also enabled.";
      }
    ];
  };
}
</file>

<file path="src/CLI/UI/UI.hpp">
#pragma once

#include <Drac++/Services/Weather.hpp>

#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#include "Config/Config.hpp"
#include "Core/SystemInfo.hpp"

namespace draconis::ui {
  namespace {
    using config::Config;

    using core::system::SystemInfo;

    using services::weather::Report;

    using utils::logging::LogColor;
    using utils::types::Result;
    using utils::types::String;
    using utils::types::StringView;
  } // namespace

  struct Theme {
    LogColor icon;
    LogColor label;
    LogColor value;
  };

  extern const Theme DEFAULT_THEME;

  struct Icons {
    StringView calendar;
    StringView desktopEnvironment;
    StringView disk;
    StringView host;
    StringView kernel;
    StringView memory;
    StringView cpu;
    StringView gpu;
    StringView uptime;
#if DRAC_ENABLE_NOWPLAYING
    StringView music;
#endif
    StringView os;
#if DRAC_ENABLE_PACKAGECOUNT
    StringView package;
#endif
    StringView palette;
    StringView shell;
    StringView user;
#if DRAC_ENABLE_WEATHER
    StringView weather;
#endif
    StringView windowManager;
  };

  extern const Icons ICON_TYPE;

#if DRAC_ENABLE_WEATHER
  /**
   * @brief Creates the main UI element based on system data and configuration.
   * @param config The application configuration.
   * @param data The collected system data.
   * @param weather The weather report, if enabled/available.
   * @return A string containing the formatted UI.
   */
  fn CreateUI(const Config& config, const SystemInfo& data, Result<Report> weather, bool noAscii) -> String;
#else
  /**
   * @brief Creates the main UI element based on system data and configuration.
   * @param config The application configuration.
   * @param data The collected system data. @return A string containing the formatted UI.
   */
  fn CreateUI(const Config& config, const SystemInfo& data, bool noAscii) -> String;
#endif // DRAC_ENABLE_WEATHER
} // namespace draconis::ui
</file>

<file path="src/Lib/Services/Packages.cpp">
#if DRAC_ENABLE_PACKAGECOUNT

  #include "Drac++/Services/Packages.hpp"

  #if !defined(__serenity__) && !defined(_WIN32)
    #include <SQLiteCpp/Database.h>  // SQLite::{Database, OPEN_READONLY}
    #include <SQLiteCpp/Exception.h> // SQLite::Exception
    #include <SQLiteCpp/Statement.h> // SQLite::Statement
  #endif

  #if defined(__linux__) && defined(HAVE_PUGIXML)
    #include <pugixml.hpp> // pugi::{xml_document, xml_node, xml_parse_result}
  #endif

  #include <filesystem>   // std::filesystem
  #include <future>       // std::{async, future, launch}
  #include <matchit.hpp>  // matchit::{match, is, or_, _}
  #include <system_error> // std::{errc, error_code}

  #include "Drac++/Utils/Env.hpp"
  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Logging.hpp"
  #include "Drac++/Utils/Types.hpp"

namespace fs = std::filesystem;

using namespace draconis::utils::types;
using draconis::utils::cache::CacheManager;
using enum draconis::utils::error::DracErrorCode;

namespace {
  constexpr const char* CACHE_KEY_PREFIX = "pkg_count_";

  fn GetCountFromDirectoryImplNoCache(
    const String&         pmId,
    const fs::path&       dirPath,
    const Option<String>& fileExtensionFilter,
    const bool            subtractOne
  ) -> Result<u64> {
    std::error_code fsErrCode;

    fsErrCode.clear();

    if (!fs::is_directory(dirPath, fsErrCode)) {
      if (fsErrCode && fsErrCode != std::errc::no_such_file_or_directory)
        ERR_FMT(ResourceExhausted, "Filesystem error checking if '{}' is a directory: {} (resource exhausted or API unavailable)", dirPath.string(), fsErrCode.message());

      ERR_FMT(NotFound, "{} path is not a directory: {}", pmId, dirPath.string());
    }

    fsErrCode.clear();

    u64              count     = 0;
    const bool       hasFilter = fileExtensionFilter.has_value();
    const StringView filter    = fileExtensionFilter ? StringView(*fileExtensionFilter) : StringView();

    try {
      const fs::directory_iterator dirIter(
        dirPath,
        fs::directory_options::skip_permission_denied | fs::directory_options::follow_directory_symlink,
        fsErrCode
      );

      if (fsErrCode)
        ERR_FMT(ResourceExhausted, "Failed to create iterator for {} directory '{}': {} (resource exhausted or API unavailable)", pmId, dirPath.string(), fsErrCode.message());

      if (hasFilter) {
        for (const fs::directory_entry& entry : dirIter) {
          if (entry.path().empty())
            continue;

          if (std::error_code isFileErr; entry.is_regular_file(isFileErr) && !isFileErr) {
            if (entry.path().extension().string() == filter)
              count++;
          } else if (isFileErr)
            warn_log("Error stating entry '{}' in {} directory: {}", entry.path().string(), pmId, isFileErr.message());
        }
      } else {
        for (const fs::directory_entry& entry : dirIter) {
          if (!entry.path().empty())
            count++;
        }
      }
    } catch (const fs::filesystem_error& fsCatchErr) {
      ERR_FMT(ResourceExhausted, "Filesystem error during {} directory iteration: {} (resource exhausted or API unavailable)", pmId, fsCatchErr.what());
    } catch (const Exception& exc) {
      ERR_FMT(InternalError, "Internal error during {} directory iteration: {}", pmId, exc.what());
    } catch (...) {
      ERR_FMT(Other, "Unknown error iterating {} directory (unexpected exception)", pmId);
    }

    if (subtractOne && count > 0)
      count--;

    return count;
  }

  fn GetCountFromDirectoryImpl(
    CacheManager&         cache,
    const String&         pmId,
    const fs::path&       dirPath,
    const Option<String>& fileExtensionFilter,
    const bool            subtractOne
  ) -> Result<u64> {
    return cache.getOrSet<u64>(std::format("{}{}", CACHE_KEY_PREFIX, pmId), [&]() -> Result<u64> {
      return GetCountFromDirectoryImplNoCache(pmId, dirPath, fileExtensionFilter, subtractOne);
    });
  }

} // namespace

namespace draconis::services::packages {
  fn GetCountFromDirectory(
    CacheManager&   cache,
    const String&   pmId,
    const fs::path& dirPath,
    const String&   fileExtensionFilter,
    const bool      subtractOne
  ) -> Result<u64> {
    return GetCountFromDirectoryImpl(cache, pmId, dirPath, fileExtensionFilter, subtractOne);
  }

  fn GetCountFromDirectory(CacheManager& cache, const String& pmId, const fs::path& dirPath, const String& fileExtensionFilter) -> Result<u64> {
    return GetCountFromDirectoryImpl(cache, pmId, dirPath, fileExtensionFilter, false);
  }

  fn GetCountFromDirectory(CacheManager& cache, const String& pmId, const fs::path& dirPath, const bool subtractOne) -> Result<u64> {
    return GetCountFromDirectoryImpl(cache, pmId, dirPath, None, subtractOne);
  }

  fn GetCountFromDirectory(CacheManager& cache, const String& pmId, const fs::path& dirPath) -> Result<u64> {
    return GetCountFromDirectoryImpl(cache, pmId, dirPath, None, false);
  }

  fn GetCountFromDirectoryNoCache(
    const String&         pmId,
    const fs::path&       dirPath,
    const Option<String>& fileExtensionFilter,
    const bool            subtractOne
  ) -> Result<u64> {
    return GetCountFromDirectoryImplNoCache(pmId, dirPath, fileExtensionFilter, subtractOne);
  }

  #if !defined(__serenity__) && !defined(_WIN32)
  fn GetCountFromDb(
    CacheManager&   cache,
    const String&   pmId,
    const fs::path& dbPath,
    const String&   countQuery
  ) -> Result<u64> {
    return cache.getOrSet<u64>(std::format("{}{}", CACHE_KEY_PREFIX, pmId), [&]() -> Result<u64> {
      u64 count = 0;

      try {
        if (std::error_code existsErr; !fs::exists(dbPath, existsErr) || existsErr)
          ERR_FMT(NotFound, "{} database not found at '{}' (file does not exist or access denied)", pmId, dbPath.string());

        const SQLite::Database database(dbPath.string(), SQLite::OPEN_READONLY);

        if (SQLite::Statement queryStmt(database, countQuery); queryStmt.executeStep()) {
          const i64 countInt64 = queryStmt.getColumn(0).getInt64();

          if (countInt64 < 0)
            ERR_FMT(CorruptedData, "Negative count returned by {} DB COUNT query (corrupt database data)", pmId);

          count = static_cast<u64>(countInt64);
        } else
          ERR_FMT(ParseError, "No rows returned by {} DB COUNT query (empty result set)", pmId);
      } catch (const SQLite::Exception& e) {
        ERR_FMT(ApiUnavailable, "SQLite error occurred accessing {} database '{}': {}", pmId, dbPath.string(), e.what());
      } catch (const Exception& e) {
        ERR_FMT(InternalError, "Standard exception accessing {} database '{}': {}", pmId, dbPath.string(), e.what());
      } catch (...) {
        ERR_FMT(Other, "Unknown error occurred accessing {} database (unexpected exception)", pmId);
      }

      return count;
    });
  }
  #endif // __serenity__ || _WIN32

  #if defined(__linux__) && defined(HAVE_PUGIXML)
  fn GetCountFromPlist(
    CacheManager&   cache,
    const String&   pmId,
    const fs::path& plistPath
  ) -> Result<u64> {
    return cache.getOrSet<u64>(std::format("{}{}", CACHE_KEY_PREFIX, pmId), [&]() -> Result<u64> {
      xml_document doc;

      if (const xml_parse_result result = doc.load_file(plistPath.c_str()); !result)
        ERR_FMT(ParseError, "Failed to parse plist file '{}': {} (malformed XML)", plistPath.string(), result.description());

      const xml_node dict = doc.child("plist").child("dict");

      if (!dict)
        ERR_FMT(CorruptedData, "No <dict> element found in plist file '{}' (corrupt plist structure)", plistPath.string());

      u64              count           = 0;
      const StringView alternativesKey = "_XBPS_ALTERNATIVES_";
      const StringView keyName         = "key";
      const StringView stateValue      = "installed";

      for (xml_node node = dict.first_child(); node; node = node.next_sibling()) {
        if (StringView(node.name()) != keyName)
          continue;

        if (const StringView keyName = node.child_value(); keyName == alternativesKey)
          continue;

        xml_node pkgDict = node.next_sibling("dict");

        if (!pkgDict)
          continue;

        bool isInstalled = false;

        for (xml_node pkgNode = pkgDict.first_child(); pkgNode; pkgNode = pkgNode.next_sibling())
          if (StringView(pkgNode.name()) == keyName && StringView(pkgNode.child_value()) == "state")
            if (xml_node stateValue = pkgNode.next_sibling("string"); stateValue && StringView(stateValue.child_value()) == stateValue) {
              isInstalled = true;
              break;
            }

        if (isInstalled)
          ++count;
      }

      if (count == 0)
        ERR_FMT(NotFound, "No installed packages found in plist file '{}' (empty package list)", plistPath.string());

      return count;
    });
  }
  #endif // __linux__

  #if defined(__linux__) || defined(__APPLE__)
  fn CountNix(CacheManager& cache) -> Result<u64> {
    return GetCountFromDb(cache, "nix", "/nix/var/nix/db/db.sqlite", "SELECT COUNT(path) FROM ValidPaths WHERE sigs IS NOT NULL");
  }
  #endif // __linux__ || __APPLE__

  fn CountCargo(CacheManager& cache) -> Result<u64> {
    using draconis::utils::env::GetEnv;

    fs::path cargoPath {};

    if (const Result<PCStr> cargoHome = GetEnv("CARGO_HOME"))
      cargoPath = fs::path(*cargoHome) / "bin";
    else if (const Result<PCStr> homeDir = GetEnv("HOME"))
      cargoPath = fs::path(*homeDir) / ".cargo" / "bin";

    if (cargoPath.empty() || !fs::exists(cargoPath))
      ERR(ConfigurationError, "Could not find cargo directory (CARGO_HOME or ~/.cargo/bin not configured)");

    return GetCountFromDirectory(cache, "cargo", cargoPath);
  }

  fn GetTotalCount(CacheManager& cache, const Manager enabledPackageManagers) -> Result<u64> {
  #if DRAC_PRECOMPILED_CONFIG
    #if DRAC_ENABLE_PACKAGECOUNT
    Vec<Future<Result<u64>>> futures;
    futures.reserve(16);

    fn addFutureIfEnabled = [&futures, &cache, enabledPackageManagers]<typename T>(const Manager manager, T&& countFunc) -> Unit {
      if (HasPackageManager(enabledPackageManagers, manager))
        futures.emplace_back(std::async(std::launch::async, std::forward<T>(countFunc), std::ref(cache)));
    };

      #ifdef __linux__
    addFutureIfEnabled(Manager::APK, CountApk);
    addFutureIfEnabled(Manager::DPKG, CountDpkg);
    addFutureIfEnabled(Manager::MOSS, CountMoss);
    addFutureIfEnabled(Manager::PACMAN, CountPacman);
    addFutureIfEnabled(Manager::RPM, CountRpm);
        #ifdef HAVE_PUGIXML
    addFutureIfEnabled(Manager::XBPS, CountXbps);
        #endif
      #elifdef __APPLE__
    addFutureIfEnabled(Manager::HOMEBREW, GetHomebrewCount);
    addFutureIfEnabled(Manager::MACPORTS, GetMacPortsCount);
      #elifdef _WIN32
    addFutureIfEnabled(Manager::WINGET, CountWinGet);
    addFutureIfEnabled(Manager::CHOCOLATEY, CountChocolatey);
    addFutureIfEnabled(Manager::SCOOP, CountScoop);
      #elif defined(__FreeBSD__) || defined(__DragonFly__)
    addFutureIfEnabled(Manager::PKGNG, GetPkgNgCount);
      #elifdef __NetBSD__
    addFutureIfEnabled(Manager::PKGSRC, GetPkgSrcCount);
      #elifdef __HAIKU__
    addFutureIfEnabled(Manager::HAIKUPKG, GetHaikuCount);
      #elifdef __serenity__
    addFutureIfEnabled(Manager::SERENITY, GetSerenityCount);
      #endif

      #if defined(__linux__) || defined(__APPLE__)
    addFutureIfEnabled(Manager::NIX, CountNix);
      #endif
    addFutureIfEnabled(Manager::CARGO, CountCargo);

    if (futures.empty())
      ERR(UnavailableFeature, "No enabled package managers for this platform in precompiled config (feature not available)");
    #else
    ERR(NotSupported, "Package counting disabled by precompiled configuration (feature not supported)");
    #endif
  #else
    #ifdef __linux__
      #ifdef HAVE_PUGIXML
    constexpr size_t platformSpecificCount = 6; // Apk, Dpkg, Moss, Pacman, Rpm, Xbps
      #else
    constexpr size_t platformSpecificCount = 5; // Apk, Dpkg, Moss, Pacman, Rpm
      #endif
    #elifdef __APPLE__
    constexpr size_t platformSpecificCount = 2; // Homebrew, MacPorts
    #elifdef _WIN32
    constexpr size_t platformSpecificCount = 3; // WinGet, Chocolatey, Scoop
    #elif defined(__FreeBSD__) || defined(__DragonFly__)
    constexpr size_t platformSpecificCount = 1; // GetPkgNgCount
    #elifdef __NetBSD__
    constexpr size_t platformSpecificCount = 1; // GetPkgSrcCount
    #elifdef __HAIKU__
    constexpr size_t platformSpecificCount = 1; // GetHaikuCount
    #elifdef __serenity__
    constexpr size_t platformSpecificCount = 1; // GetSerenityCount
    #endif

    #if defined(__linux__) || defined(__APPLE__)
    // platform specific + cargo + nix
    constexpr size_t numFutures = platformSpecificCount + 2;
    #else
    // platform specific + cargo
    constexpr size_t numFutures = platformSpecificCount + 1;
    #endif

    Array<Future<Result<u64>>, numFutures> futures;
    size_t                                 active = 0;

    #ifdef __linux__
    if (HasPackageManager(enabledPackageManagers, Manager::APK))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountApk(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::DPKG))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountDpkg(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::MOSS))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountMoss(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::PACMAN))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountPacman(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::RPM))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountRpm(cache); });
      #ifdef HAVE_PUGIXML
    if (HasPackageManager(enabledPackageManagers, Manager::XBPS))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountXbps(cache); });
      #endif
    #elifdef __APPLE__
    if (HasPackageManager(enabledPackageManagers, Manager::HOMEBREW))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return GetHomebrewCount(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::MACPORTS))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return GetMacPortsCount(cache); });
    #elifdef _WIN32
    if (HasPackageManager(enabledPackageManagers, Manager::WINGET))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountWinGet(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::CHOCOLATEY))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountChocolatey(cache); });
    if (HasPackageManager(enabledPackageManagers, Manager::SCOOP))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountScoop(cache); });
    #elif defined(__FreeBSD__) || defined(__DragonFly__)
    if (HasPackageManager(enabledPackageManagers, Manager::PKGNG))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return GetPkgNgCount(cache); });
    #elifdef __NetBSD__
    if (HasPackageManager(enabledPackageManagers, Manager::PKGSRC))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return GetPkgSrcCount(cache); });
    #elifdef __HAIKU__
    if (HasPackageManager(enabledPackageManagers, Manager::HAIKUPKG))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return GetHaikuCount(cache); });
    #elifdef __serenity__
    if (HasPackageManager(enabledPackageManagers, Manager::SERENITY))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return GetSerenityCount(cache); });
    #endif

    #if defined(__linux__) || defined(__APPLE__)
    if (HasPackageManager(enabledPackageManagers, Manager::NIX))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountNix(cache); });
    #endif

    if (HasPackageManager(enabledPackageManagers, Manager::CARGO))
      futures.at(active++) = std::async(std::launch::async, [&cache]() { return CountCargo(cache); });

    if (active == 0)
      ERR(UnavailableFeature, "No enabled package managers for this platform.");
  #endif // DRAC_PRECOMPILED_CONFIG
    u64  totalCount   = 0;
    bool oneSucceeded = false;

    constexpr usize chunkSize = 4;

    usize effectiveSize =
  #if DRAC_PRECOMPILED_CONFIG
      futures.size();
  #else
      active;
  #endif

    for (usize i = 0; i < effectiveSize; i += chunkSize) {
      const usize end = std::min(i + chunkSize, effectiveSize);

      for (usize j = i; j < end; ++j) {
        try {
          using matchit::match, matchit::is, matchit::or_, matchit::_;

          if (const Result<u64> result = futures.at(j).get()) {
            totalCount += *result;
            oneSucceeded = true;
          } else
            match(result.error().code)(
              is | or_(NotFound, ApiUnavailable, NotSupported) = [&] -> Unit { debug_at(result.error()); },
              is | _                                           = [&] -> Unit { error_at(result.error()); }
            );
        } catch (const Exception& exc) {
          error_log("Exception while getting package count future: {}", exc.what());
        } catch (...) {
          error_log("Unknown exception while getting package count future (unexpected exception)");
        }
      }
    }

    if (!oneSucceeded && totalCount == 0)
      ERR(UnavailableFeature, "No package managers found or none reported counts (feature not available)");

    return totalCount;
  }

  fn GetIndividualCounts(CacheManager& cache, const Manager enabledPackageManagers) -> Result<Map<String, u64>> {
  #if DRAC_PRECOMPILED_CONFIG
    #if DRAC_ENABLE_PACKAGECOUNT
    Vec<Future<Result<u64>>> futures;
    Vec<String>              managerNames;
    futures.reserve(16);
    managerNames.reserve(16);

    fn addFutureIfEnabled = [&futures, &managerNames, &cache, enabledPackageManagers]<typename T>(const Manager manager, const String& name, T&& countFunc) -> Unit {
      if (HasPackageManager(enabledPackageManagers, manager)) {
        futures.emplace_back(std::async(std::launch::async, std::forward<T>(countFunc), std::ref(cache)));
        managerNames.emplace_back(name);
      }
    };

      #ifdef __linux__
    addFutureIfEnabled(Manager::APK, "apk", CountApk);
    addFutureIfEnabled(Manager::DPKG, "dpkg", CountDpkg);
    addFutureIfEnabled(Manager::MOSS, "moss", CountMoss);
    addFutureIfEnabled(Manager::PACMAN, "pacman", CountPacman);
    addFutureIfEnabled(Manager::RPM, "rpm", CountRpm);
        #ifdef HAVE_PUGIXML
    addFutureIfEnabled(Manager::XBPS, "xbps", CountXbps);
        #endif
      #elifdef __APPLE__
    addFutureIfEnabled(Manager::HOMEBREW, "homebrew", GetHomebrewCount);
    addFutureIfEnabled(Manager::MACPORTS, "macports", GetMacPortsCount);
      #elifdef _WIN32
    addFutureIfEnabled(Manager::WINGET, "winget", CountWinGet);
    addFutureIfEnabled(Manager::CHOCOLATEY, "chocolatey", CountChocolatey);
    addFutureIfEnabled(Manager::SCOOP, "scoop", CountScoop);
      #elif defined(__FreeBSD__) || defined(__DragonFly__)
    addFutureIfEnabled(Manager::PKGNG, "pkgng", GetPkgNgCount);
      #elifdef __NetBSD__
    addFutureIfEnabled(Manager::PKGSRC, "pkgsrc", GetPkgSrcCount);
      #elifdef __HAIKU__
    addFutureIfEnabled(Manager::HAIKUPKG, "haikupkg", GetHaikuCount);
      #endif

      #if defined(__linux__) || defined(__APPLE__)
    addFutureIfEnabled(Manager::NIX, "nix", CountNix);
      #endif
    addFutureIfEnabled(Manager::CARGO, "cargo", CountCargo);

    if (futures.empty())
      ERR(UnavailableFeature, "No enabled package managers for this platform in precompiled config (feature not available)");
    #else
    ERR(NotSupported, "Package counting disabled by precompiled configuration (feature not supported)");
    #endif
  #else
    #ifdef __linux__
      #ifdef HAVE_PUGIXML
    constexpr size_t platformSpecificCount = 6; // Apk, Dpkg, Moss, Pacman, Rpm, Xbps
      #else
    constexpr size_t platformSpecificCount = 5; // Apk, Dpkg, Moss, Pacman, Rpm
      #endif
    #elifdef __APPLE__
    constexpr size_t platformSpecificCount = 2; // Homebrew, MacPorts
    #elifdef _WIN32
    constexpr size_t platformSpecificCount = 3; // WinGet, Chocolatey, Scoop
    #elif defined(__FreeBSD__) || defined(__DragonFly__)
    constexpr size_t platformSpecificCount = 1; // GetPkgNgCount
    #elifdef __NetBSD__
    constexpr size_t platformSpecificCount = 1; // GetPkgSrcCount
    #elifdef __HAIKU__
    constexpr size_t platformSpecificCount = 1; // GetHaikuCount
    #elifdef __serenity__
    constexpr size_t platformSpecificCount = 1; // GetSerenityCount
    #endif

    #if defined(__linux__) || defined(__APPLE__)
    // platform specific + cargo + nix
    constexpr size_t numFutures = platformSpecificCount + 2;
    #else
    // platform specific + cargo
    constexpr size_t numFutures = platformSpecificCount + 1;
    #endif

    Array<Future<Result<u64>>, numFutures> futures;
    Array<String, numFutures>              managerNames;
    size_t                                 active = 0;

    #ifdef __linux__
    if (HasPackageManager(enabledPackageManagers, Manager::APK)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountApk(cache); });
      managerNames.at(active++) = "apk";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::DPKG)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountDpkg(cache); });
      managerNames.at(active++) = "dpkg";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::MOSS)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountMoss(cache); });
      managerNames.at(active++) = "moss";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::PACMAN)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountPacman(cache); });
      managerNames.at(active++) = "pacman";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::RPM)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountRpm(cache); });
      managerNames.at(active++) = "rpm";
    }
      #ifdef HAVE_PUGIXML
    if (HasPackageManager(enabledPackageManagers, Manager::XBPS)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountXbps(cache); });
      managerNames.at(active++) = "xbps";
    }
      #endif
    #elifdef __APPLE__
    if (HasPackageManager(enabledPackageManagers, Manager::HOMEBREW)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return GetHomebrewCount(cache); });
      managerNames.at(active++) = "homebrew";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::MACPORTS)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return GetMacPortsCount(cache); });
      managerNames.at(active++) = "macports";
    }
    #elifdef _WIN32
    if (HasPackageManager(enabledPackageManagers, Manager::WINGET)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountWinGet(cache); });
      managerNames.at(active++) = "winget";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::CHOCOLATEY)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountChocolatey(cache); });
      managerNames.at(active++) = "chocolatey";
    }
    if (HasPackageManager(enabledPackageManagers, Manager::SCOOP)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountScoop(cache); });
      managerNames.at(active++) = "scoop";
    }
    #elif defined(__FreeBSD__) || defined(__DragonFly__)
    if (HasPackageManager(enabledPackageManagers, Manager::PKGNG)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return GetPkgNgCount(cache); });
      managerNames.at(active++) = "pkgng";
    }
    #elifdef __NetBSD__
    if (HasPackageManager(enabledPackageManagers, Manager::PKGSRC)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return GetPkgSrcCount(cache); });
      managerNames.at(active++) = "pkgsrc";
    }
    #elifdef __HAIKU__
    if (HasPackageManager(enabledPackageManagers, Manager::HAIKUPKG)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return GetHaikuCount(cache); });
      managerNames.at(active++) = "haikupkg";
    }
    #elifdef __serenity__
    if (HasPackageManager(enabledPackageManagers, Manager::SERENITY)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return GetSerenityCount(cache); });
      managerNames.at(active++) = "serenity";
    }
    #endif

    #if defined(__linux__) || defined(__APPLE__)
    if (HasPackageManager(enabledPackageManagers, Manager::NIX)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountNix(cache); });
      managerNames.at(active++) = "nix";
    }
    #endif

    if (HasPackageManager(enabledPackageManagers, Manager::CARGO)) {
      futures.at(active)        = std::async(std::launch::async, [&cache]() { return CountCargo(cache); });
      managerNames.at(active++) = "cargo";
    }

    if (active == 0)
      ERR(UnavailableFeature, "No enabled package managers for this platform.");
  #endif // DRAC_PRECOMPILED_CONFIG

    Map<String, u64> individualCounts;
    bool             oneSucceeded = false;

    constexpr usize chunkSize = 4;

    usize effectiveSize =
  #if DRAC_PRECOMPILED_CONFIG
      futures.size();
  #else
      active;
  #endif

    for (usize i = 0; i < effectiveSize; i += chunkSize) {
      const usize end = std::min(i + chunkSize, effectiveSize);

      for (usize j = i; j < end; ++j) {
        try {
          using matchit::match, matchit::is, matchit::or_, matchit::_;

          if (const Result<u64> result = futures.at(j).get()) {
            individualCounts[managerNames.at(j)] = *result;
            oneSucceeded                         = true;
          } else
            match(result.error().code)(
              is | or_(NotFound, ApiUnavailable, NotSupported) = [&] -> Unit { debug_at(result.error()); },
              is | _                                           = [&] -> Unit { error_at(result.error()); }
            );
        } catch (const Exception& exc) {
          error_log("Exception while getting package count future: {}", exc.what());
        } catch (...) {
          error_log("Unknown exception while getting package count future (unexpected exception)");
        }
      }
    }

    if (!oneSucceeded && individualCounts.empty())
      ERR(UnavailableFeature, "No package managers found or none reported counts (feature not available)");

    return individualCounts;
  }
} // namespace draconis::services::packages

#endif // DRAC_ENABLE_PACKAGECOUNT
</file>

<file path="include/Drac++/Utils/Types.hpp">
/**
 * @file Types.hpp
 * @brief Defines various type aliases for commonly used types.
 *
 * This header provides a collection of type aliases for commonly used types
 * in the Drac++ project. These aliases are defined using the standard library
 * types and are provided as convenient shorthand notations.
 */

#pragma once

#include <array>         // std::array (Array)
#include <expected>      // std::expected
#include <functional>    // std::function (Fn)
#include <future>        // std::future (Future)
#include <map>           // std::map (Map)
#include <memory>        // std::shared_ptr and std::unique_ptr (SharedPointer, UniquePointer)
#include <mutex>         // std::mutex and std::lock_guard (Mutex, LockGuard)
#include <optional>      // std::optional (Option)
#include <span>          // std::span (Span)
#include <string>        // std::string (String, StringView)
#include <string_view>   // std::string_view (StringView)
#include <unordered_map> // std::unordered_map (UnorderedMap)
#include <utility>       // std::pair (Pair)
#include <vector>        // std::vector (Vec)

namespace draconis::utils {
  // Forward decl for Result and Err
  namespace error {
    struct DracError;
  } // namespace error

  namespace types {
    /**
     * @brief Alias for std::uint8_t.
     *
     * 8-bit unsigned integer.
     */
    using u8 = std::uint8_t;

    /**
     * @brief Alias for std::uint16_t.
     *
     * 16-bit unsigned integer.
     */
    using u16 = std::uint16_t;

    /**
     * @brief Alias for std::uint32_t.
     *
     * 32-bit unsigned integer.
     */
    using u32 = std::uint32_t;

    /**
     * @brief Alias for std::uint64_t.
     *
     * 64-bit unsigned integer.
     */
    using u64 = std::uint64_t;

    /**
     * @brief Alias for std::int8_t.
     *
     * 8-bit signed integer.
     */
    using i8 = std::int8_t;

    /**
     * @brief Alias for std::int16_t.
     *
     * 16-bit signed integer.
     */
    using i16 = std::int16_t;

    /**
     * @brief Alias for std::int32_t.
     *
     * 32-bit signed integer.
     */
    using i32 = std::int32_t;

    /**
     * @brief Alias for std::int64_t.
     *
     * 64-bit signed integer.
     */
    using i64 = std::int64_t;

    /**
     * @brief Alias for float.
     *
     * 32-bit floating-point number.
     */
    using f32 = float;

    /**
     * @brief Alias for double.
     *
     * 64-bit floating-point number.
     */
    using f64 = double;

    /**
     * @brief Alias for std::size_t.
     *
     * Unsigned size type (result of sizeof).
     */
    using usize = std::size_t;

    /**
     * @brief Alias for std::ptrdiff_t.
     *
     * Signed size type (result of pointer subtraction).
     */
    using isize = std::ptrdiff_t;

    /**
     * @brief Alias for std::string.
     *
     * Owning, mutable string.
     */
    using String = std::string;

    /**
     * @brief Alias for std::wstring.
     *
     * Owning, mutable wide string.
     */
    using WString = std::wstring;

    /**
     * @brief Alias for std::string_view.
     *
     * Non-owning view of a string.
     */
    using StringView = std::string_view;

    /**
     * @brief Alias for std::wstring_view.
     *
     * Non-owning view of a wide string.
     */
    using WStringView = std::wstring_view;

    /**
     * @brief Alias for char.
     *
     * Single character type.
     */
    using CStr = char;

    /**
     * @brief Alias for const char*.
     *
     * Pointer to a null-terminated C-style string.
     */
    using PCStr = const char*;

    /**
     * @brief Alias for wchar_t.
     *
     * Single wide character type.
     */
    using WCStr = wchar_t;

    /**
     * @brief Alias for const wchar_t*.
     *
     * Pointer to a null-terminated C-style wide string.
     */
    using PWCStr = const wchar_t*;

    /**
     * @brief Alias for std::exception.
     *
     * Standard exception type.
     */
    using Exception = std::exception;

    /**
     * @brief Alias for std::mutex.
     *
     * Mutex type for synchronization.
     */
    using Mutex = std::mutex;

    /**
     * @brief Alias for std::lock_guard<Mutex>.
     *
     * RAII-style lock guard for mutexes.
     */
    using LockGuard = std::lock_guard<Mutex>;

    /**
     * @brief Alias for void.
     *
     * Represents a unit type.
     */
    using Unit = void;

    /**
     * @brief Alias for void*.
     *
     * A type-erased pointer.
     */
    using RawPointer = void*;

    /**
     * @brief Alias for std::optional<Tp>.
     *
     * Represents a value that may or may not be present.
     * @tparam Tp The type of the potential value.
     */
    template <typename Tp>
    using Option = std::optional<Tp>;

    /**
     * @brief Alias for std::nullopt_t.
     *
     * Represents an empty optional value.
     */
    inline constexpr std::nullopt_t None = std::nullopt;

    /**
     * @brief Helper function to create an Option with a value.
     *
     * Creates an Option containing the given value.
     * @tparam Tp The type of the value.
     * @param value The value to wrap in an Option.
     * @return An Option containing the value.
     */
    template <typename Tp>
    constexpr fn Some(Tp&& value) -> Option<std::remove_reference_t<Tp>> {
      return std::make_optional<std::remove_reference_t<Tp>>(std::forward<Tp>(value));
    }

    /**
     * @brief Alias for std::array<Tp, sz>.
     *
     * Represents a fixed-size array.
     * @tparam Tp The element type.
     * @tparam sz The size of the array.
     */
    template <typename Tp, usize sz>
    using Array = std::array<Tp, sz>;

    /**
     * @brief Alias for std::vector<Tp>.
     *
     * Represents a dynamic-size array (vector).
     * @tparam Tp The element type.
     */
    template <typename Tp>
    using Vec = std::vector<Tp>;

    /**
     * @brief Alias for std::span<Tp, sz>.
     *
     * Represents a non-owning view of a contiguous sequence of elements.
     * @tparam Tp The element type.
     * @tparam sz (Optional) The size of the span.
     */
    template <typename Tp, usize sz = std::dynamic_extent>
    using Span = std::span<Tp, sz>;

    /**
     * @brief Alias for std::pair<T1, T2>.
     *
     * Represents a pair of values.
     * @tparam T1 The type of the first element.
     * @tparam T2 The type of the second element.
     */
    template <typename T1, typename T2>
    using Pair = std::pair<T1, T2>;

    /**
     * @brief Alias for std::tuple<Ts...>.
     *
     * Represents a tuple of values.
     * @tparam Ts The types of the elements.
     */
    template <typename... Ts>
    using Tuple = std::tuple<Ts...>;

    /**
     * @brief Alias for std::map<Key, Val>.
     *
     * Represents an ordered map (dictionary).
     * @tparam Key The key type.
     * @tparam Val The value type.
     */
    template <typename Key, typename Val>
    using Map = std::map<Key, Val, std::less<>>;

    /**
     * @brief Alias for std::unordered_map<Key, Val>.
     *
     * Represents an unordered map (dictionary).
     * @tparam Key The key type.
     * @tparam Val The value type.
     */
    template <typename Key, typename Val>
    using UnorderedMap = std::unordered_map<Key, Val>;

    /**
     * @brief Alias for std::shared_ptr<Tp>.
     *
     * Manages shared ownership of a dynamically allocated object.
     * @tparam Tp The type of the managed object.
     */
    template <typename Tp>
    using SharedPointer = std::shared_ptr<Tp>;

    /**
     * @brief Alias for std::unique_ptr<Tp, Dp>.
     *
     * Manages unique ownership of a dynamically allocated object.
     * @tparam Tp The type of the managed object.
     * @tparam Dp The deleter type (defaults to std::default_delete<Tp>).
     */
    template <typename Tp, typename Dp = std::default_delete<Tp>>
    using UniquePointer = std::unique_ptr<Tp, Dp>;

    /**
     * @brief Alias for std::future<Tp>.
     *
     * @tparam Tp The type of the value.
     */
    template <typename Tp>
    using Future = std::future<Tp>;

    /**
     * @brief Alias for std::move_only_function<Tp>.
     *
     * Represents a callable object.
     * @tparam Tp The return type of the callable.
     */
    template <typename Tp>
    using Fn = std::function<Tp>;

    /**
     * @typedef Result
     * @brief Alias for std::expected<Tp, Er>. Represents a value that can either be
     * a success value of type Tp or an error value of type Er.
     * @tparam Tp The type of the success value.
     * @tparam Er The type of the error value.
     */
    template <typename Tp = Unit, typename Er = error::DracError>
    using Result = std::expected<Tp, Er>;

    /**
     * @typedef Err
     * @brief Alias for std::unexpected<Er>. Used to construct a Result in an error state.
     * @tparam Er The type of the error value.
     */
    template <typename Er = error::DracError>
    using Err = std::unexpected<Er>;
  } // namespace types
} // namespace draconis::utils
</file>

<file path="src/CLI/Config/Config.hpp">
#pragma once

#ifdef _WIN32
  #include <windows.h> // GetUserNameA, DWORD
#else
  #include <pwd.h>    // getpwuid, passwd
  #include <unistd.h> // getuid

  #include <Drac++/Utils/Env.hpp>
#endif

#if !DRAC_PRECOMPILED_CONFIG
  #include <memory>                    // std::{make_unique, unique_ptr}
  #include <toml++/impl/node.hpp>      // toml::node
  #include <toml++/impl/node_view.hpp> // toml::node_view
  #include <toml++/impl/table.hpp>     // toml::table

  #include <Drac++/Utils/Logging.hpp>
#endif

#if DRAC_ENABLE_WEATHER
  #include <Drac++/Services/Weather.hpp>
#endif

#if DRAC_ENABLE_PACKAGECOUNT
  #include <Drac++/Services/Packages.hpp>
#endif

#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

namespace draconis::config {
  /**
   * @struct General
   * @brief Holds general configuration settings.
   */
  struct General {
    mutable draconis::utils::types::Option<draconis::utils::types::String> name; ///< Display name; resolved lazily via getDefaultName() when needed.

    /**
     * @brief Retrieves the default name for the user.
     * @return The default name for the user, either from the system or a fallback.
     *
     * Retrieves the default name for the user based on the operating system.
     * On Windows, it uses GetUserNameA to get the username.
     * On POSIX systems, it first tries to get the username using getpwuid,
     * then checks the USER and LOGNAME environment variables.
     */
    static fn getDefaultName() -> draconis::utils::types::String {
#ifdef _WIN32
      using draconis::utils::types::Array;

      Array<char, 256> username {};

      DWORD size = username.size();

      return GetUserNameA(username.data(), &size) ? username.data() : "User";
#else
      using draconis::utils::env::GetEnv;
      using draconis::utils::types::PCStr, draconis::utils::types::String, draconis::utils::types::Result;

      info_log("Getting default name from system");

      const passwd*        pwd        = getpwuid(getuid());
      PCStr                pwdName    = pwd ? pwd->pw_name : nullptr;
      const Result<String> envUser    = GetEnv("USER");
      const Result<String> envLogname = GetEnv("LOGNAME");

      return pwdName ? pwdName
        : envUser    ? *envUser
        : envLogname ? *envLogname
                     : "User";
#endif // _WIN32
    }

    fn getName() const -> const draconis::utils::types::String& {
      if (!name)
        name = getDefaultName();
      return *name;
    }

#if !DRAC_PRECOMPILED_CONFIG
    /**
     * @brief Parses a TOML table to create a General instance.
     * @param tbl The TOML table to parse, containing [general].
     * @return A General instance with the parsed values, or defaults otherwise.
     */
    static fn fromToml(const toml::table& tbl) -> General {
      using draconis::utils::types::String;

      General gen;

      if (const toml::node_view<const toml::node> nameNode = tbl["name"])
        if (auto nameVal = nameNode.value<String>())
          gen.name = *nameVal;

      return gen;
    }
#endif // DRAC_PRECOMPILED_CONFIG
  };

#if DRAC_ENABLE_NOWPLAYING
  /**
   * @struct NowPlaying
   * @brief Holds configuration settings for the Now Playing feature.
   */
  struct NowPlaying {
    bool enabled = true; ///< Flag to enable or disable the Now Playing feature.

  #if !DRAC_PRECOMPILED_CONFIG
    /**
     * @brief Parses a TOML table to create a NowPlaying instance.
     * @param tbl The TOML table to parse, containing [now_playing].
     * @return A NowPlaying instance with the parsed values, or defaults otherwise.
     */
    static fn fromToml(const toml::table& tbl) -> NowPlaying {
      return { .enabled = tbl["enabled"].value_or(true) };
    }
  #endif
  };
#endif // DRAC_ENABLE_NOWPLAYING

#if DRAC_ENABLE_WEATHER
  /**
   * @struct Weather
   * @brief Holds configuration settings for the Weather feature.
   */
  struct Weather {
    draconis::services::weather::Location                          location; ///< Location for weather data, can be a city name or coordinates.
    draconis::utils::types::Option<draconis::utils::types::String> apiKey;   ///< API key for the weather service.
    draconis::services::weather::UnitSystem                        units;    ///< Units for temperature, either "metric" or "imperial".

    bool                                                          enabled      = false;   ///< Flag to enable or disable the Weather feature.
    bool                                                          showTownName = false;   ///< Flag to show the town name in the output.
    std::unique_ptr<draconis::services::weather::IWeatherService> service      = nullptr; ///< Pointer to the weather service.

  #if !DRAC_PRECOMPILED_CONFIG
    /**
     * @brief Parses a TOML table to create a Weather instance.
     * @param tbl The TOML table to parse, containing [weather].
     * @return A Weather instance with the parsed values, or defaults otherwise.
     */
    static fn fromToml(const toml::table& tbl) -> Weather {
      using draconis::utils::types::String;
      using namespace draconis::services::weather;

      using matchit::match, matchit::is, matchit::_;

    #define SET_ERROR(...)       \
      do {                       \
        error_log(__VA_ARGS__);  \
        weather.enabled = false; \
      } while (false)

      Weather weather;

      weather.apiKey  = tbl["api_key"].value<String>();
      weather.enabled = tbl["enabled"].value_or<bool>(false);

      if (!weather.enabled)
        return weather;

      weather.showTownName = tbl["show_town_name"].value_or(false);
      String unitsStr      = tbl["units"].value_or("metric");

      match(unitsStr)(
        is | "metric"   = [&]() { weather.units = UnitSystem::Metric; },
        is | "imperial" = [&]() { weather.units = UnitSystem::Imperial; },
        is | _          = [&]() { SET_ERROR("Invalid units: '{}'. Accepted values are 'metric' and 'imperial'.", unitsStr); }
      );

      String provider = tbl["provider"].value_or("openweathermap");

      if (const toml::node_view<const toml::node> locationNode = tbl["location"]) {
        using matchit::app;

        // clang-format off
        match(locationNode)(
          is | app([](const toml::node_view<const toml::node>& node) { return node.is_string(); }, true) = [&]() { weather.location = *locationNode.value<String>(); },
          is | app([](const toml::node_view<const toml::node>& node) { return node.is_table(); }, true)  = [&]() {
            weather.location = Coords {
              .lat = *locationNode.as_table()->get("lat")->value<double>(),
              .lon = *locationNode.as_table()->get("lon")->value<double>(),
            };
          },
          is | _ = [&]() { SET_ERROR("Invalid location format in config. Accepted values are a string (only if using OpenWeatherMap) or a table with 'lat' and 'lon' keys."); }
        );
        // clang-format on
      } else
        SET_ERROR("No location provided in config. Accepted values are a string (only if using OpenWeatherMap) or a table with 'lat' and 'lon' keys.");

      if (weather.enabled) {
        // clang-format off
        match(provider)(
          is | "openmeteo" = [&]() {
            if (std::holds_alternative<Coords>(weather.location)) {
              const auto& coords = std::get<Coords>(weather.location);
              weather.service = CreateWeatherService(Provider::OpenMeteo, coords, weather.units);
            } else
              SET_ERROR("OpenMeteo requires coordinates (lat, lon) for location.");
          },
          is | "metno" = [&]() {
            if (std::holds_alternative<Coords>(weather.location)) {
              const auto& coords = std::get<Coords>(weather.location);
              weather.service = CreateWeatherService(Provider::MetNo, coords, weather.units);
            } else
              SET_ERROR("MetNo requires coordinates (lat, lon) for location.");
          },
          is | "openweathermap" = [&]() {
            if (weather.apiKey)
              weather.service = CreateWeatherService(Provider::OpenWeatherMap, weather.location,  weather.units, weather.apiKey);
            else
              SET_ERROR("OpenWeatherMap requires an API key.");
          },
          is | _ = [&]() { SET_ERROR("Unknown weather provider: '{}'. Accepted values are 'openmeteo', 'metno', and 'openweathermap'.", provider); }
        );
        // clang-format on
      }

      return weather;
    }
  #endif // DRAC_PRECOMPILED_CONFIG
  };
#endif // DRAC_ENABLE_WEATHER

  /**
   * @struct Config
   * @brief Holds the application configuration settings.
   */
  struct Config {
    General general; ///< General configuration settings.
#if DRAC_ENABLE_WEATHER
    Weather weather; ///< Weather configuration settings.
#endif
#if DRAC_ENABLE_NOWPLAYING
    NowPlaying nowPlaying; ///< Now Playing configuration settings.
#endif
#if DRAC_ENABLE_PACKAGECOUNT
    draconis::services::packages::Manager enabledPackageManagers; ///< Enabled package managers.
#endif

    /**
     * @brief Default constructor for Config.
     */
    Config() = default;

#if !DRAC_PRECOMPILED_CONFIG
    /**
     * @brief Constructs a Config instance from a TOML table.
     * @param tbl The TOML table to parse, containing [general], [weather], and [now_playing].
     */
    explicit Config(const toml::table& tbl);
#endif

    /**
     * @brief Retrieves the path to the configuration file.
     * @return The path to the configuration file.
     *
     * This function constructs the path to the configuration file based on
     * the operating system and user directory. It returns a std::filesystem::path
     * object representing the configuration file path.
     */
    static fn getInstance() -> Config;
  };
} // namespace draconis::config
</file>

<file path="examples/glaze_http/main.cpp">
#include <asio/error.hpp>            // asio::error::operation_aborted
#include <chrono>                    // std::chrono::{minutes, steady_clock, time_point}
#include <csignal>                   // SIGINT, SIGTERM, SIG_ERR, std::signal
#include <cstdlib>                   // EXIT_FAILURE, EXIT_SUCCESS
#include <fstream>                   // std::ifstream
#include <magic_enum/magic_enum.hpp> // magic_enum::enum_name

#ifdef DELETE
  #undef DELETE
#endif

#ifdef fn
  #undef fn
#endif

#include <glaze/core/context.hpp>    // glz::error_ctx
#include <glaze/core/meta.hpp>       // glz::{meta, detail::Object}
#include <glaze/net/http_server.hpp> // glz::http_server
#include <matchit.hpp>               // matchit::impl::Overload
#include <mutex>                     // std::{mutex, unique_lock}
#include <optional>                  // std::optional
#include <utility>                   // std::move

#ifndef fn
  #define fn auto
#endif

#include <Drac++/Core/System.hpp>
#include <Drac++/Services/Weather.hpp>

#include <Drac++/Utils/CacheManager.hpp>
#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

using namespace draconis::utils::types;
using namespace draconis::services::weather;
using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;

namespace {
  constexpr i16   port        = 3722;
  constexpr PCStr indexFile   = "examples/glaze_http/web/index.mustache";
  constexpr PCStr stylingFile = "examples/glaze_http/web/style.css";

  struct State {
#if DRAC_ENABLE_WEATHER
    mutable struct WeatherCache {
      std::optional<Result<Report>>         report;
      std::chrono::steady_clock::time_point lastChecked;
      mutable std::mutex                    mtx;
    } weatherCache;

    mutable UniquePointer<IWeatherService> weatherService;
#endif
  };

  fn GetState() -> const State& {
    static const State STATE;

    return STATE;
  }

  fn readFile(const std::filesystem::path& path) -> Result<String> {
    if (!std::filesystem::exists(path))
      ERR_FMT(NotFound, "File not found: {}", path.string());

    std::ifstream file(path, std::ios::in | std::ios::binary);
    if (!file)
      ERR_FMT(IoError, "Failed to open file: {}", path.string());

    const usize size = std::filesystem::file_size(path);

    String result(size, '\0');

    file.read(result.data(), static_cast<std::streamsize>(size));

    return result;
  }
} // namespace

struct SystemProperty {
  String name;
  String value;
  String error;
  bool   hasError = false;

  SystemProperty(String name, String value)
    : name(std::move(name)), value(std::move(value)) {}

  SystemProperty(String name, const DracError& err)
    : name(std::move(name)), error(std::format("{} ({})", err.message, magic_enum::enum_name(err.code))), hasError(true) {}
};

struct SystemInfo {
  Vec<SystemProperty> properties;
  String              version = DRAC_VERSION;
};

namespace glz {
  template <>
  struct meta<SystemProperty> {
    using T = SystemProperty;

    // clang-format off
    static constexpr glz::detail::Object value = glz::object(
      "name",     &T::name,
      "value",    &T::value,
      "error",    &T::error,
      "hasError", &T::hasError
    );
    // clang-format on
  };

  template <>
  struct meta<SystemInfo> {
    using T = SystemInfo;

    static constexpr glz::detail::Object value = glz::object("properties", &T::properties, "version", &T::version);
  };
} // namespace glz

fn main() -> i32 {
  glz::http_server server;

#if DRAC_ENABLE_WEATHER
  {
    GetState().weatherService = CreateWeatherService(Provider::MetNo, Coords(40.71427, -74.00597), UnitSystem::Imperial);

    if (!GetState().weatherService)
      error_log("Error: Failed to initialize WeatherService.");
  }
#endif

  server.on_error([](const std::error_code errc, const std::source_location& loc) {
    if (errc != asio::error::operation_aborted)
      error_log("Server error at {}:{} -> {}", loc.file_name(), loc.line(), errc.message());
  });

  server.get("/style.css", [](const glz::request& req, glz::response& res) {
    info_log("Handling request for style.css from {}", req.remote_ip);

    Result<String> result = readFile(stylingFile);

    if (result)
      res.header("Content-Type", "text/css; charset=utf-8")
        .header("Cache-Control", "no-cache, no-store, must-revalidate")
        .header("Pragma", "no-cache")
        .header("Expires", "0")
        .body(*result);
    else {
      error_log("Failed to serve style.css: {}", result.error().message);
      res.status(500).body("Internal Server Error: Could not load stylesheet.");
    }
  });

  server.get("/", [](const glz::request& req, glz::response& res) {
    info_log("Handling request from {}", req.remote_ip);

    SystemInfo sysInfo;

    draconis::utils::cache::CacheManager cacheManager;

    {
      using namespace draconis::core::system;
      using matchit::impl::Overload;
      using enum draconis::utils::error::DracErrorCode;

      fn addProperty = Overload {
        [&](const String& name, const Result<String>& result) -> Unit {
          if (result)
            sysInfo.properties.emplace_back(name, *result);
          else if (result.error().code != NotSupported)
            sysInfo.properties.emplace_back(name, result.error());
        },
        [&](const String& name, const Result<OSInfo>& result) -> Unit {
          if (result)
            sysInfo.properties.emplace_back(name, std::format("{} {}", result->name, result->version));
          else
            sysInfo.properties.emplace_back(name, result.error());
        },
        [&](const String& name, const Result<ResourceUsage>& result) -> Unit {
          if (result)
            sysInfo.properties.emplace_back(name, std::format("{} / {}", BytesToGiB(result->usedBytes), BytesToGiB(result->totalBytes)));
          else
            sysInfo.properties.emplace_back(name, result.error());
        },
#if DRAC_ENABLE_NOWPLAYING
        [&](const String& name, const Result<MediaInfo>& result) -> Unit {
          if (result)
            sysInfo.properties.emplace_back(name, std::format("{} - {}", result->title.value_or("Unknown Title"), result->artist.value_or("Unknown Artist")));
          else if (result.error().code == NotFound)
            sysInfo.properties.emplace_back(name, "No media playing");
          else
            sysInfo.properties.emplace_back(name, result.error());
        },
#endif
#if DRAC_ENABLE_WEATHER
        [&](const String& name, const Result<Report>& result) -> Unit {
          if (result)
            sysInfo.properties.emplace_back(name, std::format("{}°F, {}", std::lround(result->temperature), result->description));
          else if (result.error().code == NotFound)
            sysInfo.properties.emplace_back(name, "No weather data available");
          else
            sysInfo.properties.emplace_back(name, result.error());
        },
#endif
      };

      addProperty("OS", GetOperatingSystem(cacheManager));
      addProperty("Kernel Version", GetKernelVersion(cacheManager));
      addProperty("Host", GetHost(cacheManager));
      addProperty("Shell", GetShell(cacheManager));
      addProperty("Desktop Environment", GetDesktopEnvironment(cacheManager));
      addProperty("Window Manager", GetWindowManager(cacheManager));
      addProperty("CPU Model", GetCPUModel(cacheManager));
      addProperty("GPU Model", GetGPUModel(cacheManager));
      addProperty("Memory", GetMemInfo(cacheManager));
      addProperty("Disk Usage", GetDiskUsage(cacheManager));
#if DRAC_ENABLE_NOWPLAYING
      addProperty("Now Playing", GetNowPlaying());
#endif
#if DRAC_ENABLE_WEATHER
      {
        using namespace std::chrono;

        Result<Report> weatherResultToAdd;

        std::unique_lock<std::mutex> lock(GetState().weatherCache.mtx);

        time_point now = steady_clock::now();

        bool needsFetch = true;

        if (GetState().weatherCache.report.has_value() && now - GetState().weatherCache.lastChecked < minutes(10)) {
          info_log("Using cached weather data.");
          weatherResultToAdd = *GetState().weatherCache.report;
          needsFetch         = false;
        }

        if (needsFetch) {
          info_log("Fetching new weather data...");
          if (GetState().weatherService) {
            Result<Report> fetchedReport        = GetState().weatherService->getWeatherInfo();
            GetState().weatherCache.report      = fetchedReport;
            GetState().weatherCache.lastChecked = now;
            weatherResultToAdd                  = fetchedReport;
          } else {
            error_log("Weather service is not initialized. Cannot fetch new data.");
            Result<Report> errorReport          = Err({ ApiUnavailable, "Weather service not initialized" });
            GetState().weatherCache.report      = errorReport;
            GetState().weatherCache.lastChecked = now;
            weatherResultToAdd                  = errorReport;
          }
        }

        lock.unlock();

        addProperty("Weather", weatherResultToAdd);
      }
#endif
    }

    Result<String> htmlTemplate = readFile(indexFile);

    if (!htmlTemplate) {
      error_log("Failed to read HTML template: {}", htmlTemplate.error().message);
      res.status(500).body("Internal Server Error: Template file not found.");
      return;
    }

    if (Result<String, glz::error_ctx> result = glz::stencil(*htmlTemplate, sysInfo))
      res.header("Content-Type", "text/html; charset=utf-8")
        .header("Cache-Control", "no-cache, no-store, must-revalidate")
        .header("Pragma", "no-cache")
        .header("Expires", "0")
        .body(*result);
    else {
      error_log("Failed to render stencil template:\n{}", glz::format_error(result.error(), *htmlTemplate));
      res.status(500).body("Internal Server Error: Template rendering failed.");
    }
  });

  server.bind(port);
  server.start();

  info_log("Server started at http://localhost:{}. Press Ctrl+C to exit.", port);

  {
    using namespace asio;

    io_context signalContext;

    signal_set signals(signalContext, SIGINT, SIGTERM);

    signals.async_wait([&](const error_code& error, i32 signal_number) {
      if (!error) {
        info_log("\nShutdown signal ({}) received. Stopping server...", signal_number);
        server.stop();
        signalContext.stop();
      }
    });

    signalContext.run();
  }

  info_log("Server stopped. Exiting.");
  return EXIT_SUCCESS;
}
</file>

<file path="flake.nix">
{
  description = "C/C++ environment";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    treefmt-nix.url = "github:numtide/treefmt-nix";
    utils.url = "github:numtide/flake-utils";
    devkitNix.url = "github:bandithedoge/devkitNix";
  };

  outputs = {
    self,
    nixpkgs,
    treefmt-nix,
    utils,
    devkitNix,
    ...
  }: let
    inherit (nixpkgs) lib;
  in
    {homeModules.default = import ./nix/module.nix {inherit self;};}
    // utils.lib.eachDefaultSystem (
      system: let
        isLinux = lib.strings.hasInfix "linux" system;

        pkgs = import nixpkgs {
          inherit system;
          overlays = lib.optionals isLinux [devkitNix.overlays.default];
        };

        llvmPackages = pkgs.llvmPackages_20;

        stdenv = with pkgs;
          (
            if hostPlatform.isLinux
            then stdenvAdapters.useMoldLinker
            else lib.id
          )
          llvmPackages.stdenv;

        devShellDeps = with pkgs;
          [
            ((glaze.override {enableAvx2 = hostPlatform.isx86;}).overrideAttrs rec {
              version = "5.5.4";

              src = fetchFromGitHub {
                owner = "stephenberry";
                repo = "glaze";
                tag = "v${version}";
                hash = "sha256-v6/IJlwc+nYgTAn8DJcbRC+qhZtUR6xu45dwm7rueV8=";
              };
            })
            (imgui.override {
              IMGUI_BUILD_GLFW_BINDING = true;
              IMGUI_BUILD_VULKAN_BINDING = true;
            })
            gtest
            vulkan-extension-layer
            vulkan-memory-allocator
            vulkan-utility-libraries
            vulkan-loader
            vulkan-tools
          ]
          ++ (with pkgsStatic; [
            asio
            curl
            libunistring
            magic-enum
            sqlitecpp
            (tomlplusplus.overrideAttrs {
              doCheck = false;
            })
          ])
          ++ darwinPkgs
          ++ linuxPkgs
          ++ lib.optionals isLinux (with pkgs.devkitNix; [
            devkitA64
          ]);

        darwinPkgs = lib.optionals stdenv.isDarwin (with pkgs.pkgsStatic; [
          libiconv
          apple-sdk_15
        ]);

        linuxPkgs = lib.optionals stdenv.isLinux (with pkgs;
          [valgrind]
          ++ (with pkgsStatic; [
            dbus
            pugixml
            xorg.libxcb
            wayland
          ]));

        draconisPkgs = import ./nix ({inherit nixpkgs self system lib;} // lib.optionalAttrs isLinux {inherit devkitNix;});
      in {
        packages = draconisPkgs;
        checks = draconisPkgs;

        devShells.default = pkgs.mkShell.override {inherit stdenv;} {
          packages =
            (with pkgs; [
              alejandra
              bear
              cachix
              cmake
              hyperfine
              llvmPackages.clang-tools
              meson
              ninja
              pkg-config

              (writeScriptBin "build" "meson compile -C build")
              (writeScriptBin "clean" ("meson setup build --wipe -Dprecompiled_config=true" + lib.optionalString pkgs.stdenv.isLinux " -Duse_linked_pci_ids=true"))
              (writeScriptBin "run" "meson compile -C build && build/draconis++")
            ])
            ++ devShellDeps;

          NIX_ENFORCE_NO_NATIVE = 0;

          VULKAN_SDK = "${pkgs.vulkan-headers}";
          VK_LAYER_PATH = "${pkgs.vulkan-validation-layers}/share/vulkan/explicit_layer.d";
          VK_ICD_FILENAMES =
            if stdenv.isDarwin
            then "${pkgs.darwin.moltenvk}/share/vulkan/icd.d/MoltenVK_icd.json"
            else let
              vulkanDir = "${pkgs.mesa}/share/vulkan/icd.d";
              vulkanFiles = builtins.filter (file: builtins.match ".*\\.json$" file != null) (builtins.attrNames (builtins.readDir vulkanDir));
            in
              lib.concatStringsSep ":" (map (file: "${vulkanDir}/${file}") vulkanFiles);

          shellHook =
            lib.optionalString pkgs.stdenv.hostPlatform.isDarwin ''
              export SDKROOT=${pkgs.pkgsStatic.apple-sdk_15}/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk
              export DEVELOPER_DIR=${pkgs.pkgsStatic.apple-sdk_15}
              export LDFLAGS="-L${pkgs.pkgsStatic.libiconvReal}/lib $LDFLAGS"
              export NIX_CFLAGS_COMPILE="-isysroot $SDKROOT"
              export NIX_CXXFLAGS_COMPILE="-isysroot $SDKROOT"
              export NIX_OBJCFLAGS_COMPILE="-isysroot $SDKROOT"
              export NIX_OBJCXXFLAGS_COMPILE="-isysroot $SDKROOT"
            ''
            + lib.optionalString pkgs.stdenv.hostPlatform.isLinux ''
              cp ${pkgs.pciutils}/share/pci.ids pci.ids
              chmod +w pci.ids
              objcopy -I binary -O default pci.ids pci_ids.o
              rm pci.ids
              export DEVKITPRO=${pkgs.devkitNix.devkitA64}/opt/devkitpro
              export PATH=$DEVKITPRO/devkitA64/bin:$PATH
            '';
        };

        formatter = treefmt-nix.lib.mkWrapper pkgs {
          projectRootFile = "flake.nix";
          programs = {
            alejandra.enable = true;
            deadnix.enable = true;
            clang-format = {
              enable = true;
              package = pkgs.llvmPackages.clang-tools;
            };
          };
        };
      }
    );
}
</file>

<file path="include/Drac++/Utils/CacheManager.hpp">
#pragma once

#include <chrono>
#include <filesystem>
#include <glaze/glaze.hpp>

#include "DataTypes.hpp"
#include "Env.hpp"
#include "Logging.hpp"

namespace draconis::utils::cache {
  namespace {
    using types::Fn;
    using types::LockGuard;
    using types::Mutex;
    using types::None;
    using types::Option;
    using types::Pair;
    using types::Result;
    using types::Some;
    using types::String;
    using types::u64;
    using types::u8;
    using types::UniquePointer;
    using types::Unit;
    using types::UnorderedMap;
    using types::Vec;

    using std::chrono::days;
    using std::chrono::duration_cast;
    using std::chrono::seconds;
    using std::chrono::system_clock;

    namespace fs = std::filesystem;
  } // namespace

  enum class CacheLocation : u8 {
    InMemory,      ///< Volatile, lost on app exit. Fastest.
    TempDirectory, ///< Persists until next reboot or system cleanup.
    Persistent     ///< Stored in a user-level cache dir (e.g., ~/.cache).
  };

  struct CachePolicy {
    CacheLocation location = CacheLocation::Persistent;

    Option<seconds> ttl = days(1); ///< Default to 1 day.

    static fn inMemory() -> CachePolicy {
      return { .location = CacheLocation::InMemory, .ttl = None };
    }

    static fn neverExpire() -> CachePolicy {
      return { .location = CacheLocation::Persistent, .ttl = None };
    }

    static fn tempDirectory() -> CachePolicy {
      return { .location = CacheLocation::TempDirectory, .ttl = None };
    }
  };

  class CacheManager {
   public:
    /*!
     * @brief Global flag to bypass all caching logic at runtime.
     *
     * When set to true, getOrSet() will skip both reading from and writing to
     * any cache (in-memory or on-disk) and will directly invoke the provided
     * fetcher each time. This makes it easy for the CLI to offer a
     * "--ignore-cache" option without having to modify every call-site.
     */
    static inline bool ignoreCache = false;

    CacheManager() : m_globalPolicy { .location = CacheLocation::Persistent, .ttl = days(1) } {}

    fn setGlobalPolicy(const CachePolicy& policy) -> Unit {
      LockGuard lock(m_cacheMutex);
      m_globalPolicy = policy;
    }

    template <typename T>
    struct CacheEntry {
      T           data;
      Option<u64> expires; // store as UNIX timestamp (seconds since epoch), None if no expiry
    };

    template <typename T>
    fn getOrSet(
      const String&       key,
      Option<CachePolicy> overridePolicy,
      Fn<Result<T>()>     fetcher
    ) -> Result<T> {
#ifdef DRAC_ENABLE_CACHING
      /* Early-exit if caching is globally disabled for this run. */
      if (ignoreCache)
        return fetcher();

      LockGuard lock(m_cacheMutex);

      const CachePolicy& policy = overridePolicy.value_or(m_globalPolicy);

      // 1. Check in-memory cache
      if (const auto iter = m_inMemoryCache.find(key); iter != m_inMemoryCache.end())
        if (
          CacheEntry<T> entry; glz::read_beve(entry, iter->second.first) == glz::error_code::none &&
          (!entry.expires.has_value() || system_clock::now() < system_clock::time_point(seconds(*entry.expires)))
        )
          return entry.data;

      // 2. Check filesystem cache
      const Option<fs::path> filePath = getCacheFilePath(key, policy.location);

      if (filePath && fs::exists(*filePath)) {
        if (std::ifstream ifs(*filePath, std::ios::binary); ifs) {
          std::string fileContents((std::istreambuf_iterator<char>(ifs)), {});

          CacheEntry<T> entry;

          if (glz::read_beve(entry, fileContents) == glz::error_code::none) {
            if (!entry.expires.has_value() || system_clock::now() < system_clock::time_point(seconds(*entry.expires))) {
              system_clock::time_point expiryTp = entry.expires.has_value() ? system_clock::time_point(seconds(*entry.expires)) : system_clock::time_point::max();

              m_inMemoryCache[key] = { fileContents, expiryTp };

              return entry.data;
            }
          }
        }
      }

      // 3. Cache miss: call fetcher (move the callable to indicate consumption)
      Result<T> fetchedResult = fetcher();

      if (!fetchedResult)
        return fetchedResult;

      // 4. Store in cache
      Option<u64> expiryTs;
      if (policy.ttl.has_value()) {
        system_clock::time_point now        = system_clock::now();
        system_clock::time_point expiryTime = now + *policy.ttl;

        expiryTs = duration_cast<seconds>(expiryTime.time_since_epoch()).count();
      }

      CacheEntry<T> newEntry {
        .data    = *fetchedResult,
        .expires = expiryTs
      };

      std::string binaryBuffer;
      glz::write_beve(newEntry, binaryBuffer);

      system_clock::time_point inMemoryExpiryTp = expiryTs.has_value()
        ? system_clock::time_point(seconds(*expiryTs))
        : system_clock::time_point::max();

      m_inMemoryCache[key] = { binaryBuffer, inMemoryExpiryTp };

      if (policy.location != CacheLocation::InMemory) {
        fs::create_directories(filePath->parent_path());
        std::ofstream ofs(*filePath, std::ios::binary | std::ios::trunc);
        ofs.write(binaryBuffer.data(), static_cast<std::streamsize>(binaryBuffer.size()));
      }

      return fetchedResult;
#else
      (void)key;
      (void)overridePolicy;
      return fetcher();
#endif
    }

    template <typename T>
    fn getOrSet(const String& key, Fn<Result<T>()> fetcher) -> Result<T> {
      return getOrSet(key, None, fetcher);
    }

    /**
     * @brief Remove a cached entry corresponding to the given key.
     *
     * This erases the entry from the in-memory cache and also attempts to
     * remove any corresponding files in the temporary and persistent cache
     * locations (if they exist).
     *
     * @param key Cache key to invalidate.
     */
    fn invalidate(const String& key) -> Unit {
#ifdef DRAC_ENABLE_CACHING
      LockGuard lock(m_cacheMutex);

      // Erase from in-memory cache (no harm if the key is absent).
      m_inMemoryCache.erase(key);

      // Attempt to remove the on-disk copies for both possible locations.
      for (const CacheLocation loc : { CacheLocation::TempDirectory, CacheLocation::Persistent })
        if (const Option<fs::path> filePath = getCacheFilePath(key, loc); filePath && fs::exists(*filePath)) {
          std::error_code errc;
          fs::remove(*filePath, errc);
        }
#else
      (void)key;
#endif
    }

    /**
     * @brief Remove **all** cached data – both in-memory and on-disk.
     *
     * This clears the in-memory cache map and removes all files from the
     * persistent and temporary cache directories while preserving the
     * directory structure.
     */
    fn invalidateAll(bool logRemovals = false) -> u8 {
#ifdef DRAC_ENABLE_CACHING
      LockGuard lock(m_cacheMutex);

      u8 removedCount = 0;

      // Record keys currently present so we can clean their temp-dir copies
      // after we clear the map.
      Vec<String> keys;
      keys.reserve(m_inMemoryCache.size());
      for (const auto& [key, val] : m_inMemoryCache)
        keys.emplace_back(key);

      // Clear in-memory cache.
      m_inMemoryCache.clear();

      // Remove all files from persistent cache directory.
  #ifdef __APPLE__
      const fs::path persistentDir = std::format("{}/Library/Caches/draconis++", draconis::utils::env::GetEnv("HOME").value_or("."));
  #else
      const fs::path persistentDir = std::format("{}/.cache/draconis++", draconis::utils::env::GetEnv("HOME").value_or("."));
  #endif

      if (fs::exists(persistentDir)) {
        std::error_code errc;
        for (const fs::directory_entry& entry : fs::recursive_directory_iterator(persistentDir, errc))
          if (entry.is_regular_file()) {
            fs::remove(entry.path(), errc);
            removedCount++;
            if (logRemovals)
              logging::Println("Removed persistent cache file: {}", entry.path().string());
          }
      }

      // Remove all files from temp directory that match our cache pattern.
      const fs::path tempDir = fs::temp_directory_path();
      if (fs::exists(tempDir)) {
        std::error_code errc;
        for (const fs::directory_entry& entry : fs::directory_iterator(tempDir, errc)) {
          if (entry.is_regular_file()) {
            // Check if this file is one of our cache files by looking at known keys
            // or by checking if it's a file we might have created
            bool shouldRemove = false;

            // Remove files that match our known keys
            for (const String& key : keys)
              if (entry.path().filename() == key) {
                shouldRemove = true;
                break;
              }

            // Also remove any files that might be orphaned cache files
            // (files that don't have extensions and are likely our cache files)
            if (!shouldRemove && entry.path().extension().empty())
              shouldRemove = true;

            if (shouldRemove) {
              fs::remove(entry.path(), errc);
              removedCount++;
              if (logRemovals)
                logging::Println("Removed temp-directory cache file: {}", entry.path().string());
            }
          }
        }
      }

      return removedCount;
#else
      (void)logRemovals;
      return 0;
#endif
    }

   private:
    CachePolicy m_globalPolicy;

    UnorderedMap<String, Pair<String, system_clock::time_point>> m_inMemoryCache;

    Mutex m_cacheMutex;

    static fn getCacheFilePath(const String& key, const CacheLocation location) -> Option<fs::path> {
      using matchit::match, matchit::is, matchit::_;

      Option<fs::path> cacheDir = None;

      if (location == CacheLocation::InMemory)
        return None; // In-memory cache does not have a file path

      if (location == CacheLocation::TempDirectory)
        return Some(fs::temp_directory_path() / key);

      if (location == CacheLocation::Persistent)
#ifdef __APPLE__
        return Some(std::format("{}/Library/Caches/draconis++/{}", draconis::utils::env::GetEnv("HOME").value_or("."), key));
#else
        return Some(std::format("{}/.cache/draconis++/{}", draconis::utils::env::GetEnv("HOME").value_or("."), key));
#endif

      if (cacheDir) {
        fs::create_directories(*cacheDir);
        return *cacheDir / key;
      }

      return None;
    }
  };
} // namespace draconis::utils::cache

namespace glz {
  template <>
  struct meta<draconis::utils::types::OSInfo> {
    using T = draconis::utils::types::OSInfo;

    // clang-format off
    static constexpr detail::Object value = object(
      "name", &T::name,
      "version", &T::version,
      "id", &T::id
    );
    // clang-format on
  };

  template <>
  struct meta<draconis::utils::types::CPUCores> {
    using T = draconis::utils::types::CPUCores;

    static constexpr detail::Object value = object("physical", &T::physical, "logical", &T::logical);
  };

  template <>
  struct meta<draconis::utils::types::NetworkInterface> {
    using T = draconis::utils::types::NetworkInterface;

    // clang-format off
    static constexpr detail::Object value = object(
      "name",        &T::name,
      "isUp",        &T::isUp,
      "isLoopback",  &T::isLoopback,
      "ipv4Address", &T::ipv4Address,
      "macAddress",  &T::macAddress
    );
    // clang-format on
  };

  template <>
  struct meta<draconis::utils::types::DisplayInfo> {
    using T = draconis::utils::types::DisplayInfo;

    // clang-format off
    static constexpr detail::Object value = object(
      "id",          &T::id,
      "resolution",  &T::resolution,
      "refreshRate", &T::refreshRate,
      "isPrimary",   &T::isPrimary
    );
    // clang-format on
  };

  template <>
  struct meta<draconis::utils::types::DisplayInfo::Resolution> {
    using T = draconis::utils::types::DisplayInfo::Resolution;

    static constexpr detail::Object value = object("width", &T::width, "height", &T::height);
  };

  template <typename Tp>
  struct meta<draconis::utils::cache::CacheManager::CacheEntry<Tp>> {
    using T = draconis::utils::cache::CacheManager::CacheEntry<Tp>;

    static constexpr detail::Object value = object("data", &T::data, "expires", &T::expires);
  };
} // namespace glz
</file>

<file path="include/Drac++/Core/System.hpp">
/**
 * @file System.hpp
 * @brief Defines the os::System class, a cross-platform interface for querying system information.
 * @author pupbrained/Draconis
 * @version DRACONISPLUSPLUS_VERSION
 */

#pragma once

#include "../Utils/CacheManager.hpp"
#include "../Utils/DataTypes.hpp"
#include "../Utils/Types.hpp"

namespace draconis::core::system {
  namespace {
    using utils::types::Battery;
    using utils::types::CPUCores;
    using utils::types::DisplayInfo;
    using utils::types::f64;
    using utils::types::Frequencies;
    using utils::types::i64;
    using utils::types::MediaInfo;
    using utils::types::NetworkInterface;
    using utils::types::None;
    using utils::types::Option;
    using utils::types::OSInfo;
    using utils::types::ResourceUsage;
    using utils::types::Result;
    using utils::types::String;
    using utils::types::u64;
    using utils::types::usize;
    using utils::types::Vec;

    using utils::cache::CacheManager;
  } // namespace

  /**
   * @brief Fetches memory information.
   * @return The ResourceUsage struct containing the used and total memory in bytes.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GlobalMemoryStatusEx`
   *  - macOS: `host_statistics64` / `sysctlbyname("hw.memsize")`
   *  - Linux: `sysinfo`
   *  - FreeBSD/DragonFly: `sysctlbyname("hw.physmem")`
   *  - NetBSD: `sysctlbyname("hw.physmem64")`
   *  - Haiku: `get_system_info`
   *  - SerenityOS: Reads from `/sys/kernel/memstat`
   *
   * @warning This function can fail if:
   *  - Windows: `GlobalMemoryStatusEx` fails
   *  - macOS: `host_page_size` fails / `sysctlbyname` returns -1 / `host_statistics64` fails
   *  - Linux: `sysinfo` fails
   *  - FreeBSD/DragonFly: `sysctlbyname` returns -1
   *  - NetBSD: `sysctlbyname` returns -1
   *  - Haiku: `get_system_info` fails
   *  - SerenityOS: `/sys/kernel/memstat` fails to open / `glz::read` fails to parse JSON / `physical_allocated` + `physical_available` overflows
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<ResourceUsage> memInfo = draconis::core::system::GetMemInfo();
   *
   *   if (memInfo.has_value()) {
   *     std::println("Used: {} bytes", memInfo.value().usedBytes);
   *     std::println("Total: {} bytes", memInfo.value().totalBytes);
   *   } else {
   *     std::println("Failed to get memory info: {}", memInfo.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetMemInfo(CacheManager& cache) -> Result<ResourceUsage>;

#if DRAC_ENABLE_NOWPLAYING
  /**
   * @brief Fetches now playing media information.
   * @return The MediaInfo struct containing the title and artist of the currently playing media.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GlobalSystemMediaTransportControlsSessionManager::GetCurrentSession`
   *  - macOS: `MRMediaRemoteGetNowPlayingInfo` (private framework)
   *  - Linux/BSD: `DBus`
   *  - Other: Unsupported
   *
   * @warning This function can fail if:
   *  - Windows: `GlobalSystemMediaTransportControlsSessionManager::GetCurrentSession` fails
   *  - macOS: `MRMediaRemoteGetNowPlayingInfo` fails / `information` is null
   *  - Linux/BSD: Various DBus calls fail
   *  - Other: Unsupported
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<MediaInfo> nowPlaying = draconis::core::system::GetNowPlaying();
   *
   *   if (nowPlaying.has_value()) {
   *     std::println("Now playing: {} - {}", nowPlaying.value().title, nowPlaying.value().artist);
   *   } else {
   *     std::println("Failed to get now playing: {}", nowPlaying.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetNowPlaying() -> Result<MediaInfo>;
#endif

  /**
   * @brief Fetches the OS version.
   * @return The OS version (e.g., "Windows 11", "macOS 26.0 Tahoe", "Ubuntu 24.04.2 LTS", etc.).
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: Reads from `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion`, returns "Windows 11" if `buildNumber >= 22000`
   *  - macOS: Parses `/System/Library/CoreServices/SystemVersion.plist`, matches against a map of known versions
   *  - Linux: Parses `PRETTY_NAME` from `/etc/os-release`
   *  - BSD: Parses `NAME` from `/etc/os-release`, falls back to `uname`
   *  - Haiku: Reads from `/boot/system/lib/libbe.so`
   *  - SerenityOS: `uname`
   *
   * @warning This function can fail if:
   *  - Windows: `RegOpenKeyExW` fails / `productName` is empty
   *  - macOS: Various CF functions fail / `versionNumber` is empty / `versionNumber` is not a valid version number
   *  - Linux: Fails to open `/etc/os-release` / fails to find/parse `PRETTY_NAME`
   *  - BSD: Fails to open `/etc/os-release` / fails to find/parse `NAME` and `uname` returns -1 / `uname` returns empty string
   *  - Haiku: Fails to open `/boot/system/lib/libbe.so` / `BAppFileInfo::SetTo` fails / `appInfo.GetVersionInfo` fails / `versionShortString` is empty
   *  - SerenityOS: `uname` returns -1
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> osVersion = draconis::core::system::GetOSVersion();
   *
   *   if (osVersion.has_value()) {
   *     std::println("OS version: {}", osVersion.value());
   *   } else {
   *     std::println("Failed to get OS version: {}", osVersion.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetOperatingSystem(CacheManager& cache) -> Result<OSInfo>;

  /**
   * @brief Fetches the desktop environment.
   * @return The desktop environment (e.g., "KDE", "Aqua", "Fluent (Windows 11)", etc.).
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: UI design language based on build number in `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber`
   *  - macOS: Hardcoded to "Aqua"
   *  - Haiku: Hardcoded to "Haiku Desktop Environment"
   *  - SerenityOS: Hardcoded to "SerenityOS Desktop"
   *  - Other: `XDG_CURRENT_DESKTOP` environment variable, falls back to `DESKTOP_SESSION` environment variable
   *
   * @warning This function can fail if:
   *  - Windows: `RegOpenKeyExW` fails / `buildStr` is empty / `stoi` fails
   *  - macOS/Haiku/SerenityOS: N/A (hardcoded)
   *  - Other: `GetEnv` fails
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> desktopEnv = draconis::core::system::GetDesktopEnvironment();
   *
   *   if (desktopEnv.has_value()) {
   *     std::println("Desktop environment: {}", desktopEnv.value());
   *   } else {
   *     std::println("Failed to get desktop environment: {}", desktopEnv.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetDesktopEnvironment(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the window manager.
   * @return The window manager (e.g, "KWin", "yabai", "DWM", etc.).
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: "DWM" (if `DwmIsCompositionEnabled` succeeds) / "Windows Manager (Basic)" (if `DwmIsCompositionEnabled` fails)
   *  - macOS: Checks for known window managers in the process tree, falls back to "Quartz"
   *  - Haiku: Hardcoded to "app_server"
   *  - SerenityOS: Hardcoded to "WindowManager"
   *  - Other: Gets X11 or Wayland window manager depending on whether `WAYLAND_DISPLAY` or `DISPLAY` is set
   *
   * @warning This function can fail if:
   *  - Windows: `DwmIsCompositionEnabled` fails
   *  - macOS: `sysctl` returns -1, zero length, or a size that is not a multiple of `kinfo_proc` size / `Capitalize` fails
   *  - Haiku/SerenityOS: N/A (hardcoded)
   *  - Other: If DRAC_ENABLE_X11/DRAC_ENABLE_WAYLAND are disabled / `GetX11WindowManager`/`GetWaylandCompositor` fails
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> windowMgr = draconis::core::system::GetWindowManager();
   *
   *   if (windowMgr.has_value()) {
   *     std::println("Window manager: {}", windowMgr.value());
   *   } else {
   *     std::println("Failed to get window manager: {}", windowMgr.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetWindowManager(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the shell.
   * @return The active shell (e.g., "zsh", "bash", "fish", etc.).
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `MSYSTEM` variable / `SHELL` variable / `LOGINSHELL` variable / process tree
   *  - SerenityOS: `getpwuid`
   *  - Other: `SHELL` variable
   *
   * @warning This function can fail if:
   *  - Windows: None of `MSYSTEM` / `SHELL` / `LOGINSHELL` variables are set and process tree check fails
   *  - SerenityOS: `pw` is null / `pw_shell` is null or empty
   *  - Other: `SHELL` variable is not set
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> shell = draconis::core::system::GetShell();
   *
   *   if (shell.has_value()) {
   *     std::println("Shell: {}", shell.value());
   *   } else {
   *     std::println("Failed to get shell: {}", shell.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetShell(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the host.
   * @return The host (or hostname if the platform doesn't support the former).
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: Reads from `HKEY_LOCAL_MACHINE\SYSTEM\HardwareConfig\Current`
   *  - macOS: `sysctlbyname("hw.model")` - matched against a flat_map of known models
   *  - Linux: Reads from `/sys/class/dmi/id/product_family`, falls back to `/sys/class/dmi/id/product_name`
   *  - FreeBSD/DragonFly: `kenv smbios.system.product`, falls back to `sysctlbyname("hw.model")`
   *  - NetBSD: `sysctlbyname("machdep.dmi.system-product")`
   *  - Haiku: `gethostname`
   *  - SerenityOS: `gethostname`
   *
   * @warning This function can fail if:
   *  - Windows: `RegOpenKeyExW` fails
   *  - macOS: `sysctlbyname` returns -1 / model not found in known models
   *  - Linux: `/sys/class/dmi/id/product_family` and `/sys/class/dmi/id/product_name` fail to read
   *  - FreeBSD/DragonFly: `kenv` returns -1 and `sysctlbyname` returns -1 / empty string
   *  - NetBSD: `sysctlbyname` returns -1
   *  - Haiku: `gethostname` returns non-zero
   *  - SerenityOS: `gethostname` returns non-zero
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> host = draconis::core::system::GetHost();
   *
   *   if (host.has_value()) {
   *     std::println("Host: {}", host.value());
   *   } else {
   *     std::println("Failed to get host: {}", host.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetHost(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the CPU model.
   * @return The CPU model (e.g., "Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz").
   *
   * @details Obtained differently depending on the platform and architecture:
   *  - Windows: `__cpuid` (x86) / `RegQueryValueExW` (arm64)
   *  - macOS: `sysctlbyname("machdep.cpu.brand_string")`
   *  - Linux: `__get_cpuid` (x86) / `/proc/cpuinfo` (arm64)
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `__cpuid` fails (x86) / `RegOpenKeyExW` fails (arm64)
   *  - macOS: `sysctlbyname` fails
   *  - Linux: `__get_cpuid` fails (x86) / `/proc/cpuinfo` is empty (arm64)
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> cpuModel = draconis::core::system::GetCPUModel();
   *
   *   if (cpuModel.has_value()) {
   *     std::println("CPU model: {}", cpuModel.value());
   *   } else {
   *     std::println("Failed to get CPU model: {}", cpuModel.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetCPUModel(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the number of physical and logical cores on the CPU.
   * @return The CPUCores struct containing the number of physical and logical cores.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetLogicalProcessorInformation`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetLogicalProcessorInformation` fails
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<CPUCores> cpuCores = draconis::core::system::GetCPUCores();
   *
   *   if (cpuCores.has_value()) {
   *     std::println("Physical cores: {}", cpuCores.value().physical);
   *     std::println("Logical cores: {}", cpuCores.value().logical);
   *   } else {
   *     std::println("Failed to get CPU cores: {}", cpuCores.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetCPUCores(CacheManager& cache) -> Result<CPUCores>;

  /**
   * @brief Fetches the GPU model.
   * @return The GPU model (e.g., "NVIDIA GeForce RTX 3070").
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: DXGI
   *  - macOS: Metal
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `CreateDXGIFactory` / `pFactory->EnumAdapters` / `pAdapter->GetDesc` fails
   *  - macOS: `MTLCreateSystemDefaultDevice` fails / `device.name` is null
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> gpuModel = draconis::core::system::GetGPUModel();
   *
   *   if (gpuModel.has_value()) {
   *     std::println("GPU model: {}", gpuModel.value());
   *   } else {
   *     std::println("Failed to get GPU model: {}", gpuModel.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetGPUModel(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the kernel version.
   * @return The kernel version (e.g., "6.14.4").
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: "10.0.22000" (From `KUSER_SHARED_DATA`)
   *  - macOS: "22.3.0" (`sysctlbyname("kern.osrelease")`)
   *  - Haiku: "1" (`get_system_info`)
   *  - Other Unix-like systems: "6.14.4" (`uname`)
   *
   * @warning This function can fail if:
   *  - Windows: `kuserSharedData` fails to parse / `__try` fails
   *  - macOS: `sysctlbyname` returns -1
   *  - Haiku: `get_system_info` returns anything other than `B_OK`
   *  - Other Unix-like systems: `uname` returns -1 / `uname` returns empty string
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<String> kernelVersion = draconis::core::system::GetKernelVersion();
   *
   *   if (kernelVersion.has_value()) {
   *     std::println("Kernel version: {}", kernelVersion.value());
   *   } else {
   *     std::println("Failed to get kernel version: {}", kernelVersion.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetKernelVersion(CacheManager& cache) -> Result<String>;

  /**
   * @brief Fetches the disk usage.
   * @return The ResourceUsage struct containing the used and total disk space in bytes.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetDiskFreeSpaceExW`
   *  - Other: `statvfs`
   *
   * @warning This function can fail if:
   *  - Windows: `GetDiskFreeSpaceExW` fails
   *  - Other: `statvfs` returns -1
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<ResourceUsage> diskUsage = draconis::core::system::GetDiskUsage();
   *
   *   if (diskUsage.has_value()) {
   *     std::println("Used: {} bytes", diskUsage.value().usedBytes);
   *     std::println("Total: {} bytes", diskUsage.value().totalBytes);
   *   } else {
   *     std::println("Failed to get disk usage: {}", diskUsage.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetDiskUsage(CacheManager& cache) -> Result<ResourceUsage>;

  /**
   * @brief Fetches the uptime.
   * @return The uptime in seconds.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetTickCount64`
   *  - macOS: `sysctlbyname("kern.boottime")`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetTickCount64` fails
   *  - macOS: `sysctlbyname` returns -1
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<std::chrono::seconds> uptime = draconis::core::system::GetUptime();
   *
   *   if (uptime.has_value()) {
   *     std::println("Uptime: {} seconds", uptime.value().count());
   *   } else {
   *     std::println("Failed to get uptime: {}", uptime.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetUptime() -> Result<std::chrono::seconds>;

  /**
   * @brief Fetches the outputs.
   * @return The outputs.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetDisplayConfigBufferSizes`
   *  - macOS: `CGGetActiveDisplayList`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetDisplayConfigBufferSizes` fails
   *  - macOS: `CGGetActiveDisplayList` fails
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<Vec<DisplayInfo>> outputs = draconis::core::system::GetOutputs();
   *
   *   if (outputs.has_value()) {
   *     std::println("Outputs: {}", outputs.value().size());
   *   } else {
   *     std::println("Failed to get outputs: {}", outputs.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetOutputs(CacheManager& cache) -> Result<Vec<DisplayInfo>>;

  /**
   * @brief Fetches the primary output.
   * @return The primary output.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetDisplayConfigBufferSizes`
   *  - macOS: `CGGetActiveDisplayList`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetDisplayConfigBufferSizes` fails
   *  - macOS: `CGGetActiveDisplayList` fails
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<DisplayInfo> primaryOutput = draconis::core::system::GetPrimaryOutput();
   *
   *   if (primaryOutput.has_value()) {
   *     std::println("Primary output: {}", primaryOutput.value().name);
   *   } else {
   *     std::println("Failed to get primary output: {}", primaryOutput.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetPrimaryOutput(CacheManager& cache) -> Result<DisplayInfo>;

  /**
   * @brief Fetches the network interfaces.
   * @return The network interfaces.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetAdaptersAddresses`
   *  - macOS: `getifaddrs`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetAdaptersAddresses` fails
   *  - macOS: `getifaddrs` fails
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<Vec<NetworkInterface>> networkInterfaces = draconis::core::system::GetNetworkInterfaces();
   *
   *   if (networkInterfaces.has_value()) {
   *     std::println("Network interfaces: {}", networkInterfaces.value().size());
   *   } else {
   *     std::println("Failed to get network interfaces: {}", networkInterfaces.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetNetworkInterfaces(CacheManager& cache) -> Result<Vec<NetworkInterface>>;

  /**
   * @brief Fetches the primary network interface.
   * @return The primary network interface.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetAdaptersAddresses`
   *  - macOS: `getifaddrs`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetAdaptersAddresses` fails
   *  - macOS: `getifaddrs` fails
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<NetworkInterface> primaryNetworkInterface = draconis::core::system::GetPrimaryNetworkInterface();
   *
   *   if (primaryNetworkInterface.has_value()) {
   *     std::println("Primary network interface: {}", primaryNetworkInterface.value().name);
   *   } else {
   *     std::println("Failed to get primary network interface: {}", primaryNetworkInterface.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetPrimaryNetworkInterface(CacheManager& cache) -> Result<NetworkInterface>;

  /**
   * @brief Fetches the battery information.
   * @return The battery information.
   *
   * @details Obtained differently depending on the platform:
   *  - Windows: `GetSystemPowerStatus`
   *  - macOS: `IOPSGetPowerSourceState`
   *  - Other: To be implemented
   *
   * @warning This function can fail if:
   *  - Windows: `GetSystemPowerStatus` fails
   *  - macOS: `IOPSGetPowerSourceState` fails
   *  - Other: To be implemented
   *
   * @code{.cpp}
   * #include <print>
   * #include <Drac++/Core/System.hpp>
   *
   * int main() {
   *   Result<Battery> batteryInfo = draconis::core::system::GetBatteryInfo();
   *
   *   if (batteryInfo.has_value()) {
   *     std::println("Battery info: {}", batteryInfo.value().name);
   *   } else {
   *     std::println("Failed to get battery info: {}", batteryInfo.error().message());
   *   }
   *
   *   return 0;
   * }
   * @endcode
   */
  fn GetBatteryInfo(CacheManager& cache) -> Result<Battery>;

#ifdef __linux__
  namespace linux {
    /**
     * @brief Fetches the distro ID.
     * @return The distro ID.
     *
     * @details Obtained from /etc/os-release.
     */
    fn GetDistroID(CacheManager& cache) -> Result<String>;
  } // namespace linux
#endif
} // namespace draconis::core::system
</file>

<file path="src/CLI/Core/SystemInfo.cpp">
#include "SystemInfo.hpp"

#include <Drac++/Core/System.hpp>

#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#include "Config/Config.hpp"

namespace draconis::core::system {
  namespace {
    using draconis::config::Config;
    using namespace draconis::utils::types;

    using draconis::utils::error::DracError;
    using enum draconis::utils::error::DracErrorCode;

    fn GetDate() -> Result<String> {
      using std::chrono::system_clock;

      const system_clock::time_point nowTp = system_clock::now();
      const std::time_t              nowTt = system_clock::to_time_t(nowTp);

      std::tm nowTm;

#ifdef _WIN32
      if (localtime_s(&nowTm, &nowTt) == 0) {
#else
      if (localtime_r(&nowTt, &nowTm) != nullptr) {
#endif
        i32 day = nowTm.tm_mday;

        String monthBuffer(32, '\0');

        if (const usize monthLen = std::strftime(monthBuffer.data(), monthBuffer.size(), "%B", &nowTm); monthLen > 0) {
          using matchit::match, matchit::is, matchit::_, matchit::in;

          monthBuffer.resize(monthLen);

          PCStr suffix = match(day)(
            is | in(11, 13)    = "th",
            is | (_ % 10 == 1) = "st",
            is | (_ % 10 == 2) = "nd",
            is | (_ % 10 == 3) = "rd",
            is | _             = "th"
          );

          return std::format("{} {}{}", monthBuffer, day, suffix);
        }

        ERR(ParseError, "Failed to format date");
      }

      ERR(ParseError, "Failed to get local time");
    }
  } // namespace

  SystemInfo::SystemInfo(utils::cache::CacheManager& cache, const Config& config) {
    // I'm not sure if AMD uses trademark symbols in their CPU models, but I know
    // Intel does. Might as well replace them with their unicode counterparts.
    auto replaceTrademarkSymbols = [](Result<String> str) -> Result<String> {
      if (!str)
        ERR_FROM(str.error());

      usize pos = 0;

      while ((pos = str->find("(TM)")) != String::npos)
        str->replace(pos, 4, "™");

      while ((pos = str->find("(R)")) != String::npos)
        str->replace(pos, 3, "®");

      return str;
    };

    this->desktopEnv      = GetDesktopEnvironment(cache);
    this->windowMgr       = GetWindowManager(cache);
    this->operatingSystem = GetOperatingSystem(cache);
    this->kernelVersion   = GetKernelVersion(cache);
    this->host            = GetHost(cache);
    this->cpuModel        = replaceTrademarkSymbols(GetCPUModel(cache));
    this->cpuCores        = GetCPUCores(cache);
    this->gpuModel        = GetGPUModel(cache);
    this->shell           = GetShell(cache);
    this->memInfo         = GetMemInfo(cache);
    this->diskUsage       = GetDiskUsage(cache);
    this->uptime          = GetUptime();
    this->date            = GetDate();

#if DRAC_ENABLE_PACKAGECOUNT
    this->packageCount = draconis::services::packages::GetTotalCount(cache, config.enabledPackageManagers);
#endif

#if DRAC_ENABLE_NOWPLAYING
    this->nowPlaying = config.nowPlaying.enabled ? GetNowPlaying() : Err(DracError(ApiUnavailable, "Now Playing API disabled"));
#endif
  }
} // namespace draconis::core::system
</file>

<file path="src/Lib/OS/Windows.cpp">
/**
 * @file   Windows.cpp
 * @author pupbrained (mars@pupbrained.dev)
 * @brief  Provides the Windows-specific implementation of the System class for system information retrieval.
 *
 * @details This file contains the concrete implementation of the System class interface for the
 * Microsoft Windows platform. It retrieves a wide range of system information by
 * leveraging various Windows APIs, including:
 * - Standard Win32 API for memory, disk, and process information.
 * - Windows Registry for OS version, host model, and CPU details.
 * - DirectX Graphics Infrastructure (DXGI) for enumerating graphics adapters.
 * - Windows Runtime (WinRT) for modern OS details, media controls, and WinGet packages.
 *
 * To optimize performance, the implementation caches process snapshots and registry
 * handles. Wide strings are used for all string operations to avoid the overhead of
 * converting between UTF-8 and UTF-16 until the final result is needed.
 *
 * @see draconis::core::system
 */

#ifdef _WIN32

  #include <dxgi.h>                                 // IDXGIFactory, IDXGIAdapter, DXGI_ADAPTER_DESC
  #include <ranges>                                 // std::ranges::find_if, std::ranges::views::transform
  #include <sysinfoapi.h>                           // GetLogicalProcessorInformationEx, RelationProcessorCore, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, KAFFINITY
  #include <tlhelp32.h>                             // CreateToolhelp32Snapshot, PROCESSENTRY32W, Process32FirstW, Process32NextW, TH32CS_SNAPPROCESS
  #include <winerror.h>                             // DXGI_ERROR_NOT_FOUND, ERROR_FILE_NOT_FOUND, FAILE
  #include <winrt/Windows.Foundation.Collections.h> // winrt::Windows::Foundation::Collections::Map
  #include <winrt/Windows.Management.Deployment.h>  // winrt::Windows::Management::Deployment::PackageManager
  #include <winrt/Windows.Media.Control.h>          // winrt::Windows::Media::Control::MediaProperties
  #include <winrt/Windows.System.Profile.h>         // winrt::Windows::System::Profile::AnalyticsInfo
  #include <winuser.h>                              // EnumDisplayMonitors, GetMonitorInfoW, MonitorFromWindow, EnumDisplaySettingsW

  // Core Winsock headers
  #include <winsock2.h> // AF_INET, AF_UNSPEC, sockaddr_in
  #include <ws2tcpip.h> // inet_ntop, inet_pton

  // IP Helper API headers
  #include <iphlpapi.h> // GetAdaptersAddresses, GetBestRoute
  #include <iptypes.h>  // GAA_FLAG_INCLUDE_PREFIX, IP_ADAPTER_ADDRESSES, IP_ADAPTER_UNICAST_ADDRESS

  #include "Drac++/Core/System.hpp"

  #if DRAC_ENABLE_PACKAGECOUNT
    #include "Drac++/Services/Packages.hpp"
  #endif

  #include "Drac++/Utils/CacheManager.hpp"
  #include "Drac++/Utils/Env.hpp"
  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Types.hpp"

namespace {
  using draconis::utils::error::DracError;
  using enum draconis::utils::error::DracErrorCode;
  using namespace draconis::utils::types;
  using draconis::utils::cache::CacheManager;

  namespace constants {
    // Registry keys for Windows version information
    constexpr PWCStr PRODUCT_NAME    = L"ProductName";
    constexpr PWCStr DISPLAY_VERSION = L"DisplayVersion";
    constexpr PWCStr SYSTEM_FAMILY   = L"SystemFamily";

    // clang-format off
    constexpr Array<Pair<StringView, StringView>, 5> windowsShellMap = {{
      {      "cmd",     "Command Prompt" },
      { "powershell",       "PowerShell" },
      {       "pwsh",  "PowerShell Core" },
      {         "wt", "Windows Terminal" },
      {   "explorer", "Windows Explorer" },
    }};

    constexpr Array<Pair<StringView, StringView>, 7> msysShellMap = {{
      { "bash",      "Bash" },
      {  "zsh",       "Zsh" },
      { "fish",      "Fish" },
      {   "sh",        "sh" },
      {  "ksh", "KornShell" },
      { "tcsh",      "tcsh" },
      { "dash",      "dash" },
    }};

    constexpr Array<Pair<StringView, StringView>, 4> windowManagerMap = {{
      {     "glazewm",   "GlazeWM" },
      {    "komorebi",  "Komorebi" },
      {   "seelen-ui", "Seelen UI" },
      { "slu-service", "Seelen UI" },
    }};
    // clang-format on
  } // namespace constants

  namespace helpers {
    fn ConvertWStringToUTF8(const WString& wstr) -> Result<String> {
      // Likely best to just return an empty string if an empty wide string is provided.
      if (wstr.empty())
        return String {};

      // First call WideCharToMultiByte to get the buffer size...
      const i32 sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), nullptr, 0, nullptr, nullptr);

      if (sizeNeeded == 0)
        ERR_FMT(InternalError, "Failed to get buffer size for UTF-8 conversion. Error code: {}", GetLastError());

      // Then make the buffer using that size...
      String result(sizeNeeded, 0);

      // ...and finally call WideCharToMultiByte again to convert the wide string to UTF-8.
      const i32 bytesConverted =
        WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), static_cast<int>(wstr.length()), result.data(), sizeNeeded, nullptr, nullptr);

      if (bytesConverted == 0)
        ERR_FMT(InternalError, "Failed to convert wide string to UTF-8. Error code: {}", GetLastError());

      return result;
    }

    fn GetDirCount(const WString& path) -> Result<u64> {
      // Create mutable copy and append wildcard.
      WString searchPath(path);
      searchPath.append(L"\\*");

      // Used to receive information about the found file or directory.
      WIN32_FIND_DATAW findData;

      // Begin searching for files and directories.
      HANDLE hFind = FindFirstFileW(searchPath.c_str(), &findData);

      if (hFind == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
          return 0;

        ERR(IoError, "FindFirstFileW failed");
      }

      u64 count = 0;

      while (hFind != INVALID_HANDLE_VALUE) {
        // Only increment if the found item is:
        // 1. a directory
        // 2. not a special directory (".", "..")
        if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (wcscmp(findData.cFileName, L".") != 0 && wcscmp(findData.cFileName, L"..") != 0))
          count++;

        // Continue searching for more files and directories.
        if (!FindNextFileW(hFind, &findData))
          break;
      }

      // Ensure that the handle is closed to avoid leaks.
      FindClose(hFind);

      return count;
    }

    // Reads a registry value into a WString.
    fn GetRegistryValue(const HKEY& hKey, const WString& valueName) -> Result<WString> {
      // Buffer for storing the registry value. Should be large enough to hold most values.
      Array<WCStr, 1024> registryBuffer {};

      // Size of the buffer in bytes.
      DWORD dataSizeInBytes = registryBuffer.size() * sizeof(WCStr);

      // Stores the type of the registry value.
      DWORD type = 0;

      // Query the registry value.
      if (const LSTATUS status = RegQueryValueExW(
            hKey,
            valueName.c_str(),
            nullptr,
            &type,
            // NOLINTNEXTLINE(*-pro-type-reinterpret-cast) - reinterpret_cast is required to convert the buffer to a byte array.
            reinterpret_cast<LPBYTE>(registryBuffer.data()),
            &dataSizeInBytes
          );
          FAILED(status)) {
        if (status == ERROR_FILE_NOT_FOUND)
          ERR(NotFound, "Registry value not found");

        if (status == ERROR_ACCESS_DENIED)
          ERR(PermissionDenied, "Permission denied while reading registry value");

        ERR_FMT(PlatformSpecific, "RegQueryValueExW failed with error code: {}", status);
      }

      // Ensure the retrieved value is a string.
      if (type == REG_SZ || type == REG_EXPAND_SZ)
        return WString(registryBuffer.data());

      ERR_FMT(ParseError, "Registry value exists but is not a string type. Type is: {}", type);
    }

  } // namespace helpers

  namespace cache {
    // Caches registry values, allowing them to only be retrieved once.
    class RegistryCache {
      HKEY m_currentVersionKey = nullptr;
      HKEY m_hardwareConfigKey = nullptr;

      RegistryCache() {
        if (FAILED(RegOpenKeyExW(HKEY_LOCAL_MACHINE, LR"(SOFTWARE\Microsoft\Windows NT\CurrentVersion)", 0, KEY_READ, &m_currentVersionKey)))
          m_currentVersionKey = nullptr;

        if (FAILED(RegOpenKeyExW(HKEY_LOCAL_MACHINE, LR"(SYSTEM\HardwareConfig\Current)", 0, KEY_READ, &m_hardwareConfigKey)))
          m_hardwareConfigKey = nullptr;
      }

      ~RegistryCache() {
        if (m_currentVersionKey)
          RegCloseKey(m_currentVersionKey);

        if (m_hardwareConfigKey)
          RegCloseKey(m_hardwareConfigKey);
      }

     public:
      static fn getInstance() -> const RegistryCache& {
        static RegistryCache Instance;
        return Instance;
      }

      [[nodiscard]] fn getCurrentVersionKey() const -> HKEY {
        return m_currentVersionKey;
      }

      [[nodiscard]] fn getHardwareConfigKey() const -> HKEY {
        return m_hardwareConfigKey;
      }

      RegistryCache(const RegistryCache&)                = delete;
      RegistryCache(RegistryCache&&)                     = delete;
      fn operator=(const RegistryCache&)->RegistryCache& = delete;
      fn operator=(RegistryCache&&)->RegistryCache&      = delete;
    };

    // Caches OS version data for use in other functions.
    class OsVersionCache {
     public:
      struct VersionData {
        u32 majorVersion;
        u32 minorVersion;
        u32 buildNumber;
      };

      static fn getInstance() -> const OsVersionCache& {
        static OsVersionCache Instance;
        return Instance;
      }

      fn getVersionData() const -> const Result<VersionData>& {
        return m_versionData;
      }

      fn getBuildNumber() const -> Result<u64> {
        if (!m_versionData)
          ERR_FROM(m_versionData.error());

        return static_cast<u64>(m_versionData->buildNumber);
      }

      OsVersionCache(const OsVersionCache&)                = delete;
      OsVersionCache(OsVersionCache&&)                     = delete;
      fn operator=(const OsVersionCache&)->OsVersionCache& = delete;
      fn operator=(OsVersionCache&&)->OsVersionCache&      = delete;

     private:
      Result<VersionData> m_versionData;

      // Fetching version data from KUSER_SHARED_DATA is the fastest way to get the version information.
      // It also avoids the need for a system call or registry access. The biggest downside, though, is
      // that it's inherently risky/unsafe, and could break in future updates. To mitigate this risk,
      // this constructor uses SEH (__try/__except) to handle potential exceptions and safely error out.
      OsVersionCache() {
        // KUSER_SHARED_DATA is a block of memory shared between the kernel and user-mode
        // processes. This address has not changed since its inception. It SHOULD always
        // contain data for the running Windows version.
        constexpr ULONG_PTR kuserSharedData = 0x7FFE0000;

        // These offsets should also be static/consistent across different versions of Windows.
        constexpr u32 kuserSharedNtMajorVersion = kuserSharedData + 0x26C;
        constexpr u32 kuserSharedNtMinorVersion = kuserSharedData + 0x270;
        constexpr u32 kuserSharedNtBuildNumber  = kuserSharedData + 0x260;

        // Considering this file is windows-specific, it's fine to use windows-specific extensions.
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wlanguage-extension-token"
        // Use Structured Exception Handling (SEH) to safely read the version data. In case of invalid
        // pointers, this will catch the access violation and return an Error, instead of crashing.
        __try {
          // Read the version data directly from the calculated memory addresses.
          // - reinterpret_cast is required to cast the memory addresses to volatile pointers.
          // - `volatile` tells the compiler that these memory reads should not be optimized away.
          m_versionData = VersionData {
            // NOLINTBEGIN(*-pro-type-reinterpret-cast, *-no-int-to-ptr)
            .majorVersion = *reinterpret_cast<const volatile u32*>(kuserSharedNtMajorVersion),
            .minorVersion = *reinterpret_cast<const volatile u32*>(kuserSharedNtMinorVersion),
            .buildNumber  = *reinterpret_cast<const volatile u32*>(kuserSharedNtBuildNumber)
            // NOLINTEND(*-pro-type-reinterpret-cast, *-no-int-to-ptr)
          };
        } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
          // If an access violation occurs, then the shared memory couldn't be properly read.
          // Set the version data to an error instead of crashing.
          m_versionData = Err(DracError(InternalError, "Failed to read kernel version from KUSER_SHARED_DATA"));
        }
  #pragma clang diagnostic pop
      }

      ~OsVersionCache() = default;
    };

    // Captures a process tree and stores it for later reuse.
    class ProcessTreeCache {
     public:
      struct Data {
        DWORD  parentPid = 0;
        String baseExeNameLower;
      };

      static fn getInstance() -> ProcessTreeCache& {
        static ProcessTreeCache Instance;
        return Instance;
      }

      fn initialize() -> Result<> {
        // Ensure exclusive access to the initialization process.
        LockGuard lock(m_initMutex);

        // Prevent wasteful re-initialization if the cache is already populated.
        if (m_initialized)
          return {};

        // Use the Toolhelp32Snapshot API to get a snapshot of all running processes.
        HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnap == INVALID_HANDLE_VALUE)
          ERR(ApiUnavailable, "Failed to create snapshot of processes");

        // This structure must be initialized with its own size before use; it's a WinAPI requirement.
        PROCESSENTRY32W pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32W);

        // Iterate through all processes captured in the snapshot.
        for (BOOL ok = Process32FirstW(hSnap, &pe32); ok; ok = Process32NextW(hSnap, &pe32)) {
          WStringView exeFileView(pe32.szExeFile);

          const usize lastSlashPos = exeFileView.find_last_of(L"\\/");
          const usize start        = (lastSlashPos == WStringView::npos) ? 0 : lastSlashPos + 1;

          const usize lastDotPos = exeFileView.find_last_of(L'.');
          const usize end        = (lastDotPos == WStringView::npos || lastDotPos < start) ? exeFileView.length() : lastDotPos;

          WStringView stemView = exeFileView.substr(start, end - start);

          WString baseName(stemView);
          std::ranges::transform(baseName, baseName.begin(), [](const WCStr character) { return towlower(character); });

          const Result<String> baseNameUTF8 = helpers::ConvertWStringToUTF8(baseName);

          if (!baseNameUTF8)
            continue;

          m_processMap[pe32.th32ProcessID] = Data { .parentPid = pe32.th32ParentProcessID, .baseExeNameLower = *baseNameUTF8 };
        }

        // Ensure that the handle is closed to avoid leaks.
        CloseHandle(hSnap);
        m_initialized = true;

        return {};
      }

      fn getProcessMap() const -> const std::unordered_map<DWORD, Data>& {
        return m_processMap;
      }

      ProcessTreeCache(const ProcessTreeCache&)                = delete;
      ProcessTreeCache(ProcessTreeCache&&)                     = delete;
      fn operator=(const ProcessTreeCache&)->ProcessTreeCache& = delete;
      fn operator=(ProcessTreeCache&&)->ProcessTreeCache&      = delete;

     private:
      std::unordered_map<DWORD, Data> m_processMap;
      bool                            m_initialized = false;
      Mutex                           m_initMutex;

      ProcessTreeCache()  = default;
      ~ProcessTreeCache() = default;
    };
  } // namespace cache

  namespace shell {
    template <usize sz>
    fn FindShellInProcessTree(const DWORD startPid, const Array<Pair<StringView, StringView>, sz>& shellMap) -> Result<String> {
      using cache::ProcessTreeCache;

      // PID 0 (System Idle Process) is always the root process, and cannot have a parent.
      if (startPid == 0)
        ERR(InvalidArgument, "Start PID cannot be 0");

      if (const Result<> initialized = ProcessTreeCache::getInstance().initialize(); !initialized)
        ERR_FROM(initialized.error());

      const UnorderedMap<DWORD, ProcessTreeCache::Data>& processMap = ProcessTreeCache::getInstance().getProcessMap();

      DWORD currentPid = startPid;

      // This is a pretty reasonable depth and should cover most cases without excessive recursion.
      constexpr i32 maxDepth = 16;

      i32 depth = 0;

      while (currentPid != 0 && depth < maxDepth) {
        auto procIt = processMap.find(currentPid);
        if (procIt == processMap.end())
          break;

        // Get the lowercase name of the process.
        const String& processName = procIt->second.baseExeNameLower;

        // Check if the process name matches any shell in the map,
        // and return its friendly-name counterpart if it is.
        if (const auto mapIter =
              std::ranges::find_if(shellMap, [&](const Pair<StringView, StringView>& pair) { return StringView { processName } == pair.first; });
            mapIter != std::ranges::end(shellMap))
          return String(mapIter->second);

        // Move up the tree to the parent process.
        currentPid = procIt->second.parentPid;
        depth++;
      }

      ERR(NotFound, "Shell not found");
    }
  } // namespace shell
} // namespace

namespace draconis::core::system {
  using namespace cache;
  using namespace constants;
  using namespace helpers;

  fn GetMemInfo(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    // Passed to GlobalMemoryStatusEx to retrieve memory information.
    // dwLength is required to be set as per WinAPI.
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);

    if (GlobalMemoryStatusEx(&memInfo))
      return ResourceUsage(memInfo.ullTotalPhys - memInfo.ullAvailPhys, memInfo.ullTotalPhys);

    ERR_FMT(ApiUnavailable, "GlobalMemoryStatusEx failed with error code {}", GetLastError());
  }

  #if DRAC_ENABLE_NOWPLAYING
  fn GetNowPlaying() -> Result<MediaInfo> {
    // WinRT makes HEAVY use of namespaces and has very long names for
    // structs and classes, so its easier to alias most things.
    using namespace winrt::Windows::Media::Control;
    using namespace winrt::Windows::Foundation;

    using Session         = GlobalSystemMediaTransportControlsSession;
    using SessionManager  = GlobalSystemMediaTransportControlsSessionManager;
    using MediaProperties = GlobalSystemMediaTransportControlsSessionMediaProperties;

    try {
      // WinRT provides a nice easy way to get the current media session.
      // AFAIK, there's no other way to easily get the current media session on Windows.

      // getNowPlaying() isn't async, so we just RequestAsync() and immediately get() the result.
      const SessionManager sessionManager = SessionManager::RequestAsync().get();

      if (const Session currentSession = sessionManager.GetCurrentSession()) {
        const MediaProperties mediaProperties = currentSession.TryGetMediaPropertiesAsync().get();

        const String title  = winrt::to_string(mediaProperties.Title());
        const String artist = winrt::to_string(mediaProperties.Artist());

        return MediaInfo(title.empty() ? None : Some(title), artist.empty() ? None : Some(artist));
      }

      ERR(NotFound, "No media session found");
    } catch (const winrt::hresult_error& e) {
      // Make sure to catch any errors that WinRT might throw.
      ERR_FMT(ApiUnavailable, "Failed to get media session: {}", winrt::to_string(e.message()));
    }
  }
  #endif // DRAC_ENABLE_NOWPLAYING

  fn GetOperatingSystem(CacheManager& cache) -> Result<OSInfo> {
    return cache.getOrSet<OSInfo>("windows_os_version", []() -> Result<OSInfo> {
      // Windows is weird about its versioning scheme, and Windows 11 is still
      // considered Windows 10 in the registry. We have to manually check if
      // the actual version is Windows 11 by checking the build number.
      constexpr PWCStr windows10 = L"Windows 10";
      constexpr PWCStr windows11 = L"Windows 11";

      constexpr usize windowsLen = std::char_traits<WCStr>::length(windows10);

      const RegistryCache& registry = RegistryCache::getInstance();

      HKEY currentVersionKey = registry.getCurrentVersionKey();

      if (!currentVersionKey)
        ERR(NotFound, "Failed to open registry key");

      Result<WString> productName = GetRegistryValue(currentVersionKey, PRODUCT_NAME);

      if (!productName)
        ERR_FROM(productName.error());

      if (productName->empty())
        ERR(NotFound, "ProductName not found in registry");

      // Build 22000+ of Windows are all considered Windows 11, so we can safely replace the product name
      // if it's currently "Windows 10" and the build number is greater than or equal to 22000.
      if (const Result<u64> buildNumberOpt = OsVersionCache::getInstance().getBuildNumber())
        if (const u64 buildNumber = *buildNumberOpt; buildNumber >= 22000)
          if (const size_t pos = productName->find(windows10); pos != WString::npos) {
            // Make sure we're not replacing a substring of a larger string. Should never happen,
            // but if it ever does, we'll just leave the product name unchanged.
            const bool startBoundary = (pos == 0 || !iswalnum(productName->at(pos - 1)));
            const bool endBoundary   = (pos + windowsLen == productName->length() || !iswalnum(productName->at(pos + windowsLen)));

            if (startBoundary && endBoundary)
              productName->replace(pos, windowsLen, windows11);
          }

      // Append the display version if it exists.
      const Result<WString> displayVersion = GetRegistryValue(currentVersionKey, DISPLAY_VERSION);

      if (!displayVersion)
        ERR_FROM(displayVersion.error());

      const Result<String> productNameUTF8 = ConvertWStringToUTF8(*productName);

      if (!productNameUTF8)
        ERR_FROM(productNameUTF8.error());

      const Result<String> displayVersionUTF8 = ConvertWStringToUTF8(*displayVersion);

      if (!displayVersionUTF8)
        ERR_FROM(displayVersionUTF8.error());

      return OSInfo(*productNameUTF8, *displayVersionUTF8, "windows");
    });
  }

  fn GetHost(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_host", []() -> Result<String> {
      // See the RegistryCache class for how the registry keys are retrieved.
      const RegistryCache& registry = RegistryCache::getInstance();

      HKEY hardwareConfigKey = registry.getHardwareConfigKey();

      if (!hardwareConfigKey)
        ERR(NotFound, "Failed to open registry key");

      const Result<WString> systemFamily = GetRegistryValue(hardwareConfigKey, SYSTEM_FAMILY);

      if (!systemFamily)
        ERR(NotFound, "SystemFamily not found in registry");

      return ConvertWStringToUTF8(*systemFamily);
    });
  }

  fn GetKernelVersion(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_kernel_version", []() -> Result<String> {
      // See the OsVersionCache class for how the version data is retrieved.
      const Result<OsVersionCache::VersionData>& versionDataResult = OsVersionCache::getInstance().getVersionData();

      if (!versionDataResult)
        ERR_FROM(versionDataResult.error());

      const auto& [majorVersion, minorVersion, buildNumber] = *versionDataResult;

      return std::format("{}.{}.{}", majorVersion, minorVersion, buildNumber);
    });
  }

  fn GetWindowManager(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_wm", []() -> Result<String> {
      if (!cache::ProcessTreeCache::getInstance().initialize())
        ERR(PlatformSpecific, "Failed to initialize process tree cache");

      for (const auto& [parentPid, baseExeNameLower] : cache::ProcessTreeCache::getInstance().getProcessMap() | std::views::values) {
        const StringView processName = baseExeNameLower;

        if (
          const auto mapIter =
            std::ranges::find_if(windowManagerMap, [&](const Pair<StringView, StringView>& pair) -> bool {
              return processName == pair.first;
            });
          mapIter != std::ranges::end(windowManagerMap)
        )
          return String(mapIter->second);
      }

      return "DWM";
    });
  }

  fn GetDesktopEnvironment(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_desktop_environment", []() -> Result<String> {
      // Windows doesn't really have the concept of a desktop environment,
      // so our next best bet is just displaying the UI design based on the build number.

      const Result<u64> buildResult = OsVersionCache::getInstance().getBuildNumber();

      if (!buildResult)
        ERR_FROM(buildResult.error());

      const u64 build = *buildResult;

      if (build >= 15063)
        return "Fluent";

      if (build >= 9200)
        return "Metro";

      if (build >= 6000)
        return "Aero";

      return "Classic";
    });
  }

  fn GetShell(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_shell", []() -> Result<String> {
      using draconis::utils::env::GetEnv;
      using shell::FindShellInProcessTree;

      // MSYS2 environments automatically set the MSYSTEM environment variable.
      if (const Result<String> msystemResult = GetEnv("MSYSTEM"); msystemResult && !msystemResult->empty()) {
        String shellPath;

        // The SHELL environment variable should basically always be set.
        if (const Result<String> shellResult = GetEnv("SHELL"); shellResult && !shellResult->empty())
          shellPath = *shellResult;

        if (!shellPath.empty()) {
          // Get the executable name from the path.
          const usize lastSlash = shellPath.find_last_of("\\/");
          String      shellExe  = (lastSlash != String::npos) ? shellPath.substr(lastSlash + 1) : shellPath;

          std::ranges::transform(shellExe, shellExe.begin(), [](const u8 character) { return std::tolower(character); });

          // Remove the .exe extension if it exists.
          if (shellExe.ends_with(".exe"))
            shellExe.resize(shellExe.length() - 4);

          // Check if the executable name matches any shell in the map.
          if (
            const auto iter =
              std::ranges::find_if(msysShellMap, [&](const Pair<StringView, StringView>& pair) -> bool {
                return StringView { shellExe } == pair.first;
              });
            iter != std::ranges::end(msysShellMap)
          )
            return String(iter->second);

          // If the executable name doesn't match any shell in the map, we might as well just return it as is.
          return shellExe;
        }

        // If the SHELL environment variable is not set, we can fall back to checking the process tree.
        // This is slower, but if we don't have the SHELL variable there's not much else we can do.
        const Result<String> msysShell = FindShellInProcessTree(GetCurrentProcessId(), msysShellMap);

        if (msysShell)
          return *msysShell;

        ERR_FROM(msysShell.error());
      }

      // Normal windows shell environments don't set any environment variables we can check,
      // so we have to check the process tree instead.
      const Result<String> windowsShell = FindShellInProcessTree(GetCurrentProcessId(), windowsShellMap);

      if (windowsShell)
        return *windowsShell;

      ERR_FROM(windowsShell.error());
    });
  }

  fn GetDiskUsage(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    // GetDiskFreeSpaceExW is a pretty old function and doesn't use native 64-bit integers,
    // so we have to use ULARGE_INTEGER instead. It's basically a union that holds either a
    // 64-bit integer or two 32-bit integers.
    ULARGE_INTEGER freeBytes, totalBytes;

    // Get the disk usage for the C: drive.
    if (FAILED(GetDiskFreeSpaceExW(L"C:\\\\", nullptr, &totalBytes, &freeBytes)))
      ERR(IoError, "Failed to get disk usage");

    // Calculate the used bytes by subtracting the free bytes from the total bytes.
    // QuadPart corresponds to the 64-bit integer in the union. (LowPart/HighPart are for the 32-bit integers.)
    return ResourceUsage(totalBytes.QuadPart - freeBytes.QuadPart, totalBytes.QuadPart);
  }

  fn GetCPUModel(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_cpu_model", []() -> Result<String> {
    /*
     * This function attempts to get the CPU model name on Windows in two ways:
     * 1. Using __cpuid on x86/x86_64 platforms (much more direct and efficient).
     * 2. Reading from the registry on all platforms (slower, but more reliable).
     */
  #if DRAC_ARCH_X86_64 || DRAC_ARCH_X86
      {
        /*
         * The CPUID instruction is used to get the CPU model name on x86/x86_64 platforms.
         * 1. First, we call CPUID with leaf 0x80000000 to ask the CPU if it supports the
         *    extended functions needed to retrieve the brand string.
         * 2. If it does, we then make three more calls to retrieve the 48-byte brand
         *    string, which the CPU provides in three 16-byte chunks.
         *
         * (In this context, a "leaf" is basically just an action we ask the CPU to perform.)
         */

        // Array to hold the raw 32-bit values from the EAX, EBX, ECX, and EDX registers.
        Array<i32, 4> cpuInfo = {};

        // Buffer to hold the raw 48-byte brand string + null terminator.
        Array<char, 49> brandString = {};

        // Step 1: Check for brand string support. The result is returned in EAX (cpuInfo[0]).
        __cpuid(0x80000000, cpuInfo[0], cpuInfo[1], cpuInfo[2], cpuInfo[3]);

        // We must have extended functions support (functions up to 0x80000004).
        if (const u32 maxFunction = cpuInfo[0]; maxFunction >= 0x80000004) {
          // Retrieve the brand string in three 16-byte parts.
          for (u32 i = 0; i < 3; i++) {
            // Call leaves 0x80000002, 0x80000003, and 0x80000004. Each call
            // returns a 16-byte chunk of the brand string.
            __cpuid(0x80000002 + i, cpuInfo[0], cpuInfo[1], cpuInfo[2], cpuInfo[3]);

            // Copy the chunk into the brand string buffer.
            std::memcpy(&brandString.at(i * 16), cpuInfo.data(), sizeof(cpuInfo));
          }

          String result(brandString.data());

          // Clean up any possible trailing whitespace.
          while (!result.empty() && std::isspace(result.back()))
            result.pop_back();

          // We're done if we got a valid, non-empty string.
          // Otherwise, fallback to querying the registry.
          if (!result.empty())
            return result;
        }
      }
  #endif // DRAC_ARCH_X86_64 || DRAC_ARCH_X86
      {
        /*
         * If the CPUID instruction fails/is unsupported on the target architecture,
         * we fallback to querying the registry. This is a lot more reliable than
         * querying the CPU itself and supports all architectures, but it's also slower.
         */

        HKEY hKey = nullptr;

        // This key contains information about the processor.
        if (FAILED(RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &hKey))) {
          // Get the processor name value from the registry key.
          Result<WString> processorNameW = GetRegistryValue(hKey, L"ProcessorNameString");

          // Ensure the key is closed to prevent leaks.
          RegCloseKey(hKey);

          // The registry returns wide strings so we have to convert to UTF-8 before returning.
          if (processorNameW)
            return ConvertWStringToUTF8(*processorNameW);
        }
      }

      // At this point, there's no other good method to get the CPU model on Windows.
      // Using WMI is useless because it just calls the same registry key we're already using.
      ERR(NotFound, "All methods to get CPU model failed on this platform");
    });
  }

  fn GetCPUCores(CacheManager& cache) -> Result<CPUCores> {
    return cache.getOrSet<CPUCores>("windows_cpu_cores", []() -> Result<CPUCores> {
      const DWORD logicalProcessors = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);
      if (logicalProcessors == 0)
        ERR_FMT(ApiUnavailable, "GetActiveProcessorCount failed with error code {}", GetLastError());

      DWORD bufferSize = 0;

      if (GetLogicalProcessorInformationEx(RelationProcessorCore, nullptr, &bufferSize) == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        ERR_FMT(ApiUnavailable, "GetLogicalProcessorInformationEx (size query) failed with error code {}", GetLastError());

      Array<BYTE, 1024> buffer {};

      // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
      if (GetLogicalProcessorInformationEx(RelationProcessorCore, reinterpret_cast<PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(buffer.data()), &bufferSize) == FALSE)
        ERR_FMT(ApiUnavailable, "GetLogicalProcessorInformationEx (data retrieval) failed with error code {}", GetLastError());

      DWORD      physicalCores = 0;
      DWORD      offset        = 0;
      Span<BYTE> bufferSpan(buffer);

      while (offset < bufferSize) {
        physicalCores++;

        // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
        const auto* current = reinterpret_cast<PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(&bufferSpan[offset]);
        offset += current->Size;
      }

      return CPUCores(static_cast<u16>(physicalCores), static_cast<u16>(logicalProcessors));
    });
  }

  fn GetGPUModel(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("windows_gpu_model", draconis::utils::cache::CachePolicy::neverExpire(), []() -> Result<String> {
      // Used to create and enumerate DirectX graphics interfaces.
      IDXGIFactory* pFactory = nullptr;

      // The __uuidof operator is a Microsoft-specific extension that gets the GUID of a COM interface.
      // It's required by CreateDXGIFactory. The pragma below disables the compiler warning about this
      // non-standard extension, as its use is necessary here.
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wlanguage-extension-token"
      // NOLINTNEXTLINE(*-pro-type-reinterpret-cast) - CreateDXGIFactory needs a void** parameter, not an IDXGIFactory**.
      if (FAILED(CreateDXGIFactory(__uuidof(IDXGIFactory), reinterpret_cast<void**>(&pFactory))))
        ERR_FMT(ApiUnavailable, "Failed to create DXGI Factory: {}", GetLastError());
  #pragma clang diagnostic pop

      // Attempt to get the first adapter.
      IDXGIAdapter* pAdapter = nullptr;

      // 0 = primary adapter/GPU
      if (pFactory->EnumAdapters(0, &pAdapter) == DXGI_ERROR_NOT_FOUND) {
        // Clean up factory.
        pFactory->Release();

        ERR(NotFound, "No DXGI adapters found");
      }

      // Get the adapter description.
      DXGI_ADAPTER_DESC desc {};

      if (FAILED(pAdapter->GetDesc(&desc))) {
        // Make sure to release the adapter and factory if GetDesc fails.
        pAdapter->Release();
        pFactory->Release();

        ERR_FMT(ApiUnavailable, "Failed to get adapter description: {}", GetLastError());
      }

      // The DirectX description is a wide string.
      // We have to convert it to a UTF-8 string.
      Array<CStr, 128> gpuName {};

      WideCharToMultiByte(CP_UTF8, 0, desc.Description, -1, gpuName.data(), gpuName.size(), nullptr, nullptr);

      // Clean up resources.
      pAdapter->Release();
      pFactory->Release();

      return gpuName.data();
    });
  }

  fn GetUptime() -> Result<std::chrono::seconds> {
    return std::chrono::seconds(GetTickCount64() / 1000);
  }

  fn GetOutputs(CacheManager& /*cache*/) -> Result<Vec<DisplayInfo>> {
    UINT32 pathCount = 0;
    UINT32 modeCount = 0;

    if (FAILED(GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &pathCount, &modeCount)))
      ERR_FMT(ApiUnavailable, "GetDisplayConfigBufferSizes failed to get buffer sizes: {}", GetLastError());

    Vec<DISPLAYCONFIG_PATH_INFO> paths(pathCount);
    Vec<DISPLAYCONFIG_MODE_INFO> modes(modeCount);

    if (FAILED(QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &pathCount, paths.data(), &modeCount, modes.data(), nullptr)))
      ERR_FMT(ApiUnavailable, "QueryDisplayConfig failed to retrieve display data: {}", GetLastError());

    Vec<DisplayInfo> outputs;
    outputs.reserve(pathCount);

    // NOLINTBEGIN(*-pro-type-union-access)
    for (const DISPLAYCONFIG_PATH_INFO& path : paths) {
      if (path.flags & DISPLAYCONFIG_PATH_ACTIVE) {
        const DISPLAYCONFIG_MODE_INFO& mode = modes[path.targetInfo.modeInfoIdx];

        if (mode.infoType != DISPLAYCONFIG_MODE_INFO_TYPE_TARGET)
          continue;

        outputs.emplace_back(DisplayInfo(
          path.targetInfo.id,
          { .width = mode.targetMode.targetVideoSignalInfo.activeSize.cx, .height = mode.targetMode.targetVideoSignalInfo.activeSize.cy },
          mode.targetMode.targetVideoSignalInfo.totalSize.cx != 0 && mode.targetMode.targetVideoSignalInfo.totalSize.cy != 0
            ? static_cast<f64>(mode.targetMode.targetVideoSignalInfo.pixelRate) / (mode.targetMode.targetVideoSignalInfo.totalSize.cx * mode.targetMode.targetVideoSignalInfo.totalSize.cy)
            : 0,
          (path.flags & DISPLAYCONFIG_PATH_ACTIVE) != 0
        ));
      }
    }
    // NOLINTEND(*-pro-type-union-access)

    if (outputs.empty())
      ERR(NotFound, "No active displays found with QueryDisplayConfig");

    return outputs;
  }

  fn GetPrimaryOutput(CacheManager& /*cache*/) -> Result<DisplayInfo> {
    UINT32 pathCount = 0;
    UINT32 modeCount = 0;

    if (FAILED(GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &pathCount, &modeCount)))
      ERR_FMT(ApiUnavailable, "GetDisplayConfigBufferSizes failed to get buffer sizes: {}", GetLastError());

    Vec<DISPLAYCONFIG_PATH_INFO> paths(pathCount);
    Vec<DISPLAYCONFIG_MODE_INFO> modes(modeCount);

    if (FAILED(QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &pathCount, paths.data(), &modeCount, modes.data(), nullptr)))
      ERR_FMT(ApiUnavailable, "QueryDisplayConfig failed to retrieve display data: {}", GetLastError());

    // NOLINTBEGIN(*-pro-type-union-access)
    for (const DISPLAYCONFIG_PATH_INFO& path : paths) {
      if (!(path.flags & DISPLAYCONFIG_PATH_ACTIVE))
        continue;

      const DISPLAYCONFIG_MODE_INFO& sourceModeInfo = modes.at(path.sourceInfo.modeInfoIdx);

      if (sourceModeInfo.infoType == DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE && sourceModeInfo.sourceMode.position.x == 0 && sourceModeInfo.sourceMode.position.y == 0) {
        const DISPLAYCONFIG_MODE_INFO& targetModeInfo = modes.at(path.targetInfo.modeInfoIdx);

        if (targetModeInfo.infoType != DISPLAYCONFIG_MODE_INFO_TYPE_TARGET)
          continue;

        const DISPLAYCONFIG_VIDEO_SIGNAL_INFO& videoSignalInfo = targetModeInfo.targetMode.targetVideoSignalInfo;

        return DisplayInfo(
          path.targetInfo.id,
          { .width = videoSignalInfo.activeSize.cx, .height = videoSignalInfo.activeSize.cy },
          videoSignalInfo.totalSize.cx != 0 && videoSignalInfo.totalSize.cy != 0
            ? static_cast<f64>(videoSignalInfo.pixelRate) / (videoSignalInfo.totalSize.cx * videoSignalInfo.totalSize.cy)
            : 0,
          true
        );
      }
    }
    // NOLINTEND(*-pro-type-union-access)

    ERR(NotFound, "No primary display found with QueryDisplayConfig");
  }

  fn GetNetworkInterfaces(CacheManager& /*cache*/) -> Result<Vec<NetworkInterface>> {
    Vec<NetworkInterface> interfaces;
    ULONG                 bufferSize = 15000; // A reasonable starting buffer size
    Vec<BYTE>             buffer(bufferSize);

    // GetAdaptersAddresses is a two-call function. First call gets the required buffer size.
    // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
    auto* pAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(buffer.data());
    DWORD result     = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, nullptr, pAddresses, &bufferSize);

    if (result == ERROR_BUFFER_OVERFLOW) {
      buffer.resize(bufferSize);
      // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
      pAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(buffer.data());
      result     = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, nullptr, pAddresses, &bufferSize);
    }

    if (result != NO_ERROR)
      ERR_FMT(NetworkError, "GetAdaptersAddresses failed with error: {}", result);

    // Iterate through the linked list of adapters
    for (IP_ADAPTER_ADDRESSES* pCurrAddresses = pAddresses; pCurrAddresses != nullptr; pCurrAddresses = pCurrAddresses->Next) {
      NetworkInterface iface;
      iface.name = pCurrAddresses->AdapterName;

      iface.isUp       = (pCurrAddresses->OperStatus == IfOperStatusUp);
      iface.isLoopback = (pCurrAddresses->IfType == IF_TYPE_SOFTWARE_LOOPBACK);

      // Format the MAC address
      if (pCurrAddresses->PhysicalAddressLength == 6)
        iface.macAddress = std::format(
          "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
          pCurrAddresses->PhysicalAddress[0],
          pCurrAddresses->PhysicalAddress[1],
          pCurrAddresses->PhysicalAddress[2],
          pCurrAddresses->PhysicalAddress[3],
          pCurrAddresses->PhysicalAddress[4],
          pCurrAddresses->PhysicalAddress[5]
        );

      // Iterate through the IP addresses for this adapter
      for (const IP_ADAPTER_UNICAST_ADDRESS* pUnicast = pCurrAddresses->FirstUnicastAddress; pUnicast != nullptr; pUnicast = pUnicast->Next)
        if (pUnicast->Address.lpSockaddr->sa_family == AF_INET) {
          // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
          const auto* saIn = reinterpret_cast<sockaddr_in*>(pUnicast->Address.lpSockaddr);

          Array<char, INET_ADDRSTRLEN> strBuffer {};

          if (inet_ntop(AF_INET, &(saIn->sin_addr), strBuffer.data(), INET_ADDRSTRLEN))
            iface.ipv4Address = strBuffer.data();
        }

      interfaces.emplace_back(iface);
    }

    return interfaces;
  }

  fn GetPrimaryNetworkInterface(CacheManager& cache) -> Result<NetworkInterface> {
    return cache.getOrSet<NetworkInterface>("windows_primary_network_interface", []() -> Result<NetworkInterface> {
      MIB_IPFORWARDROW routeRow;
      sockaddr_in      destAddr {};
      destAddr.sin_family = AF_INET;
      inet_pton(AF_INET, "8.8.8.8", &destAddr.sin_addr);

      if (DWORD status = GetBestRoute(destAddr.sin_addr.s_addr, 0, &routeRow); status != NO_ERROR)
        ERR_FMT(NetworkError, "GetBestRoute failed with error: {}", status);

      // The interface index for the best route
      const DWORD primaryInterfaceIndex = routeRow.dwForwardIfIndex;

      ULONG     bufferSize = 15000;
      Vec<BYTE> buffer(bufferSize);

      // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
      auto* pAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(buffer.data());

      DWORD result = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, nullptr, pAddresses, &bufferSize);
      if (result == ERROR_BUFFER_OVERFLOW) {
        buffer.resize(bufferSize);
        // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
        pAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(buffer.data());
        result     = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, nullptr, pAddresses, &bufferSize);
      }

      if (result != NO_ERROR)
        ERR_FMT(NetworkError, "GetAdaptersAddresses failed with error: {}", result);

      for (IP_ADAPTER_ADDRESSES* pCurrAddresses = pAddresses; pCurrAddresses != nullptr; pCurrAddresses = pCurrAddresses->Next) {
        // NOLINTNEXTLINE(*-union-access)
        if (pCurrAddresses->IfIndex == primaryInterfaceIndex) {
          NetworkInterface iface;
          iface.name = pCurrAddresses->AdapterName;

          iface.isUp       = (pCurrAddresses->OperStatus == IfOperStatusUp);
          iface.isLoopback = (pCurrAddresses->IfType == IF_TYPE_SOFTWARE_LOOPBACK);

          if (pCurrAddresses->PhysicalAddressLength == 6)
            iface.macAddress = std::format(
              "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
              pCurrAddresses->PhysicalAddress[0],
              pCurrAddresses->PhysicalAddress[1],
              pCurrAddresses->PhysicalAddress[2],
              pCurrAddresses->PhysicalAddress[3],
              pCurrAddresses->PhysicalAddress[4],
              pCurrAddresses->PhysicalAddress[5]
            );

          for (IP_ADAPTER_UNICAST_ADDRESS* pUnicast = pCurrAddresses->FirstUnicastAddress; pUnicast != nullptr; pUnicast = pUnicast->Next) {
            if (pUnicast->Address.lpSockaddr->sa_family == AF_INET) {
              // NOLINTNEXTLINE(*-pro-type-reinterpret-cast)
              auto* saIn = reinterpret_cast<sockaddr_in*>(pUnicast->Address.lpSockaddr);

              Array<char, INET_ADDRSTRLEN> strBuffer {};

              if (inet_ntop(AF_INET, &(saIn->sin_addr), strBuffer.data(), INET_ADDRSTRLEN))
                iface.ipv4Address = strBuffer.data();
            }
          }
          return iface;
        }
      }

      ERR(NotFound, "Could not find details for the primary network interface.");
    });
  }

  fn GetBatteryInfo(CacheManager& /*cache*/) -> Result<Battery> {
    using matchit::match, matchit::is, matchit::_;
    using enum Battery::Status;

    SYSTEM_POWER_STATUS powerStatus;

    if (!GetSystemPowerStatus(&powerStatus))
      ERR_FMT(ApiUnavailable, "GetSystemPowerStatus failed with error code {}", GetLastError());

    // The BATTERY_FLAG_NO_SYSTEM_BATTERY flag (0x80) indicates no battery is present.
    if (powerStatus.BatteryFlag & BATTERY_FLAG_NO_BATTERY)
      ERR(NotFound, "No battery found");

    // The BATTERY_FLAG_UNKNOWN flag (0xFF) indicates the status can't be determined.
    if (powerStatus.BatteryFlag == BATTERY_FLAG_UNKNOWN)
      ERR(NotFound, "Battery status unknown");

    // 255 means unknown, so we'll map it to None.
    const Option<u8> percentage = (powerStatus.BatteryLifePercent == 255) ? None : Some(powerStatus.BatteryLifePercent);

    // The catch-all should only ever need to cover 255 but using it regardless is safer.
    const Battery::Status status = match(powerStatus.ACLineStatus)(
      is | (_ == 1 && percentage == 100) = Full,
      is | 1                             = Charging,
      is | 0                             = Discharging,
      is | _                             = Unknown
    );

    return Battery(
      status,
      percentage,
      powerStatus.BatteryFullLifeTime == static_cast<DWORD>(-1)
        ? None
        : Some(std::chrono::seconds(powerStatus.BatteryFullLifeTime))
    );
  }
} // namespace draconis::core::system

  #if DRAC_ENABLE_PACKAGECOUNT
namespace draconis::services::packages {
  using draconis::utils::env::GetEnv;
  using helpers::GetDirCount;

  fn CountChocolatey(CacheManager& cache) -> Result<u64> {
    return cache.getOrSet<u64>("windows_chocolatey_count", []() -> Result<u64> {
      // C:\ProgramData\chocolatey is the default installation directory.
      WString chocoPath = L"C:\\ProgramData\\chocolatey";

      // If the ChocolateyInstall environment variable is set, use that instead.
      // Most of the time it's set to C:\ProgramData\chocolatey, but it can be overridden.
      if (const Result<PWCStr> chocoEnv = GetEnv(L"ChocolateyInstall"); chocoEnv)
        chocoPath = *chocoEnv;

      // The lib directory contains the package metadata.
      chocoPath.append(L"\\lib");

      // Get the number of directories in the lib directory.
      // This corresponds to the number of packages installed.
      const Result<u64> dirCount = GetDirCount(chocoPath);

      if (dirCount)
        return *dirCount;

      ERR_FROM(dirCount.error());
    });
  }

  fn CountScoop(CacheManager& cache) -> Result<u64> {
    return cache.getOrSet<u64>("windows_scoop_count", []() -> Result<u64> {
      WString scoopAppsPath;

      // The SCOOP environment variable should be used first if it's set.
      if (const Result<PWCStr> scoopEnv = GetEnv(L"SCOOP"); scoopEnv) {
        scoopAppsPath = *scoopEnv;
        scoopAppsPath.append(L"\\apps");
      } else if (const Result<PWCStr> userProfile = GetEnv(L"USERPROFILE"); userProfile) {
        // Otherwise, we can try finding the scoop folder in the user's home directory.
        scoopAppsPath = *userProfile;
        scoopAppsPath.append(L"\\scoop\\apps");
      } else {
        // The user likely doesn't have scoop installed if neither of those other methods work.
        ERR(ConfigurationError, "Could not determine Scoop installation directory (SCOOP and USERPROFILE environment variables not found)");
      }

      // Get the number of directories in the apps directory.
      // This corresponds to the number of packages installed.
      const Result<u64> dirCount = GetDirCount(scoopAppsPath);

      if (dirCount)
        return *dirCount;

      ERR_FROM(dirCount.error());
    });
  }

  fn CountWinGet(CacheManager& cache) -> Result<u64> {
    return cache.getOrSet<u64>("windows_winget_count", []() -> Result<u64> {
      try {
        using winrt::Windows::Management::Deployment::PackageManager;

        // The only good way to get the number of packages installed via winget is using WinRT.
        // It's a bit slow, but it's still faster than shelling out to the command line.
        // FindPackagesForUser returns an iterator to the first package, so we can use std::ranges::distance to get the
        // number of packages.
        return std::ranges::distance(PackageManager().FindPackagesForUser(L""));
      } catch (const winrt::hresult_error& e) {
        // Make sure to catch any errors that WinRT might throw.
        ERR_FMT(ApiUnavailable, "Failed to get package count: {}", winrt::to_string(e.message()));
      }
    });
  }
} // namespace draconis::services::packages
  #endif // DRAC_ENABLE_PACKAGECOUNT

#endif // _WIN32
</file>

<file path="meson.build">
# ========================= #
#   Project Configuration   #
# ========================= #
project(
  'draconis++',
  'cpp',
  version: '0.1.0',
  meson_version: '>=1.1',
  default_options: [
    'default_library=static',
    'buildtype=debugoptimized',
    'b_vscrt=mt',
    'b_ndebug=if-release',
    'warning_level=3',
  ],
)

# ========================== #
#   Compiler & Environment   #
# ========================== #
cpp = meson.get_compiler('cpp')
host_system = host_machine.system()

# Preprocessor definitions
project_string_defines = {
  'DRAC_VERSION': '"' + meson.project_version() + '"',
  'fn': 'auto',
  '_WIN32_WINNT': '0x0602',
}

project_flag_defines = {
  'DRAC_ARCH_64BIT': cpp.sizeof('void*') == 8,
  'DRAC_ARCH_AARCH64': host_machine.cpu_family() == 'aarch64',
  'DRAC_ARCH_ARM': host_machine.cpu_family() == 'arm',
  'DRAC_ARCH_X86': host_machine.cpu_family() == 'x86',
  'DRAC_ARCH_X86_64': host_machine.cpu_family() == 'x86_64',
  'DRAC_DEBUG': get_option('debug'),
}

if host_system == 'windows'
  project_flag_defines += {
    'NOMINMAX': true,
    'WIN32_LEAN_AND_MEAN': true,
    'WINRT_LEAN_AND_MEAN': true,
    'CURL_STATICLIB': true,
  }
endif

# Feature detection
feature_states = {}

# Define which options are features vs booleans
feature_options = [
  'nowplaying',
  'caching',
  'weather',
  'packagecount',
  'xcb',
  'wayland',
  'pugixml',
]

foreach option, define : {
  'caching': 'DRAC_ENABLE_CACHING',
  'nowplaying': 'DRAC_ENABLE_NOWPLAYING',
  'packagecount': 'DRAC_ENABLE_PACKAGECOUNT',
  'precompiled_config': 'DRAC_PRECOMPILED_CONFIG',
  'pugixml': 'DRAC_USE_PUGIXML',
  'use_linked_pci_ids': 'DRAC_USE_LINKED_PCI_IDS',
  'wayland': 'DRAC_USE_WAYLAND',
  'weather': 'DRAC_ENABLE_WEATHER',
  'xcb': 'DRAC_USE_XCB',
}
  opt_val = get_option(option)

  # Check if this is a feature option
  if option in feature_options
    enabled = opt_val.enabled()
  else
    enabled = opt_val
  endif

  if enabled
    project_flag_defines += {define: true}
  endif
  feature_states += {option: enabled}
endforeach

cpp_args = []

foreach name, value : project_string_defines
  cpp_args += '-D@0@=@1@'.format(name, value)
endforeach

foreach name, value : project_flag_defines
  cpp_args += '-D@0@=@1@'.format(name, value ? '1' : '0')
endforeach

if cpp.get_id() in ['msvc', 'clang-cl']
  cpp_args += '/std:c++latest'
  cpp_args += cpp.get_supported_arguments(
    '/Zc:__cplusplus',
    '/Zc:preprocessor',
    '/external:W0',
    '/external:anglebrackets',
  )
else
  cpp_args += '-std=c++26'
endif

# Check compiler arguments in groups
cpp_args += cpp.get_supported_arguments(
  [
    # Common flags
    '-fno-strict-enums',
    '-fvisibility=hidden',
    '-fvisibility-inlines-hidden',
    '-march=native',

    # Warning flags
    '-Wno-c++17-extensions',
    '-Wno-c++20-compat',
    '-Wno-c++20-extensions',
    '-Wno-c++98-compat-pedantic',
    '-Wno-c++98-compat',
    '-Wno-disabled-macro-expansion',
    '-Wno-gnu-conditional-omitted-operand',
    '-Wno-missing-prototypes',
    '-Wno-padded',
    '-Wno-pre-c++20-compat-pedantic',
    '-Wno-unused-command-line-argument',
    '-Wunused-function',
  ],
)

add_project_arguments(cpp_args, language: 'cpp')

if host_system == 'darwin'
  add_languages('objcpp', native: false)
  add_project_arguments(cpp_args, language: 'objcpp')
endif

# =================== #
#   Include Folders   #
# =================== #
project_public_includes = include_directories('include', is_system: true)
third_party_includes = include_directories('third_party', is_system: true)
includes_dep = declare_dependency(include_directories: [project_public_includes, third_party_includes])

# ================ #
#   Dependencies   #
# ================ #
fs = import('fs')
lib_deps = [includes_dep]

# Core dependencies
lib_deps += dependency(
  'magic_enum',
  fallback: ['magic_enum', 'magic_enum_dep'],
  include_type: 'system',
  static: true,
)

# Precompiled configuration
if get_option('precompiled_config') == true
  config_hpp_path = meson.project_source_root() / 'config.hpp'

  if not fs.is_file(config_hpp_path)
    error(
      'Option "precompiled_config" is enabled, but "@0@" was not found.'.format(config_hpp_path),
    )
  endif
else
  lib_deps += dependency('tomlplusplus', include_type: 'system', static: true)
endif

if feature_states['weather']
  lib_deps += dependency('libcurl', include_type: 'system', static: true)
endif

if feature_states['packagecount'] and host_system in ['darwin', 'linux']
  lib_deps += dependency('SQLiteCpp')
endif

# Platform-specific dependencies
if host_system == 'darwin'
  lib_deps += dependency(
    'appleframeworks',
    modules: [
      'coregraphics',
      'foundation',
      'iokit',
      feature_states['nowplaying'] ? 'mediaplayer' : '',
      'metal',
      'systemconfiguration',
    ],
  )
  lib_deps += cpp.find_library('iconv')
elif host_system == 'windows'
  lib_deps += [
    cpp.find_library('dwmapi'),
    cpp.find_library('windowsapp'),
    cpp.find_library('setupapi'),
    cpp.find_library('dxgi'),
    cpp.find_library('dxguid'),
  ]
elif host_system not in ['serenity', 'haiku']
  lib_deps += dependency('dbus-1', required: feature_states['nowplaying'])

  lib_deps += dependency('xau', required: get_option('xcb'))
  lib_deps += dependency('xcb', required: get_option('xcb'))
  lib_deps += dependency('xcb-randr', required: get_option('xcb'))
  lib_deps += dependency('xdmcp', required: get_option('xcb'))

  lib_deps += dependency('pugixml', required: get_option('pugixml'))

  lib_deps += dependency('wayland-client', required: get_option('wayland'))
endif

# Glaze (JSON/BEVE serializer/deserializer)
glaze_dep = dependency('glaze', include_type: 'system', required: false)

if not glaze_dep.found()
  cmake = import('cmake')
  options = cmake.subproject_options()
  options.add_cmake_defines(
    {
      'glaze_ENABLE_SSL': false,
      'glaze_BUILD_EXAMPLES': false,
      'glaze_DEVELOPER_MODE': false,
    },
  )
  glaze_proj = cmake.subproject('glaze', options: options)
  glaze_dep = glaze_proj.dependency('glaze_glaze', include_type: 'system')
endif

lib_deps += glaze_dep

# =============== #
#   Subprojects   #
# =============== #
subdir('src/Lib')
subdir('src/CLI')

if get_option('build_examples')
  lib_deps += dependency('asio', static: true, fallback: ['asio', 'asio_dep'])
  subdir('examples')
endif

if get_option('build_tests')
  subdir('src/Lib/Tests')
endif

# =========================== #
#   Configuration Summaries   #
# =========================== #
summary(
  {
    '64-bit': project_flag_defines['DRAC_ARCH_64BIT'],
    'AArch64': project_flag_defines['DRAC_ARCH_AARCH64'],
    'ARM': project_flag_defines['DRAC_ARCH_ARM'],
    'X86': project_flag_defines['DRAC_ARCH_X86'],
    'X86_64': project_flag_defines['DRAC_ARCH_X86_64'],
    'Debug': project_flag_defines['DRAC_DEBUG'],
  },
  section: 'Definitions',
  bool_yn: true,
)

summary(
  {
    'Weather support': feature_states['weather'],
    'Package counting': feature_states['packagecount'],
    'Now Playing': feature_states['nowplaying'],
    'Caching': feature_states['caching'],
    'Precompiled config': get_option('precompiled_config'),
  },
  section: 'Features',
  bool_yn: true,
)

if host_system != 'windows' and host_system != 'darwin'
  summary(
    {
      'XCB (X11)': feature_states.get('xcb', false),
      'Wayland': feature_states.get('wayland', false),
      'pugixml': feature_states.get('pugixml', false),
      'Use Linked pci.ids': feature_states.get('use_linked_pci_ids', false),
    },
    section: 'Platform Support',
    bool_yn: true,
  )
endif

summary(
  {
    'Build examples': get_option('build_examples'),
    'Build tests': get_option('build_tests'),
    'Build Switch example': get_option('build_switch_example'),
  },
  section: 'Build Options',
  bool_yn: true,
)

summary(
  {
    'C++ Compiler': cpp.get_id(),
    'Host system': host_system,
    'Build type': get_option('buildtype'),
    'Install prefix': get_option('prefix'),
  },
  section: 'System',
)
</file>

<file path="src/CLI/UI/UI.cpp">
#include "UI.hpp"

#include <sstream>

#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#include "AsciiArt.hpp"

using namespace draconis::utils::types;
using namespace draconis::utils::logging;

namespace draconis::ui {
  using config::Config;

  using core::system::SystemInfo;

  using services::weather::Report;

  constexpr Theme DEFAULT_THEME = {
    .icon  = LogColor::Cyan,
    .label = LogColor::Yellow,
    .value = LogColor::White,
  };

  [[maybe_unused]] static constexpr Icons NONE = {
    .calendar           = "",
    .desktopEnvironment = "",
    .disk               = "",
    .host               = "",
    .kernel             = "",
    .memory             = "",
    .cpu                = "",
    .gpu                = "",
    .uptime             = "",
#if DRAC_ENABLE_NOWPLAYING
    .music = "",
#endif
    .os = "",
#if DRAC_ENABLE_PACKAGECOUNT
    .package = "",
#endif
    .palette = "",
    .shell   = "",
    .user    = "",
#if DRAC_ENABLE_WEATHER
    .weather = "",
#endif
    .windowManager = "",
  };

  [[maybe_unused]] static constexpr Icons NERD = {
    .calendar           = "   ",
    .desktopEnvironment = " 󰇄  ",
    .disk               = " 󰋊  ",
    .host               = " 󰌢  ",
    .kernel             = "   ",
    .memory             = "   ",
#if DRAC_ARCH_64BIT
    .cpu = " 󰻠  ",
#else
    .cpu = " 󰻟  ",
#endif
    .gpu    = "   ",
    .uptime = "   ",
#if DRAC_ENABLE_NOWPLAYING
    .music = "   ",
#endif
#ifdef __linux__
    .os = " 󰌽  ",
#elifdef __APPLE__
    .os = "   ",
#elifdef _WIN32
    .os = "   ",
#elifdef __FreeBSD__
    .os = "   ",
#else
    .os = "   ",
#endif
#if DRAC_ENABLE_PACKAGECOUNT
    .package = " 󰏖  ",
#endif
    .palette = "   ",
    .shell   = "   ",
    .user    = "   ",
#if DRAC_ENABLE_WEATHER
    .weather = "   ",
#endif
    .windowManager = "   ",
  };

  [[maybe_unused]] static constexpr Icons EMOJI = {
    .calendar           = " 📅 ",
    .desktopEnvironment = " 🖥️ ",
    .disk               = " 💾 ",
    .host               = " 💻 ",
    .kernel             = " 🫀 ",
    .memory             = " 🧠 ",
    .cpu                = " 💻 ",
    .gpu                = " 🎨 ",
    .uptime             = " ⏰ ",
#if DRAC_ENABLE_NOWPLAYING
    .music = " 🎵 ",
#endif
    .os = " 🤖 ",
#if DRAC_ENABLE_PACKAGECOUNT
    .package = " 📦 ",
#endif
    .palette = " 🎨 ",
    .shell   = " 💲 ",
    .user    = " 👤 ",
#if DRAC_ENABLE_WEATHER
    .weather = " 🌈 ",
#endif
    .windowManager = " 🪟 ",
  };

  constexpr inline Icons ICON_TYPE = NERD;

  struct RowInfo {
    StringView icon;
    StringView label;
    String     value;
  };

  struct UIGroup {
    Vec<RowInfo> rows;
    Vec<usize>   iconWidths;
    Vec<usize>   labelWidths;
    Vec<usize>   valueWidths;
    Vec<String>  coloredIcons;
    Vec<String>  coloredLabels;
    Vec<String>  coloredValues;
    usize        maxLabelWidth = 0;
  };

  namespace {
#ifdef __linux__
    // clang-format off
    constexpr Array<Pair<StringView, StringView>, 13> distro_icons {{
      {      "arch", "   " },
      {     "nixos", "   " },
      {     "popos", "   " },
      {     "zorin", "   " },
      {    "debian", "   " },
      {    "fedora", "   " },
      {    "gentoo", "   " },
      {    "ubuntu", "   " },
      {    "alpine", "   " },
      {   "manjaro", "   " },
      { "linuxmint", "   " },
      { "voidlinux", "   " },
    }};
    // clang-format on

    constexpr fn GetDistroIcon(StringView distro) -> Option<StringView> {
      for (const auto& [distroName, distroIcon] : distro_icons)
        if (distro.contains(distroName))
          return distroIcon;

      return None;
    }
#endif // __linux__

    constexpr Array<StringView, 16> COLOR_CIRCLES {
      "\033[38;5;0m◯\033[0m",
      "\033[38;5;1m◯\033[0m",
      "\033[38;5;2m◯\033[0m",
      "\033[38;5;3m◯\033[0m",
      "\033[38;5;4m◯\033[0m",
      "\033[38;5;5m◯\033[0m",
      "\033[38;5;6m◯\033[0m",
      "\033[38;5;7m◯\033[0m",
      "\033[38;5;8m◯\033[0m",
      "\033[38;5;9m◯\033[0m",
      "\033[38;5;10m◯\033[0m",
      "\033[38;5;11m◯\033[0m",
      "\033[38;5;12m◯\033[0m",
      "\033[38;5;13m◯\033[0m",
      "\033[38;5;14m◯\033[0m",
      "\033[38;5;15m◯\033[0m"
    };

    constexpr fn IsWideCharacter(char32_t codepoint) -> bool {
      return (codepoint >= 0x1100 && codepoint <= 0x115F) || // Hangul Jamo
        (codepoint >= 0x2329 && codepoint <= 0x232A) ||      // Angle brackets
        (codepoint >= 0x2E80 && codepoint <= 0x2EFF) ||      // CJK Radicals Supplement
        (codepoint >= 0x2F00 && codepoint <= 0x2FDF) ||      // Kangxi Radicals
        (codepoint >= 0x2FF0 && codepoint <= 0x2FFF) ||      // Ideographic Description Characters
        (codepoint >= 0x3000 && codepoint <= 0x303E) ||      // CJK Symbols and Punctuation
        (codepoint >= 0x3041 && codepoint <= 0x3096) ||      // Hiragana
        (codepoint >= 0x3099 && codepoint <= 0x30FF) ||      // Katakana
        (codepoint >= 0x3105 && codepoint <= 0x312F) ||      // Bopomofo
        (codepoint >= 0x3131 && codepoint <= 0x318E) ||      // Hangul Compatibility Jamo
        (codepoint >= 0x3190 && codepoint <= 0x31BF) ||      // Kanbun
        (codepoint >= 0x31C0 && codepoint <= 0x31EF) ||      // CJK Strokes
        (codepoint >= 0x31F0 && codepoint <= 0x31FF) ||      // Katakana Phonetic Extensions
        (codepoint >= 0x3200 && codepoint <= 0x32FF) ||      // Enclosed CJK Letters and Months
        (codepoint >= 0x3300 && codepoint <= 0x33FF) ||      // CJK Compatibility
        (codepoint >= 0x3400 && codepoint <= 0x4DBF) ||      // CJK Unified Ideographs Extension A
        (codepoint >= 0x4E00 && codepoint <= 0x9FFF) ||      // CJK Unified Ideographs
        (codepoint >= 0xA000 && codepoint <= 0xA48F) ||      // Yi Syllables
        (codepoint >= 0xA490 && codepoint <= 0xA4CF) ||      // Yi Radicals
        (codepoint >= 0xAC00 && codepoint <= 0xD7A3) ||      // Hangul Syllables
        (codepoint >= 0xF900 && codepoint <= 0xFAFF) ||      // CJK Compatibility Ideographs
        (codepoint >= 0xFE10 && codepoint <= 0xFE19) ||      // Vertical Forms
        (codepoint >= 0xFE30 && codepoint <= 0xFE6F) ||      // CJK Compatibility Forms
        (codepoint >= 0xFF00 && codepoint <= 0xFF60) ||      // Fullwidth Forms
        (codepoint >= 0xFFE0 && codepoint <= 0xFFE6) ||      // Fullwidth Forms
        (codepoint >= 0x20000 && codepoint <= 0x2FFFD) ||    // CJK Unified Ideographs Extension B, C, D, E
        (codepoint >= 0x30000 && codepoint <= 0x3FFFD);      // CJK Unified Ideographs Extension F
    }

    constexpr fn DecodeUTF8(const StringView& str, usize& pos) -> char32_t {
      if (pos >= str.length())
        return 0;

      const fn getByte = [&](usize index) -> u8 {
        return static_cast<u8>(str[index]);
      };

      const u8 first = getByte(pos++);

      if ((first & 0x80) == 0) // ASCII (0xxxxxxx)
        return first;

      if ((first & 0xE0) == 0xC0) {
        // 2-byte sequence (110xxxxx 10xxxxxx)
        if (pos >= str.length())
          return 0;

        const u8 second = getByte(pos++);

        return ((first & 0x1F) << 6) | (second & 0x3F);
      }

      if ((first & 0xF0) == 0xE0) {
        // 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)
        if (pos + 1 >= str.length())
          return 0;

        const u8 second = getByte(pos++);
        const u8 third  = getByte(pos++);

        return ((first & 0x0F) << 12) | ((second & 0x3F) << 6) | (third & 0x3F);
      }

      if ((first & 0xF8) == 0xF0) {
        // 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)
        if (pos + 2 >= str.length())
          return 0;

        const u8 second = getByte(pos++);
        const u8 third  = getByte(pos++);
        const u8 fourth = getByte(pos++);

        return ((first & 0x07) << 18) | ((second & 0x3F) << 12) | ((third & 0x3F) << 6) | (fourth & 0x3F);
      }

      return 0; // Invalid UTF-8
    }

    constexpr fn GetVisualWidth(const StringView& str) -> usize {
      usize width    = 0;
      bool  inEscape = false;
      usize pos      = 0;

      while (pos < str.length()) {
        const char current = str[pos];

        if (inEscape) {
          inEscape = (current != 'm');
          pos++;
        } else if (current == '\033') {
          inEscape = true;
          pos++;
        } else {
          const char32_t codepoint = DecodeUTF8(str, pos);
          if (codepoint != 0)
            width += IsWideCharacter(codepoint) ? 2 : 1;
        }
      }

      return width;
    }

    constexpr fn CreateDistributedColorCircles(usize availableWidth) -> String {
      if (COLOR_CIRCLES.empty() || availableWidth == 0)
        return "";

      const usize circleWidth = GetVisualWidth(COLOR_CIRCLES.at(0));
      const usize numCircles  = COLOR_CIRCLES.size();

      const usize minSpacingPerGap  = 1;
      const usize totalMinSpacing   = (numCircles - 1) * minSpacingPerGap;
      const usize totalCirclesWidth = numCircles * circleWidth;
      const usize requiredWidth     = totalCirclesWidth + totalMinSpacing;
      const usize effectiveWidth    = std::max(availableWidth, requiredWidth);

      if (numCircles == 1) {
        const usize padding = effectiveWidth / 2;
        return String(padding, ' ') + String(COLOR_CIRCLES.at(0));
      }

      const usize totalSpacing   = effectiveWidth - totalCirclesWidth;
      const usize spacingBetween = totalSpacing / (numCircles - 1);

      String result;
      result.reserve(effectiveWidth);

      for (usize i = 0; i < numCircles; ++i) {
        if (i > 0)
          result.append(spacingBetween, ' ');

        const auto& circle = COLOR_CIRCLES.at(i);
        result.append(circle.data(), circle.size());
      }

      return result;
    }

    constexpr fn ProcessGroup(UIGroup& group) -> usize {
      if (group.rows.empty())
        return 0;

      group.iconWidths.reserve(group.rows.size());
      group.labelWidths.reserve(group.rows.size());
      group.valueWidths.reserve(group.rows.size());
      group.coloredIcons.reserve(group.rows.size());
      group.coloredLabels.reserve(group.rows.size());
      group.coloredValues.reserve(group.rows.size());

      usize groupMaxWidth = 0;

      for (const RowInfo& row : group.rows) {
        const usize labelWidth = GetVisualWidth(row.label);
        group.maxLabelWidth    = std::max(group.maxLabelWidth, labelWidth);

        const usize iconW  = GetVisualWidth(row.icon);
        const usize valueW = GetVisualWidth(row.value);

        group.iconWidths.push_back(iconW);
        group.labelWidths.push_back(labelWidth);
        group.valueWidths.push_back(valueW);

        group.coloredIcons.push_back(Colorize(row.icon, DEFAULT_THEME.icon));
        group.coloredLabels.push_back(Colorize(row.label, DEFAULT_THEME.label));
        group.coloredValues.push_back(Colorize(row.value, DEFAULT_THEME.value));

        groupMaxWidth = std::max(groupMaxWidth, iconW + valueW); // label handled after loop
      }

      groupMaxWidth += group.maxLabelWidth + 1;

      return groupMaxWidth;
    }

    constexpr fn RenderGroup(String& out, const UIGroup& group, const usize maxContentWidth, const String& hBorder, bool& hasRenderedContent) {
      if (group.rows.empty())
        return;

      if (hasRenderedContent) {
        out += "├";
        out += hBorder;
        out += "┤\n";
      }

      for (usize i = 0; i < group.rows.size(); ++i) {
        const usize leftWidth  = group.iconWidths[i] + group.maxLabelWidth;
        const usize rightWidth = group.valueWidths[i];
        const usize padding    = (maxContentWidth >= leftWidth + rightWidth)
             ? maxContentWidth - (leftWidth + rightWidth)
             : 0;

        out += "│";
        out += group.coloredIcons[i];
        out += group.coloredLabels[i];
        out.append(group.maxLabelWidth - group.labelWidths[i], ' ');
        out.append(padding, ' ');
        out += group.coloredValues[i];
        out += " │\n";
      }

      hasRenderedContent = true;
    }

    constexpr fn WordWrap(const StringView& text, const usize wrapWidth) -> Vec<String> {
      Vec<String> lines;

      if (wrapWidth == 0) {
        lines.emplace_back(text);
        return lines;
      }

      std::stringstream textStream((String(text)));
      String            word;
      String            currentLine;

      while (textStream >> word) {
        if (!currentLine.empty() && GetVisualWidth(currentLine) + GetVisualWidth(word) + 1 > wrapWidth) {
          lines.emplace_back(currentLine);
          currentLine.clear();
        }

        if (!currentLine.empty())
          currentLine += " ";

        currentLine += word;
      }

      if (!currentLine.empty())
        lines.emplace_back(currentLine);

      return lines;
    }

  } // namespace

#if DRAC_ENABLE_WEATHER
  fn CreateUI(const Config& config, const SystemInfo& data, Result<Report> weather, bool noAscii) -> String {
#else
  fn CreateUI(const Config& config, const SystemInfo& data, bool noAscii) -> String {
#endif
    const String& name     = config.general.getName();
    const Icons&  iconType = ICON_TYPE;

    UIGroup initialGroup;
    UIGroup systemInfoGroup;
    UIGroup hardwareGroup;
    UIGroup softwareGroup;
    UIGroup envInfoGroup;

    {
      if (data.date)
        initialGroup.rows.push_back({ .icon = iconType.calendar, .label = "Date", .value = *data.date });

#if DRAC_ENABLE_WEATHER
      if (weather) {
        const auto& [temperature, townName, description] = *weather;

        PCStr tempUnit =
          config.weather.units == services::weather::UnitSystem::Metric
          ? "C"
          : "F";

        initialGroup.rows.push_back(
          {
            .icon  = iconType.weather,
            .label = "Weather",
            .value = config.weather.showTownName && townName
              ? std::format("{}°{} in {}", std::lround(temperature), tempUnit, *townName)
              : std::format("{}°{}, {}", std::lround(temperature), tempUnit, description),
          }
        );
      }
#endif
    }

    {
      if (data.host && !data.host->empty())
        systemInfoGroup.rows.push_back({ .icon = iconType.host, .label = "Host", .value = *data.host });

      if (data.operatingSystem)
        systemInfoGroup.rows.push_back({
#ifdef __linux__
          .icon = GetDistroIcon(data.operatingSystem->id).value_or(iconType.os),
#else
          .icon = iconType.os,
#endif
          .label = "OS",
          .value = std::format("{} {}", data.operatingSystem->name, data.operatingSystem->version),
        });

      if (data.kernelVersion)
        systemInfoGroup.rows.push_back({ .icon = iconType.kernel, .label = "Kernel", .value = *data.kernelVersion });
    }

    {
      if (data.memInfo)
        hardwareGroup.rows.push_back({ .icon = iconType.memory, .label = "RAM", .value = std::format("{}/{}", BytesToGiB(data.memInfo->usedBytes), BytesToGiB(data.memInfo->totalBytes)) });

      if (data.diskUsage)
        hardwareGroup.rows.push_back({ .icon = iconType.disk, .label = "Disk", .value = std::format("{}/{}", BytesToGiB(data.diskUsage->usedBytes), BytesToGiB(data.diskUsage->totalBytes)) });

      if (data.cpuModel)
        hardwareGroup.rows.push_back({ .icon = iconType.cpu, .label = "CPU", .value = *data.cpuModel });

      if (data.gpuModel)
        hardwareGroup.rows.push_back({ .icon = iconType.gpu, .label = "GPU", .value = *data.gpuModel });

      if (data.uptime)
        hardwareGroup.rows.push_back({ .icon = iconType.uptime, .label = "Uptime", .value = std::format("{}", SecondsToFormattedDuration { *data.uptime }) });
    }

    {
      if (data.shell)
        softwareGroup.rows.push_back({ .icon = iconType.shell, .label = "Shell", .value = *data.shell });

#if DRAC_ENABLE_PACKAGECOUNT
      if (data.packageCount && *data.packageCount > 0)
        softwareGroup.rows.push_back({ .icon = iconType.package, .label = "Packages", .value = std::format("{}", *data.packageCount) });
#endif
    }

    {
      const bool deExists = data.desktopEnv.has_value();
      const bool wmExists = data.windowMgr.has_value();

      if (deExists && wmExists) {
        if (*data.desktopEnv == *data.windowMgr)
          envInfoGroup.rows.push_back({ .icon = iconType.windowManager, .label = "WM", .value = *data.windowMgr });
        else {
          envInfoGroup.rows.push_back({ .icon = iconType.desktopEnvironment, .label = "DE", .value = *data.desktopEnv });
          envInfoGroup.rows.push_back({ .icon = iconType.windowManager, .label = "WM", .value = *data.windowMgr });
        }
      } else if (deExists)
        envInfoGroup.rows.push_back({ .icon = iconType.desktopEnvironment, .label = "DE", .value = *data.desktopEnv });
      else if (wmExists)
        envInfoGroup.rows.push_back({ .icon = iconType.windowManager, .label = "WM", .value = *data.windowMgr });
    }

    Vec<UIGroup*> groups = { &initialGroup, &systemInfoGroup, &hardwareGroup, &softwareGroup, &envInfoGroup };

    usize maxContentWidth = 0;

    for (UIGroup* group : groups) {
      if (group->rows.empty())
        continue;

      maxContentWidth = std::max(maxContentWidth, ProcessGroup(*group));
    }

    String greetingLine = std::format("{}Hello {}!", iconType.user, name);
    maxContentWidth     = std::max(maxContentWidth, GetVisualWidth(greetingLine));

    // Calculate width needed for color circles (including minimum spacing)
    const usize circleWidth       = GetVisualWidth(COLOR_CIRCLES[0]);
    const usize totalCirclesWidth = COLOR_CIRCLES.size() * circleWidth;
    const usize minSpacingPerGap  = 1;
    const usize totalMinSpacing   = (COLOR_CIRCLES.size() - 1) * minSpacingPerGap;
    const usize colorCirclesWidth = GetVisualWidth(iconType.palette) + totalCirclesWidth + totalMinSpacing;
    maxContentWidth               = std::max(maxContentWidth, colorCirclesWidth);

#if DRAC_ENABLE_NOWPLAYING
    bool   nowPlayingActive = false;
    String npText;

    if (config.nowPlaying.enabled && data.nowPlaying) {
      npText           = std::format("{} - {}", data.nowPlaying->artist.value_or("Unknown Artist"), data.nowPlaying->title.value_or("Unknown Title"));
      nowPlayingActive = true;
    }
#endif

    String out;

    usize estimatedLines = 4;
    for (const UIGroup* grp : groups)
      estimatedLines += grp->rows.empty() ? 0 : (grp->rows.size() + 1);
#if DRAC_ENABLE_NOWPLAYING
    if (nowPlayingActive)
      ++estimatedLines;
#endif

    out.reserve(estimatedLines * (maxContentWidth + 4));

    const usize innerWidth = maxContentWidth + 1;

    String hBorder;
    hBorder.reserve(innerWidth * 3);
    for (usize i = 0; i < innerWidth; ++i) hBorder += "─";

    const fn createLine = [&](const String& left, const String& right = "") {
      const usize leftWidth  = GetVisualWidth(left);
      const usize rightWidth = GetVisualWidth(right);
      const usize padding    = (maxContentWidth >= leftWidth + rightWidth) ? maxContentWidth - (leftWidth + rightWidth) : 0;

      out += "│";
      out += left;
      out.append(padding, ' ');
      out += right;
      out += " │\n";
    };

    const fn createLeftAlignedLine = [&](const String& content) { createLine(content, ""); };

    // Top border and greeting
    out += "╭";
    out += hBorder;
    out += "╮\n";

    createLeftAlignedLine(Colorize(greetingLine, DEFAULT_THEME.icon));

    // Palette line
    out += "├";
    out += hBorder;
    out += "┤\n";

    const String paletteIcon    = Colorize(iconType.palette, DEFAULT_THEME.icon);
    const usize  availableWidth = maxContentWidth - GetVisualWidth(paletteIcon);
    createLeftAlignedLine(paletteIcon + CreateDistributedColorCircles(availableWidth));

    bool hasRenderedContent = true;

    for (const UIGroup* group : groups)
      RenderGroup(out, *group, maxContentWidth, hBorder, hasRenderedContent);

#if DRAC_ENABLE_NOWPLAYING
    if (nowPlayingActive) {
      if (hasRenderedContent) {
        out += "├";
        out += hBorder;
        out += "┤\n";
      }

      const String leftPart      = Colorize(iconType.music, DEFAULT_THEME.icon) + Colorize("Playing", DEFAULT_THEME.label);
      const usize  leftPartWidth = GetVisualWidth(leftPart);

      const usize availableWidth = maxContentWidth - leftPartWidth;

      const Vec<String> wrappedLines = WordWrap(npText, availableWidth);

      if (!wrappedLines.empty()) {
        createLine(leftPart, Colorize(wrappedLines[0], LogColor::Magenta));

        const String indent(leftPartWidth, ' ');

        for (usize i = 1; i < wrappedLines.size(); ++i) {
          String rightPart      = Colorize(wrappedLines[i], LogColor::Magenta);
          usize  rightPartWidth = GetVisualWidth(rightPart);

          usize padding = (maxContentWidth > leftPartWidth + rightPartWidth)
            ? maxContentWidth - leftPartWidth - rightPartWidth
            : 0;

          String lineContent = indent;
          lineContent.append(padding, ' ');
          lineContent.append(rightPart);
          createLine(lineContent);
        }
      }
    }
#endif

    out += "╰";
    out += hBorder;
    out += "╯\n";

    Vec<String>       boxLines;
    std::stringstream stream(out);
    String            line;

    while (std::getline(stream, line, '\n'))
      boxLines.push_back(line);

    if (!boxLines.empty() && boxLines.back().empty())
      boxLines.pop_back();

    Vec<StringView> asciiLines = ascii::GetAsciiArt(data.operatingSystem->id);

    if (noAscii || asciiLines.empty())
      return out;

    usize maxAsciiW = 0;
    for (const auto& line : asciiLines)
      maxAsciiW = std::max(maxAsciiW, GetVisualWidth(line));

    usize asciiHeight = asciiLines.size();

    String emptyAscii(maxAsciiW, ' ');

    usize  boxWidth = GetVisualWidth(boxLines[0]);
    String emptyBox = "│" + String(boxWidth - 2, ' ') + "│";

    usize boxContentHeight = boxLines.size() - 2;
    usize totalHeight      = std::max(asciiHeight, boxContentHeight + 2);

    usize asciiPadTop = (totalHeight > asciiHeight) ? (totalHeight - asciiHeight) / 2 : 0;

    usize boxPadTop    = (totalHeight > boxContentHeight + 2) ? (totalHeight - boxContentHeight - 2) / 2 : 0;
    usize boxPadBottom = (totalHeight > boxContentHeight + 2) ? (totalHeight - boxContentHeight - 2 - boxPadTop) : 0;

    Vec<String> extendedBox;

    extendedBox.push_back(boxLines[0]);

    for (usize j = 0; j < boxPadTop; ++j) extendedBox.push_back(emptyBox);
    for (usize j = 1; j < boxLines.size() - 1; ++j) extendedBox.push_back(boxLines[j]);
    for (usize j = 0; j < boxPadBottom; ++j) extendedBox.push_back(emptyBox);

    extendedBox.push_back(boxLines.back());

    usize extendedBoxHeight = extendedBox.size();

    totalHeight = std::max(asciiHeight, extendedBoxHeight);

    asciiPadTop = (totalHeight - asciiHeight) / 2;

    String newOut;
    for (usize i = 0; i < totalHeight; ++i) {
      String outputLine;

      if (i < asciiPadTop || i >= asciiPadTop + asciiHeight) {
        outputLine += emptyAscii;
      } else {
        const auto& asciiLine = asciiLines[i - asciiPadTop];
        outputLine.append(asciiLine.data(), asciiLine.size());
        outputLine.append(maxAsciiW - GetVisualWidth(asciiLine), ' ');
        outputLine += "\033[0m";
      }

      outputLine += "  ";

      if (i < extendedBoxHeight)
        outputLine += extendedBox[i];
      else
        outputLine += emptyBox;

      newOut += outputLine + "\n";
    }
    return newOut;
  }
} // namespace draconis::ui
</file>

<file path="src/Lib/OS/Linux.cpp">
#ifdef __linux__

  #include <algorithm>
  #include <arpa/inet.h>          // inet_ntop
  #include <chrono>               // std::chrono::minutes
  #include <cpuid.h>              // __get_cpuid
  #include <cstring>              // std::strlen
  #include <expected>             // std::{unexpected, expected}
  #include <fcntl.h>              // open, O_RDONLY, O_CLOEXEC
  #include <filesystem>           // std::filesystem::{current_path, directory_entry, directory_iterator, etc.}
  #include <format>               // std::{format, format_to_n}
  #include <fstream>              // std::ifstream
  #include <glaze/beve/read.hpp>  // glz::read_beve
  #include <glaze/beve/write.hpp> // glz::write_beve
  #include <ifaddrs.h>            // getifaddrs, freeifaddrs, ifaddrs
  #include <linux/if_packet.h>    // sockaddr_ll
  #include <linux/limits.h>       // PATH_MAX
  #include <map>                  // std::map
  #include <matchit.hpp>          // matchit::{is, is_not, is_any, etc.}
  #include <net/if.h>             // IFF_UP, IFF_LOOPBACK
  #include <netdb.h>              // getnameinfo, NI_NUMERICHOST
  #include <netinet/in.h>         // sockaddr_in
  #include <ranges>               // std::views::{common, split, values}
  #include <sstream>              // std::istringstream
  #include <string>               // std::{getline, string (String)}
  #include <string_view>          // std::string_view (StringView)
  #include <sys/mman.h>           // mmap, munmap
  #include <sys/socket.h>         // ucred, getsockopt, SOL_SOCKET, SO_PEERCRED
  #include <sys/stat.h>           // fstat
  #include <sys/statvfs.h>        // statvfs
  #include <sys/sysinfo.h>        // sysinfo
  #include <sys/utsname.h>        // utsname, uname
  #include <unistd.h>             // readlink
  #include <utility>              // std::move

  #include "Drac++/Core/System.hpp"
  #include "Drac++/Services/Packages.hpp"

  #include "Drac++/Utils/CacheManager.hpp"
  #include "Drac++/Utils/DataTypes.hpp"
  #include "Drac++/Utils/Env.hpp"
  #include "Drac++/Utils/Error.hpp"
  #include "Drac++/Utils/Logging.hpp"
  #include "Drac++/Utils/Types.hpp"

  #include "Wrappers/DBus.hpp"
  #include "Wrappers/Wayland.hpp"
  #include "Wrappers/XCB.hpp"

using draconis::utils::error::DracError;
using enum draconis::utils::error::DracErrorCode;
using namespace draconis::utils::types;
namespace fs = std::filesystem;

// clang-format off
#ifdef __GLIBC__
extern "C" fn issetugid() -> usize { return 0; } // NOLINT(readability-identifier-naming) - glibc function stub
#endif
// clang-format on

namespace {
  template <std::integral T>
  constexpr fn TryParse(StringView sview) -> Option<T> {
    T value;

    auto [ptr, ec] = std::from_chars(sview.data(), sview.data() + sview.size(), value);

    if (ec == std::errc() && ptr == sview.data() + sview.size())
      return value;

    return None;
  }

  fn ReadSysFile(const fs::path& path) -> Result<String> {
    std::ifstream file(path);
    if (!file.is_open())
      ERR_FMT(NotFound, "Failed to open sysfs file: {}", path.string());

    String line;

    if (std::getline(file, line)) {
      if (const usize pos = line.find_last_not_of(" \t\n\r"); pos != String::npos)
        line.erase(pos + 1);

      return line;
    }

    ERR_FMT(IoError, "Failed to read from sysfs file: {}", path.string());
  }

  fn LookupPciNamesFromBuffer(StringView buffer, const StringView vendorId, const StringView deviceId) -> Result<Pair<String, String>> {
    using std::views::common;
    using std::views::split;

    const StringView vendorIdStr = vendorId.starts_with("0x") ? vendorId.substr(2) : vendorId;
    const StringView deviceIdStr = deviceId.starts_with("0x") ? deviceId.substr(2) : deviceId;

    bool       vendorFound       = false;
    StringView currentVendorName = {};

    for (auto lineRange : buffer | split('\n') | common) {
      StringView line(&*lineRange.begin(), lineRange.size());

      if (line.empty() || line.front() == '#')
        continue;

      if (line.front() != '\t') {
        vendorFound = false;

        if (line.starts_with(vendorIdStr)) {
          vendorFound = true;
          if (const usize namePos = line.find("  "); namePos != String::npos)
            currentVendorName = line.substr(namePos + 2);
        }
      } else if (vendorFound && line.size() > 1 && line[1] != '\t') {
        const StringView deviceLine = line.substr(1); // skip leading tab

        if (deviceLine.starts_with(deviceIdStr))
          if (const usize namePos = line.find("  "); namePos != String::npos)
            return Pair(String(currentVendorName), String(line.substr(namePos + 2)));
      }
    }

    ERR_FMT(NotFound, "PCI device with vendor ID '{}' and device ID '{}' not found in PCI IDs buffer", vendorId, deviceId);
  }

  #ifdef DRAC_USE_LINKED_PCI_IDS
  extern "C" {
    extern const char _binary_pci_ids_start[];
    extern const char _binary_pci_ids_end[];
  }

  fn LookupPciNames(const StringView vendorId, const StringView deviceId) -> Result<Pair<String, String>> {
    const usize pciIdsLen = _binary_pci_ids_end - _binary_pci_ids_start;

    return LookupPciNamesFromBuffer(StringView(_binary_pci_ids_start, pciIdsLen), vendorId, deviceId);
  }
  #else
  fn FindPciIDsPath() -> fs::path {
    const Array<fs::path, 3> knownPaths = {
      "/usr/share/hwdata/pci.ids",
      "/usr/share/misc/pci.ids",
      "/usr/share/pci.ids"
    };

    for (const fs::path& path : knownPaths)
      if (fs::exists(path))
        return path;

    return {};
  }

  fn LookupPciNames(const StringView vendorId, const StringView deviceId) -> Result<Pair<String, String>> {
    const fs::path& pciIdsPath = FindPciIDsPath();

    if (pciIdsPath.empty())
      ERR(NotFound, "Could not find pci.ids");

    const i32 filedesc = open(pciIdsPath.c_str(), O_RDONLY | O_CLOEXEC);

    if (filedesc >= 0) {
      struct stat statbuf {};

      if (fstat(filedesc, &statbuf) == 0 && statbuf.st_size > 0) {
        RawPointer mapped = mmap(nullptr, statbuf.st_size, PROT_READ, MAP_PRIVATE, filedesc, 0);

        if (mapped != MAP_FAILED) {
          Result<Pair<String, String>> result = LookupPciNamesFromBuffer(
            StringView(static_cast<PCStr>(mapped), static_cast<usize>(statbuf.st_size)),
            vendorId,
            deviceId
          );

          munmap(mapped, statbuf.st_size);
          close(filedesc);

          return result;
        }
      }

      close(filedesc);
    }

    std::ifstream file(pciIdsPath, std::ios::binary);

    if (!file)
      ERR_FMT(NotFound, "Could not open {}", pciIdsPath.string());

    std::string contents((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());

    return LookupPciNamesFromBuffer(StringView(contents), vendorId, deviceId);
  }
  #endif

  constexpr fn CleanGpuModelName(String vendor, String device) -> String {
    if (vendor.find("[AMD/ATI]") != String::npos)
      vendor = "AMD";
    else if (const usize pos = vendor.find(' '); pos != String::npos)
      vendor = vendor.substr(0, pos);

    if (const usize openPos = device.find('['); openPos != String::npos)
      if (const usize closePos = device.find(']', openPos); closePos != String::npos)
        device = device.substr(openPos + 1, closePos - openPos - 1);

    constexpr fn trim = [](String& str) {
      if (const usize pos = str.find_last_not_of(" \t\n\r"); pos != String::npos)
        str.erase(pos + 1);
      if (const usize pos = str.find_first_not_of(" \t\n\r"); pos != String::npos)
        str.erase(0, pos);
    };

    trim(vendor);
    trim(device);

    return std::format("{} {}", vendor, device);
  }

  #ifdef DRAC_USE_XCB
  fn GetX11WindowManager() -> Result<String> {
    using namespace XCB;
    using namespace matchit;
    using enum ConnError;

    const DisplayGuard conn;

    if (!conn)
      if (const i32 err = ConnectionHasError(conn.get()))
        ERR(
          ApiUnavailable,
          match(err)(
            is | Generic         = "Stream/Socket/Pipe Error",
            is | ExtNotSupported = "Extension Not Supported",
            is | MemInsufficient = "Insufficient Memory",
            is | ReqLenExceed    = "Request Length Exceeded",
            is | ParseErr        = "Display String Parse Error",
            is | InvalidScreen   = "Invalid Screen",
            is | FdPassingFailed = "FD Passing Failed",
            is | _               = std::format("Unknown Error Code ({})", err)
          )
        );

    const fn internAtom = [&conn](const StringView name) -> Result<Atom> {
      const ReplyGuard<IntAtomReply> reply(InternAtomReply(conn.get(), InternAtom(conn.get(), 0, static_cast<u16>(name.size()), name.data()), nullptr));

      if (!reply)
        ERR_FMT(PlatformSpecific, "Failed to get X11 atom reply for '{}'", name);

      return reply->atom;
    };

    const Result<Atom> supportingWmCheckAtom = internAtom("_NET_SUPPORTING_WM_CHECK");
    const Result<Atom> wmNameAtom            = internAtom("_NET_WM_NAME");
    const Result<Atom> utf8StringAtom        = internAtom("UTF8_STRING");

    if (!supportingWmCheckAtom || !wmNameAtom || !utf8StringAtom) {
      if (!supportingWmCheckAtom)
        error_log("Failed to get _NET_SUPPORTING_WM_CHECK atom");

      if (!wmNameAtom)
        error_log("Failed to get _NET_WM_NAME atom");

      if (!utf8StringAtom)
        error_log("Failed to get UTF8_STRING atom");

      ERR(PlatformSpecific, "Failed to get X11 atoms");
    }

    const ReplyGuard<GetPropReply> wmWindowReply(GetPropertyReply(
      conn.get(),
      GetProperty(conn.get(), 0, conn.rootScreen()->root, *supportingWmCheckAtom, ATOM_WINDOW, 0, 1),
      nullptr
    ));

    if (!wmWindowReply || wmWindowReply->type != ATOM_WINDOW || wmWindowReply->format != 32 ||
        GetPropertyValueLength(wmWindowReply.get()) == 0)
      ERR(NotFound, "Failed to get _NET_SUPPORTING_WM_CHECK property");

    const Window wmRootWindow = *static_cast<Window*>(GetPropertyValue(wmWindowReply.get()));

    const ReplyGuard<GetPropReply> wmNameReply(GetPropertyReply(
      conn.get(),
      GetProperty(
        conn.get(),
        0,
        wmRootWindow,
        *wmNameAtom,
        *utf8StringAtom,
        0,
        1024
      ),
      nullptr
    ));

    if (!wmNameReply || wmNameReply->type != *utf8StringAtom || GetPropertyValueLength(wmNameReply.get()) == 0)
      ERR(NotFound, "Failed to get _NET_WM_NAME property");

    const char* nameData = static_cast<const char*>(GetPropertyValue(wmNameReply.get()));
    const usize length   = GetPropertyValueLength(wmNameReply.get());

    return String(nameData, length);
  }

  fn GetX11Displays() -> Result<Vec<DisplayInfo>> {
    using namespace XCB;

    DisplayGuard conn;
    if (!conn)
      ERR(ApiUnavailable, "Failed to connect to X server");

    const Setup* setup = conn.setup();
    if (!setup)
      ERR(ApiUnavailable, "Failed to get X server setup");

    const ReplyGuard<QueryExtensionReply> randrQueryReply(
      GetQueryExtensionReply(conn.get(), QueryExtension(conn.get(), std::strlen("RANDR"), "RANDR"), nullptr)
    );

    if (!randrQueryReply || !randrQueryReply->present)
      ERR(NotSupported, "X server does not support RANDR extension");

    Screen* screen = conn.rootScreen();
    if (!screen)
      ERR(NotFound, "Failed to get X root screen");

    const ReplyGuard<RandrGetScreenResourcesCurrentReply> screenResourcesReply(
      GetScreenResourcesCurrentReply(
        conn.get(), GetScreenResourcesCurrent(conn.get(), screen->root), nullptr
      )
    );

    if (!screenResourcesReply)
      ERR(ApiUnavailable, "Failed to get screen resources");

    RandrOutput* outputs     = GetScreenResourcesCurrentOutputs(screenResourcesReply.get());
    const i32    outputCount = GetScreenResourcesCurrentOutputsLength(screenResourcesReply.get());

    if (outputCount == 0)
      return {};

    Vec<DisplayInfo> displays;
    i32              primaryIndex = -1;

    const ReplyGuard<RandrGetOutputPrimaryReply> primaryOutputReply(
      GetOutputPrimaryReply(conn.get(), GetOutputPrimary(conn.get(), screen->root), nullptr)
    );
    const RandrOutput primaryOutput = primaryOutputReply ? primaryOutputReply->output : NONE;

    for (i32 i = 0; i < outputCount; ++i) {
      const ReplyGuard<RandrGetOutputInfoReply> outputInfoReply(
        GetOutputInfoReply(conn.get(), GetOutputInfo(conn.get(), *std::next(outputs, i), CURRENT_TIME), nullptr)
      );

      if (!outputInfoReply || outputInfoReply->crtc == NONE)
        continue;

      const ReplyGuard<RandrGetCrtcInfoReply> crtcInfoReply(
        GetCrtcInfoReply(conn.get(), GetCrtcInfo(conn.get(), outputInfoReply->crtc, CURRENT_TIME), nullptr)
      );

      if (!crtcInfoReply)
        continue;

      f64 refreshRate = 0;

      if (crtcInfoReply->mode != NONE) {
        RandrModeInfo* modeInfo = nullptr;
        for (RandrModeInfoIterator modesIter = GetScreenResourcesCurrentModesIterator(screenResourcesReply.get()); modesIter.rem; ModeInfoNext(&modesIter))
          if (modesIter.data->id == crtcInfoReply->mode) {
            modeInfo = modesIter.data;
            break;
          }

        if (modeInfo && modeInfo->htotal > 0 && modeInfo->vtotal > 0)
          refreshRate = static_cast<f64>(modeInfo->dot_clock) / (static_cast<f64>(modeInfo->htotal) * static_cast<f64>(modeInfo->vtotal));
      }

      bool isPrimary = (*std::next(outputs, i) == primaryOutput);
      if (isPrimary)
        primaryIndex = static_cast<int>(displays.size());

      displays.emplace_back(
        *std::next(outputs, i),
        DisplayInfo::Resolution { .width = crtcInfoReply->width, .height = crtcInfoReply->height },
        refreshRate,
        isPrimary
      );
    }

    // If no display was marked as primary, set the first one as primary
    if (primaryIndex == -1 && !displays.empty())
      displays[0].isPrimary = true;
    else if (primaryIndex > 0)
      // Ensure only one display is marked as primary
      for (i32 i = 0; i < static_cast<i32>(displays.size()); ++i)
        if (i != primaryIndex)
          displays[i].isPrimary = false;

    return displays;
  }

  fn GetX11PrimaryDisplay() -> Result<DisplayInfo> {
    using namespace XCB;

    DisplayGuard conn;
    if (!conn)
      ERR(ApiUnavailable, "Failed to connect to X server");

    Screen* screen = conn.rootScreen();
    if (!screen)
      ERR(NotFound, "Failed to get X root screen");

    const ReplyGuard<RandrGetOutputPrimaryReply> primaryOutputReply(
      GetOutputPrimaryReply(conn.get(), GetOutputPrimary(conn.get(), screen->root), nullptr)
    );

    const RandrOutput primaryOutput = primaryOutputReply ? primaryOutputReply->output : NONE;

    if (primaryOutput == NONE)
      ERR(NotFound, "No primary output found");

    const ReplyGuard<RandrGetOutputInfoReply> outputInfoReply(
      GetOutputInfoReply(conn.get(), GetOutputInfo(conn.get(), primaryOutput, CURRENT_TIME), nullptr)
    );

    if (!outputInfoReply || outputInfoReply->crtc == NONE)
      ERR(NotFound, "Failed to get output info for primary display");

    const ReplyGuard<RandrGetCrtcInfoReply> crtcInfoReply(
      GetCrtcInfoReply(conn.get(), GetCrtcInfo(conn.get(), outputInfoReply->crtc, CURRENT_TIME), nullptr)
    );

    if (!crtcInfoReply)
      ERR(NotFound, "Failed to get CRTC info for primary display");

    f64 refreshRate = 0;
    if (crtcInfoReply->mode != NONE) {
      const ReplyGuard<RandrGetScreenResourcesCurrentReply> screenResourcesReply(
        GetScreenResourcesCurrentReply(
          conn.get(), GetScreenResourcesCurrent(conn.get(), screen->root), nullptr
        )
      );

      if (screenResourcesReply) {
        RandrModeInfo*        modeInfo  = nullptr;
        RandrModeInfoIterator modesIter = GetScreenResourcesCurrentModesIterator(screenResourcesReply.get());
        for (; modesIter.rem; ModeInfoNext(&modesIter)) {
          if (modesIter.data->id == crtcInfoReply->mode) {
            modeInfo = modesIter.data;
            break;
          }
        }
        if (modeInfo && modeInfo->htotal > 0 && modeInfo->vtotal > 0)
          refreshRate = static_cast<f64>(modeInfo->dot_clock) / (static_cast<f64>(modeInfo->htotal) * static_cast<f64>(modeInfo->vtotal));
      }
    }

    return DisplayInfo(
      primaryOutput,
      DisplayInfo::Resolution { .width = crtcInfoReply->width, .height = crtcInfoReply->height },
      refreshRate,
      true
    );
  }
  #else
  fn GetX11WindowManager() -> Result<String> {
    ERR(NotSupported, "XCB (X11) support not available");
  }

  fn GetX11Displays() -> Result<Vec<DisplayInfo>> {
    ERR(NotSupported, "XCB (X11) support not available");
  }

  fn GetX11PrimaryDisplay() -> Result<DisplayInfo> {
    ERR(NotSupported, "XCB (X11) support not available");
  }
  #endif

  #ifdef DRAC_USE_WAYLAND
  fn GetWaylandCompositor() -> Result<String> {
    const Wayland::DisplayGuard display;

    if (!display)
      ERR(ApiUnavailable, "Failed to connect to display (is Wayland running?)");

    const i32 fileDescriptor = display.fd();
    if (fileDescriptor < 0)
      ERR(ApiUnavailable, "Failed to get Wayland file descriptor");

    ucred     cred {};
    socklen_t len = sizeof(cred);

    if (getsockopt(fileDescriptor, SOL_SOCKET, SO_PEERCRED, &cred, &len) == -1)
      ERR(ApiUnavailable, "Failed to get socket credentials (SO_PEERCRED)");

    Array<char, 128> exeLinkPathBuf {};

    auto [out, size] = std::format_to_n(exeLinkPathBuf.data(), exeLinkPathBuf.size() - 1, "/proc/{}/exe", cred.pid);

    if (out >= exeLinkPathBuf.data() + exeLinkPathBuf.size() - 1)
      ERR(InternalError, "Failed to format /proc path (PID too large?)");

    *out = '\0';

    const char* exeLinkPath = exeLinkPathBuf.data();

    Array<char, PATH_MAX> exeRealPathBuf {}; // NOLINT(misc-include-cleaner) - PATH_MAX is in <climits>

    const isize bytesRead = readlink(exeLinkPath, exeRealPathBuf.data(), exeRealPathBuf.size() - 1);

    if (bytesRead == -1)
      ERR_FMT(IoError, "Failed to read link '{}'", exeLinkPath);

    exeRealPathBuf.at(bytesRead) = '\0';

    StringView compositorNameView;

    const StringView pathView(exeRealPathBuf.data(), bytesRead);

    StringView filenameView;

    if (const usize lastCharPos = pathView.find_last_not_of('/'); lastCharPos != StringView::npos) {
      const StringView relevantPart = pathView.substr(0, lastCharPos + 1);

      if (const usize separatorPos = relevantPart.find_last_of('/'); separatorPos == StringView::npos)
        filenameView = relevantPart;
      else
        filenameView = relevantPart.substr(separatorPos + 1);
    }

    if (!filenameView.empty())
      compositorNameView = filenameView;

    if (compositorNameView.empty() || compositorNameView == "." || compositorNameView == "/")
      ERR(ParseError, "Failed to get compositor name from path");

    if (constexpr StringView wrappedSuffix = "-wrapped"; compositorNameView.length() > 1 + wrappedSuffix.length() &&
        compositorNameView[0] == '.' && compositorNameView.ends_with(wrappedSuffix)) {
      const StringView cleanedView =
        compositorNameView.substr(1, compositorNameView.length() - 1 - wrappedSuffix.length());

      if (cleanedView.empty())
        ERR(ParseError, "Compositor name invalid after heuristic");

      return String(cleanedView);
    }

    return String(compositorNameView);
  }

  fn GetWaylandDisplays() -> Result<Vec<DisplayInfo>> {
    const Wayland::DisplayGuard display;
    if (!display)
      ERR(ApiUnavailable, "Failed to connect to Wayland display");

    Wayland::DisplayManager manager(display.get());
    return manager.getOutputs();
  }

  fn GetWaylandPrimaryDisplay() -> Result<DisplayInfo> {
    const Wayland::DisplayGuard display;

    if (!display)
      ERR(ApiUnavailable, "Failed to connect to Wayland display");

    Wayland::DisplayManager manager(display.get());
    DisplayInfo             primaryDisplay = manager.getPrimary();

    if (primaryDisplay.resolution.width == 0 && primaryDisplay.resolution.height == 0)
      ERR(NotFound, "No primary Wayland display found");

    return primaryDisplay;
  }
  #else
  fn GetWaylandCompositor() -> Result<String> {
    ERR(NotSupported, "Wayland support not available");
  }

  fn GetWaylandDisplays() -> Result<Vec<DisplayInfo>> {
    ERR(NotSupported, "Wayland support not available");
  }

  fn GetWaylandPrimaryDisplay() -> Result<DisplayInfo> {
    ERR(NotSupported, "Wayland support not available");
  }
  #endif

  fn CollectNetworkInterfaces() -> Result<Map<String, NetworkInterface>> {
    ifaddrs* ifaddrList = nullptr;
    if (getifaddrs(&ifaddrList) == -1)
      ERR_FMT(InternalError, "getifaddrs failed: {}", strerror(errno));

    // Ensure we free the list when we're done
    UniquePointer<ifaddrs, decltype(&freeifaddrs)> ifaddrsDeleter(ifaddrList, &freeifaddrs);

    Map<String, NetworkInterface> interfaceMap;

    for (ifaddrs* ifa = ifaddrList; ifa != nullptr; ifa = ifa->ifa_next) {
      using matchit::match, matchit::is, matchit::_;

      if (ifa->ifa_addr == nullptr)
        continue;

      NetworkInterface& interface = interfaceMap[ifa->ifa_name];
      interface.name              = ifa->ifa_name;

      interface.isUp       = ifa->ifa_flags & IFF_UP;
      interface.isLoopback = ifa->ifa_flags & IFF_LOOPBACK;

      match(ifa->ifa_addr->sa_family)(
        is | AF_INET = [&]() { // IPv4
          Array<char, NI_MAXHOST> host = {};
          if (getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in), host.data(), host.size(), nullptr, 0, NI_NUMERICHOST) == 0)
            interface.ipv4Address = { host.data() };
        },
        is | AF_INET6 = [&]() { // IPv6
          Array<char, NI_MAXHOST> host = {};
          if (getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in6), host.data(), host.size(), nullptr, 0, NI_NUMERICHOST) == 0)
            interface.ipv6Address = { host.data() };
        },
        is | AF_PACKET = [&]() { // MAC address
          // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
          auto* sll = reinterpret_cast<sockaddr_ll*>(ifa->ifa_addr);

          if (sll && sll->sll_halen == 6)
            interface.macAddress = std::format(
              "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
              sll->sll_addr[0],
              sll->sll_addr[1],
              sll->sll_addr[2],
              sll->sll_addr[3],
              sll->sll_addr[4],
              sll->sll_addr[5]
            );
        },
        is | _ = [&]() { return; }
      );
    }

    if (interfaceMap.empty())
      ERR(NotFound, "No network interfaces found");

    return interfaceMap;
  }
} // namespace

namespace draconis::core::system {
  using draconis::utils::cache::CacheManager;
  using draconis::utils::env::GetEnv;

  namespace linux {
    fn GetDistroID(CacheManager& cache) -> Result<String> {
      return cache.getOrSet<String>("linux_distro_id", []() -> Result<String> {
        std::ifstream file("/etc/os-release");

        if (!file.is_open())
          ERR(NotFound, "Failed to open /etc/os-release");

        String line;

        while (std::getline(file, line)) {
          if (StringView(line).starts_with("ID=")) {
            String value = line.substr(3);

            if ((value.length() >= 2 && value.front() == '"' && value.back() == '"') ||
                (value.length() >= 2 && value.front() == '\'' && value.back() == '\''))
              value = value.substr(1, value.length() - 2);

            if (value.empty())
              ERR(ParseError, "ID value is empty or only quotes in /etc/os-release");

            return String(value);
          }
        }

        ERR(NotFound, "ID line not found in /etc/os-release");
      });
    }
  } // namespace linux

  fn GetOperatingSystem(CacheManager& cache) -> Result<OSInfo> {
    return cache.getOrSet<OSInfo>("linux_os_version", []() -> Result<OSInfo> {
      std::ifstream file("/etc/os-release");

      if (!file.is_open())
        ERR(NotFound, "Failed to open /etc/os-release");

      String osName, osVersion, osId;

      String line;

      const fn parseValue = [&](String& val) {
        if (val.length() >= 2 && ((val.front() == '"' && val.back() == '"') || (val.front() == '\'' && val.back() == '\'')))
          val = val.substr(1, val.length() - 2);
      };

      while (std::getline(file, line)) {
        const StringView lineView = line;

        if (lineView.starts_with("NAME=")) {
          osName = lineView.substr(5);
          parseValue(osName);
        } else if (lineView.starts_with("VERSION=")) {
          osVersion = lineView.substr(8);
          parseValue(osVersion);
        } else if (lineView.starts_with("ID=")) {
          osId = lineView.substr(3);
          parseValue(osId);
        } else if (lineView.starts_with("PRETTY_NAME=") && osName.empty()) {
          osName = lineView.substr(12);
          parseValue(osName);
        } else if (lineView.starts_with("VERSION_ID=") && osVersion.empty()) {
          osVersion = lineView.substr(11);
          parseValue(osVersion);
        }
      }

      if (osId.empty())
        ERR(NotFound, "ID not found in /etc/os-release");

      if (osName.empty())
        ERR(NotFound, "NAME or PRETTY_NAME not found in /etc/os-release");

      if (osVersion.empty())
        osVersion = "";

      return OSInfo(std::move(osName), std::move(osVersion), std::move(osId));
    });
  }

  fn GetMemInfo(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    struct sysinfo info;

    if (sysinfo(&info) != 0)
      ERR(ApiUnavailable, "sysinfo call failed");

    if (info.mem_unit == 0)
      ERR(PlatformSpecific, "sysinfo.mem_unit is 0, cannot calculate memory");

    return ResourceUsage((info.totalram - info.freeram - info.bufferram) * info.mem_unit, info.totalram * info.mem_unit);
  }

  fn GetNowPlaying() -> Result<MediaInfo> {
  #ifdef DRAC_ENABLE_NOWPLAYING
    using namespace DBus;

    Result<Connection> connectionResult = Connection::busGet(DBUS_BUS_SESSION);
    if (!connectionResult)
      ERR_FMT(ApiUnavailable, "Failed to get DBus session connection: {}", connectionResult.error().message);

    const Connection& connection = *connectionResult;

    Option<String> activePlayer = None;

    {
      Result<Message> listNamesResult =
        Message::newMethodCall("org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", "ListNames");
      if (!listNamesResult)
        ERR_FMT(ApiUnavailable, "Failed to get DBus ListNames message: {}", listNamesResult.error().message);

      Result<Message> listNamesReplyResult = connection.sendWithReplyAndBlock(*listNamesResult, 100);
      if (!listNamesReplyResult)
        ERR_FMT(ApiUnavailable, "Failed to send DBus ListNames message: {}", listNamesReplyResult.error().message);

      MessageIter iter = listNamesReplyResult->iterInit();
      if (!iter.isValid() || iter.getArgType() != DBUS_TYPE_ARRAY)
        ERR(ParseError, "Invalid DBus ListNames reply format: Expected array");

      MessageIter subIter = iter.recurse();
      if (!subIter.isValid())
        ERR(ParseError, "Invalid DBus ListNames reply format: Could not recurse into array");

      while (subIter.getArgType() != DBUS_TYPE_INVALID) {
        if (Option<String> name = subIter.getString(); name && name->starts_with("org.mpris.MediaPlayer2.")) {
          activePlayer = std::move(*name);
          break;
        }

        if (!subIter.next())
          break;
      }
    }

    if (!activePlayer)
      ERR(NotFound, "No active MPRIS players found");

    Result<Message> msgResult = Message::newMethodCall(
      activePlayer->c_str(), "/org/mpris/MediaPlayer2", "org.freedesktop.DBus.Properties", "Get"
    );

    if (!msgResult)
      ERR_FMT(ApiUnavailable, "Failed to create DBus Properties.Get message: {}", msgResult.error().message);

    Message& msg = *msgResult;

    if (!msg.appendArgs("org.mpris.MediaPlayer2.Player", "Metadata"))
      ERR(InternalError, "Failed to append arguments to Properties.Get message");

    Result<Message> replyResult = connection.sendWithReplyAndBlock(msg, 100);

    if (!replyResult)
      ERR_FMT(ApiUnavailable, "Failed to send DBus Properties.Get message: {}", replyResult.error().message);

    Option<String> title  = None;
    Option<String> artist = None;

    MessageIter propIter = replyResult->iterInit();
    if (!propIter.isValid())
      ERR(ParseError, "Properties.Get reply has no arguments or invalid iterator");

    if (propIter.getArgType() != DBUS_TYPE_VARIANT)
      ERR(ParseError, "Properties.Get reply argument is not a variant");

    MessageIter variantIter = propIter.recurse();
    if (!variantIter.isValid())
      ERR(ParseError, "Could not recurse into variant");

    if (variantIter.getArgType() != DBUS_TYPE_ARRAY || variantIter.getElementType() != DBUS_TYPE_DICT_ENTRY)
      ERR(ParseError, "Metadata variant content is not a dictionary array (a{sv})");

    MessageIter dictIter = variantIter.recurse();
    if (!dictIter.isValid())
      ERR(ParseError, "Could not recurse into metadata dictionary array");

    while (dictIter.getArgType() == DBUS_TYPE_DICT_ENTRY) {
      MessageIter entryIter = dictIter.recurse();
      if (!entryIter.isValid()) {
        if (!dictIter.next())
          break;
        continue;
      }

      Option<String> key = entryIter.getString();
      if (!key) {
        if (!dictIter.next())
          break;
        continue;
      }

      if (!entryIter.next() || entryIter.getArgType() != DBUS_TYPE_VARIANT) {
        if (!dictIter.next())
          break;
        continue;
      }

      MessageIter valueVariantIter = entryIter.recurse();
      if (!valueVariantIter.isValid()) {
        if (!dictIter.next())
          break;
        continue;
      }

      if (*key == "xesam:title") {
        title = valueVariantIter.getString();
      } else if (*key == "xesam:artist") {
        if (valueVariantIter.getArgType() == DBUS_TYPE_ARRAY && valueVariantIter.getElementType() == DBUS_TYPE_STRING) {
          if (MessageIter artistArrayIter = valueVariantIter.recurse(); artistArrayIter.isValid())
            artist = artistArrayIter.getString();
        }
      }

      if (!dictIter.next())
        break;
    }

    return MediaInfo(std::move(title), std::move(artist));
  #else
    ERR(NotSupported, "DBus support not available");
  #endif
  }

  fn GetWindowManager(CacheManager& cache) -> Result<String> {
  #if !defined(DRAC_USE_WAYLAND) && !defined(DRAC_USE_XCB)
    ERR(NotSupported, "Wayland or XCB support not available");
  #endif

    return cache.getOrSet<String>("linux_wm", [&]() -> Result<String> {
      if (GetEnv("WAYLAND_DISPLAY"))
        return GetWaylandCompositor();

      if (GetEnv("DISPLAY"))
        return GetX11WindowManager();

      ERR(NotFound, "No display server detected");
    });
  }

  fn GetDesktopEnvironment(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("linux_desktop_environment", []() -> Result<String> {
      Result<PCStr> xdgEnvResult = GetEnv("XDG_CURRENT_DESKTOP");

      if (xdgEnvResult) {
        String xdgDesktopSz = String(*xdgEnvResult);

        if (const usize colonPos = xdgDesktopSz.find(':'); colonPos != String::npos)
          xdgDesktopSz.resize(colonPos);

        return xdgDesktopSz;
      }

      Result<PCStr> desktopSessionResult = GetEnv("DESKTOP_SESSION");

      if (desktopSessionResult)
        return *desktopSessionResult;

      ERR_FMT(ApiUnavailable, "Failed to get desktop session: {}", desktopSessionResult.error().message);
    });
  }

  fn GetShell(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("linux_shell", []() -> Result<String> {
      return GetEnv("SHELL")
        .transform([](String shellPath) -> String {
          // clang-format off
          constexpr Array<Pair<StringView, StringView>, 5> shellMap {{
            { "/usr/bin/bash",    "Bash" },
            {  "/usr/bin/zsh",     "Zsh" },
            { "/usr/bin/fish",    "Fish" },
            {   "/usr/bin/nu", "Nushell" },
            {   "/usr/bin/sh",      "SH" },
          }};
          // clang-format on

          for (const auto& [exe, name] : shellMap)
            if (shellPath == exe)
              return String(name);

          if (const usize lastSlash = shellPath.find_last_of('/'); lastSlash != String::npos)
            return shellPath.substr(lastSlash + 1);

          return shellPath;
        })
        .transform([](const String& shellPath) -> String {
          return shellPath;
        });
    });
  }

  fn GetHost(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("linux_host", []() -> Result<String> {
      constexpr PCStr primaryPath  = "/sys/class/dmi/id/product_family";
      constexpr PCStr fallbackPath = "/sys/class/dmi/id/product_name";

      fn readFirstLine = [&](const String& path) -> Result<String> {
        std::ifstream file(path);
        String        line;

        if (!file.is_open()) {
          if (errno == EACCES)
            ERR_FMT(PermissionDenied, "Permission denied when opening DMI product identifier file '{}'", path);

          ERR_FMT(NotFound, "Failed to open DMI product identifier file '{}'", path);
        }

        if (!std::getline(file, line) || line.empty())
          ERR_FMT(ParseError, "DMI product identifier file ('{}') is empty", path);

        return line;
      };

      Result<String> primaryResult = readFirstLine(primaryPath);

      if (primaryResult)
        return primaryResult;

      DracError primaryError = primaryResult.error();

      Result<String> fallbackResult = readFirstLine(fallbackPath);

      if (fallbackResult)
        return fallbackResult;

      DracError fallbackError = fallbackResult.error();

      ERR_FMT(
        NotFound,
        "Failed to get host identifier. Primary ('{}'): {}. Fallback ('{}'): {}",
        primaryPath,
        primaryError.message,
        fallbackPath,
        fallbackError.message
      );
    });
  }

  fn GetCPUModel(CacheManager& /*cache*/) -> Result<String> {
    Array<u32, 4>   cpuInfo;
    Array<char, 49> brandString = { 0 };

    __get_cpuid(0x80000000, cpuInfo.data(), &cpuInfo[1], &cpuInfo[2], &cpuInfo[3]);
    const u32 maxFunction = cpuInfo[0];

    if (maxFunction < 0x80000004)
      ERR(NotSupported, "CPU does not support brand string");

    for (u32 i = 0; i < 3; ++i) {
      __get_cpuid(0x80000002 + i, cpuInfo.data(), &cpuInfo[1], &cpuInfo[2], &cpuInfo[3]);
      std::memcpy(&brandString.at(i * 16), cpuInfo.data(), sizeof(cpuInfo));
    }

    String result(brandString.data());

    result.erase(result.find_last_not_of(" \t\n\r") + 1);

    if (result.empty())
      ERR(InternalError, "Failed to get CPU model string via CPUID");

    return result;
  }

  fn GetCPUCores(CacheManager& /*cache*/) -> Result<CPUCores> {
    u32 eax = 0, ebx = 0, ecx = 0, edx = 0;

    __get_cpuid(0x0, &eax, &ebx, &ecx, &edx);
    const u32 maxLeaf   = eax;
    const u32 vendorEbx = ebx;

    u32 logicalCores  = 0;
    u32 physicalCores = 0;

    if (maxLeaf >= 0xB) {
      u32 threadsPerCore = 0;
      for (u32 subleaf = 0;; ++subleaf) {
        __get_cpuid_count(0xB, subleaf, &eax, &ebx, &ecx, &edx);
        if (ebx == 0)
          break;

        const u32 levelType         = (ecx >> 8) & 0xFF;
        const u32 processorsAtLevel = ebx & 0xFFFF;

        if (levelType == 1) // SMT (Hyper-Threading) level
          threadsPerCore = processorsAtLevel;

        if (levelType == 2) // Core level
          logicalCores = processorsAtLevel;
      }

      if (logicalCores > 0 && threadsPerCore > 0)
        physicalCores = logicalCores / threadsPerCore;
    }

    if (physicalCores == 0 || logicalCores == 0) {
      __get_cpuid(0x1, &eax, &ebx, &ecx, &edx);
      logicalCores                 = (ebx >> 16) & 0xFF;
      const bool hasHyperthreading = (edx & (1 << 28)) != 0;

      if (hasHyperthreading) {
        constexpr u32 vendorIntel = 0x756e6547; // "Genu"ine"Intel"
        constexpr u32 vendorAmd   = 0x68747541; // "Auth"entic"AMD"

        if (vendorEbx == vendorIntel && maxLeaf >= 0x4) {
          __get_cpuid_count(0x4, 0, &eax, &ebx, &ecx, &edx);
          physicalCores = ((eax >> 26) & 0x3F) + 1;
        } else if (vendorEbx == vendorAmd) {
          __get_cpuid(0x80000000, &eax, &ebx, &ecx, &edx); // Get max extended leaf
          if (eax >= 0x80000008) {
            __get_cpuid(0x80000008, &eax, &ebx, &ecx, &edx);
            physicalCores = (ecx & 0xFF) + 1;
          }
        }
      } else {
        physicalCores = logicalCores;
      }
    }

    if (physicalCores == 0 && logicalCores > 0)
      physicalCores = logicalCores;

    if (physicalCores == 0 || logicalCores == 0)
      ERR(InternalError, "Failed to determine core counts via CPUID");

    return CPUCores(physicalCores, logicalCores);
  }

  fn GetGPUModel(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("linux_gpu_model", []() -> Result<String> {
      const fs::path pciPath = "/sys/bus/pci/devices";

      if (!fs::exists(pciPath))
        ERR(NotFound, "PCI device path '/sys/bus/pci/devices' not found.");

      // clang-format off
      const Array<Pair<StringView, StringView>, 3> fallbackVendorMap = {{
        { "0x1002", "AMD" },
        { "0x10de", "NVIDIA" },
        { "0x8086", "Intel" },
      }};
      // clang-format on

      for (const fs::directory_entry& entry : fs::directory_iterator(pciPath)) {
        if (Result<String> classIdRes = ReadSysFile(entry.path() / "class"); !classIdRes || !classIdRes->starts_with("0x03"))
          continue;

        Result<String> vendorIdRes = ReadSysFile(entry.path() / "vendor");
        Result<String> deviceIdRes = ReadSysFile(entry.path() / "device");

        if (vendorIdRes && deviceIdRes)
          if (Result<Pair<String, String>> pciNames = LookupPciNames(*vendorIdRes, *deviceIdRes))
            return CleanGpuModelName(std::move(pciNames->first), std::move(pciNames->second));

        if (vendorIdRes) {
          const auto* iter = std::ranges::find_if(fallbackVendorMap, [&](const auto& pair) {
            return pair.first == *vendorIdRes;
          });

          if (iter != fallbackVendorMap.end())
            return String(iter->second);
        }
      }

      ERR(NotFound, "No compatible GPU found in /sys/bus/pci/devices.");
    });
  }

  fn GetUptime() -> Result<std::chrono::seconds> {
    struct sysinfo info;

    if (sysinfo(&info) != 0)
      ERR(InternalError, "sysinfo call failed");

    return std::chrono::seconds(info.uptime);
  }

  fn GetKernelVersion(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("linux_kernel_version", []() -> Result<String> {
      utsname uts;

      if (uname(&uts) == -1)
        ERR(InternalError, "uname call failed");

      if (std::strlen(uts.release) == 0)
        ERR(ParseError, "uname returned null kernel release");

      return String(uts.release);
    });
  }

  fn GetDiskUsage(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    struct statvfs stat;

    if (statvfs("/", &stat) == -1)
      ERR(InternalError, "Failed to get filesystem stats for '/' (statvfs call failed)");

    return ResourceUsage((stat.f_blocks * stat.f_frsize) - (stat.f_bfree * stat.f_frsize), stat.f_blocks * stat.f_frsize);
  }

  fn GetOutputs(CacheManager& /*cache*/) -> Result<Vec<DisplayInfo>> {
    if (GetEnv("WAYLAND_DISPLAY")) {
      Result<Vec<DisplayInfo>> displays = GetWaylandDisplays();

      if (displays)
        return displays;

      debug_at(displays.error());
    }

    if (GetEnv("DISPLAY")) {
      Result<Vec<DisplayInfo>> displays = GetX11Displays();

      if (displays)
        return displays;

      debug_at(displays.error());
    }

    ERR(NotFound, "No display server detected");
  }

  fn GetPrimaryOutput(CacheManager& /*cache*/) -> Result<DisplayInfo> {
    if (GetEnv("WAYLAND_DISPLAY")) {
      Result<DisplayInfo> display = GetWaylandPrimaryDisplay();

      if (display)
        return display;

      debug_at(display.error());
    }

    if (GetEnv("DISPLAY")) {
      Result<DisplayInfo> display = GetX11PrimaryDisplay();

      if (display)
        return display;

      debug_at(display.error());
    }

    ERR(NotFound, "No display server detected");
  }

  fn GetNetworkInterfaces(CacheManager& cache) -> Result<Vec<NetworkInterface>> {
    return cache.getOrSet<Vec<NetworkInterface>>("linux_network_interfaces", []() -> Result<Vec<NetworkInterface>> {
      Result<Map<String, NetworkInterface>> mapResult = CollectNetworkInterfaces();
      if (!mapResult)
        ERR_FROM(mapResult.error());

      const Map<String, NetworkInterface>& interfaceMap = *mapResult;

      Vec<NetworkInterface> interfaces;
      interfaces.reserve(interfaceMap.size());

      std::ranges::copy(interfaceMap | std::views::values, std::back_inserter(interfaces));

      return interfaces;
    });
  }

  fn GetPrimaryNetworkInterface(CacheManager& cache) -> Result<NetworkInterface> {
    return cache.getOrSet<NetworkInterface>("linux_primary_network_interface", []() -> Result<NetworkInterface> {
      // Gather full interface list first
      Result<Map<String, NetworkInterface>> mapResult = CollectNetworkInterfaces();

      if (!mapResult)
        ERR_FROM(mapResult.error());

      const Map<String, NetworkInterface>& interfaces = *mapResult;

      // Attempt to determine primary interface via default route
      String        primaryInterfaceName;
      std::ifstream routeFile("/proc/net/route");

      if (routeFile.is_open()) {
        String line;
        std::getline(routeFile, line); // skip header

        while (std::getline(routeFile, line)) {
          std::istringstream iss(line);
          String             iface, dest, gateway, flags, refcnt, use, metric, mask, mtu, window, irtt;

          if (iss >> iface >> dest >> gateway >> flags >> refcnt >> use >> metric >> mask >> mtu >> window >> irtt && dest == "00000000") {
            primaryInterfaceName = iface;
            break;
          }
        }
      }

      // Fallback: first non-loopback interface that is up (Ranges style)
      if (primaryInterfaceName.empty())
        if (auto iter = std::ranges::find_if(
              interfaces,
              [](const auto& pair) {
                const auto& iface = pair.second;
                return iface.isUp && !iface.isLoopback;
              }
            );
            iter != interfaces.end()) {
          primaryInterfaceName = iter->first;
        }

      if (primaryInterfaceName.empty())
        ERR(NotFound, "Could not determine primary interface name");

      const auto iter = interfaces.find(primaryInterfaceName);
      if (iter == interfaces.end())
        ERR(NotFound, "Found primary interface name, but could not find its details");

      return iter->second;
    });
  }

  fn GetBatteryInfo(CacheManager& /*cache*/) -> Result<Battery> {
    using matchit::match, matchit::is, matchit::_;
    using enum Battery::Status;

    PCStr powerSupplyPath = "/sys/class/power_supply";

    if (!fs::exists(powerSupplyPath))
      ERR(NotFound, "Power supply directory not found");

    // Find the first battery device
    fs::path batteryPath;
    for (const fs::directory_entry& entry : fs::directory_iterator(powerSupplyPath))
      if (Result<String> typeResult = ReadSysFile(entry.path() / "type");
          typeResult && *typeResult == "Battery") {
        batteryPath = entry.path();
        break;
      }

    if (batteryPath.empty())
      ERR(NotFound, "No battery found in power supply directory");

    // Read battery percentage
    Option<u8> percentage =
      ReadSysFile(batteryPath / "capacity")
        .transform([](const String& capacityStr) -> Option<u8> {
          return TryParse<u8>(capacityStr);
        })
        .value_or(None);

    // Read battery status
    Battery::Status status =
      ReadSysFile(batteryPath / "status")
        .transform([percentage](const String& statusStr) -> Battery::Status {
          return match(statusStr)(
            is | "Charging"     = Charging,
            is | "Discharging"  = Discharging,
            is | "Full"         = Full,
            is | "Not charging" = (percentage && *percentage == 100 ? Full : Discharging),
            is | _              = Unknown
          );
        })
        .value_or(Unknown);

    if (status != Charging && status != Discharging)
      return Battery(status, percentage, None);

    return Battery(
      status,
      percentage,
      ReadSysFile(
        batteryPath / std::format("/time_to_{}now", status == Discharging ? "empty" : "full")
      )
        .transform([](const String& timeStr) -> Option<std::chrono::seconds> {
          if (Option<i32> timeMinutes = TryParse<i32>(timeStr); timeMinutes && *timeMinutes > 0)
            return std::chrono::minutes(*timeMinutes);

          return None;
        })
        .value_or(None)
    );
  }
} // namespace draconis::core::system

  #ifdef DRAC_ENABLE_PACKAGECOUNT
namespace draconis::services::packages {
  using draconis::utils::cache::CacheManager;

  fn CountApk(CacheManager& cache) -> Result<u64> {
    const String   pmID      = "apk";
    const fs::path apkDbPath = "/lib/apk/db/installed";

    return cache.getOrSet<u64>(std::format("pkg_count_{}", pmID), [&]() -> Result<u64> {
      if (std::error_code fsErrCode; !fs::exists(apkDbPath, fsErrCode)) {
        if (fsErrCode) {
          warn_log("Filesystem error checking for Apk DB at '{}': {}", apkDbPath.string(), fsErrCode.message());
          ERR_FMT(IoError, "Filesystem error checking Apk DB: {}", fsErrCode.message());
        }

        ERR_FMT(NotFound, "Apk database path '{}' does not exist", apkDbPath.string());
      }

      std::ifstream file(apkDbPath);
      if (!file.is_open())
        ERR(IoError, std::format("Failed to open Apk database file '{}'", apkDbPath.string()));

      u64 count = 0;

      try {
        String line;

        while (std::getline(file, line))
          if (line.empty())
            count++;
      } catch (const std::ios_base::failure& e) {
        ERR_FMT(IoError, "Error reading Apk database file '{}': {}", apkDbPath.string(), e.what());
      }

      if (file.bad())
        ERR_FMT(IoError, "IO error while reading Apk database file '{}'", apkDbPath.string());

      return count;
    });
  }

  fn CountDpkg(CacheManager& cache) -> Result<u64> {
    return GetCountFromDirectory(cache, "dpkg", fs::current_path().root_path() / "var" / "lib" / "dpkg" / "info", String(".list"));
  }

  fn CountMoss(CacheManager& cache) -> Result<u64> {
    Result<u64> countResult = GetCountFromDb(cache, "moss", "/.moss/db/install", "SELECT COUNT(*) FROM meta");

    if (countResult && *countResult > 0)
      return *countResult - 1;

    return countResult;
  }

  fn CountPacman(CacheManager& cache) -> Result<u64> {
    return GetCountFromDirectory(cache, "pacman", fs::current_path().root_path() / "var" / "lib" / "pacman" / "local", true);
  }

  fn CountRpm(CacheManager& cache) -> Result<u64> {
    return GetCountFromDb(cache, "rpm", "/var/lib/rpm/rpmdb.sqlite", "SELECT COUNT(*) FROM Installtid");
  }

    #ifdef HAVE_PUGIXML
  fn CountXbps(CacheManager& cache) -> Result<u64> {
    const CStr xbpsDbPath = "/var/db/xbps";

    if (!fs::exists(xbpsDbPath))
      ERR_FMT(NotFound, "Xbps database path '{}' does not exist", xbpsDbPath);

    fs::path plistPath;

    for (const fs::directory_entry& entry : fs::directory_iterator(xbpsDbPath))
      if (const String filename = entry.path().filename().string(); filename.starts_with("pkgdb-") && filename.ends_with(".plist")) {
        plistPath = entry.path();
        break;
      }

    if (plistPath.empty())
      ERR(NotFound, "No Xbps database found");

    return GetCountFromPlist("xbps", plistPath);
  }
    #endif
} // namespace draconis::services::packages
  #endif

#endif
</file>

<file path="src/Lib/OS/macOS.cpp">
#ifdef __APPLE__

  #include <CoreFoundation/CFPropertyList.h> // CFPropertyListCreateWithData, kCFPropertyListImmutable
  #include <CoreFoundation/CFStream.h>       // CFReadStreamClose, CFReadStreamCreateWithFile, CFReadStreamOpen, CFReadStreamRead, CFReadStreamRef
  #include <CoreGraphics/CGDirectDisplay.h>  // CGDisplayCopyDeviceDescription, CGDisplayCopyDisplayMode, CGDisplayIsMain, CGDisplayModeGetMaximumRefreshRate, CGDisplayModeGetRefreshRate, CGDisplayPixelsHigh, CGDisplayPixelsWide, CGDisplayRef, CGDisplayModeRef, CGDirectDisplayID
  #include <IOKit/ps/IOPSKeys.h>             // kIOPSCurrentCapacityKey, kIOPSInternalBatteryType, kIOPSIsChargingKey, kIOPSTimeToEmptyKey, kIOPSTypeKey
  #include <IOKit/ps/IOPowerSources.h>       // IOPSCopyPowerSourcesInfo, IOPSGetPowerSourceDescription
  #include <flat_map>                        // std::flat_map
  #include <ifaddrs.h>                       // freeifaddrs, getifaddrs, ifaddrs, sockaddr
  #include <mach/mach_host.h>                // host_statistics64
  #include <mach/mach_init.h>                // host_page_size, mach_host_self
  #include <mach/vm_statistics.h>            // vm_statistics64_data_t
  #include <net/if.h>                        // IFF_LOOPBACK, IFF_UP, IF_NAMESIZE, if_indextoname
  #include <net/if_dl.h>                     // LLADDR, sockaddr_dl
  #include <net/route.h>                     // RTA_DST, RTF_GATEWAY, rt_msghdr
  #include <netdb.h>                         // NI_MAXHOST, NI_NUMERICHOST, getnameinfo
  #include <netinet/in.h>                    // sockaddr_in
  #include <sys/statvfs.h>                   // statvfs
  #include <sys/sysctl.h>                    // {CTL_KERN, KERN_PROC, KERN_PROC_ALL, kinfo_proc, sysctl, sysctlbyname}

  #include <Drac++/Core/System.hpp>
  #include <Drac++/Services/Packages.hpp>

  #include <Drac++/Utils/CacheManager.hpp>
  #include <Drac++/Utils/Env.hpp>
  #include <Drac++/Utils/Error.hpp>
  #include <Drac++/Utils/Logging.hpp>
  #include <Drac++/Utils/Types.hpp>

  #include "OS/macOS/Bridge.hpp"

using namespace draconis::utils::types;
using draconis::utils::cache::CacheManager, draconis::utils::cache::CachePolicy;

using enum draconis::utils::error::DracErrorCode;

namespace {
  fn getDisplayInfoById(CGDirectDisplayID displayID) -> Result<DisplayInfo> {
    // Get display resolution
    const usize width  = CGDisplayPixelsWide(displayID);
    const usize height = CGDisplayPixelsHigh(displayID);

    if (width == 0 || height == 0)
      ERR_FMT(UnavailableFeature, "CGDisplayPixelsWide/High returned 0 for displayID {} (no display or API unavailable)", displayID);

    // Get the current display mode to find the refresh rate
    CGDisplayModeRef currentMode = CGDisplayCopyDisplayMode(displayID);
    if (currentMode == nullptr)
      ERR_FMT(UnavailableFeature, "CGDisplayCopyDisplayMode failed for displayID {} (no display mode available)", displayID);

    f64 refreshRate = CGDisplayModeGetRefreshRate(currentMode);

    // Release the display mode object
    CGDisplayModeRelease(currentMode);

    // Check if this is the main display
    const bool isPrimary = displayID == CGMainDisplayID();

    return DisplayInfo(
      displayID,
      { .width = static_cast<u16>(width), .height = static_cast<u16>(height) },
      static_cast<u16>(refreshRate),
      isPrimary
    );
  }

  template <typename T>
  fn getNumericValue(const CFDictionaryRef dict, const CFStringRef key) -> Option<T> {
    const auto* value = static_cast<const CFNumberRef>(CFDictionaryGetValue(dict, key));

    if (value == nullptr)
      return None;

    int64_t intermediateResult = 0;

    if (CFNumberGetValue(value, kCFNumberSInt64Type, &intermediateResult))
      if (intermediateResult >= std::numeric_limits<T>::min() && intermediateResult <= std::numeric_limits<T>::max())
        return static_cast<T>(intermediateResult);

    return None;
  }
} // namespace

namespace draconis::core::system {
  fn GetMemInfo(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    // Mach ports are used for communicating with the kernel. mach_host_self
    // provides a port to the host kernel, which is needed for host-level queries.
    static mach_port_t HostPort = mach_host_self();

    // The size of a virtual memory page in bytes.
    static vm_size_t PageSize = 0;

    // Make sure the page size is set.
    if (PageSize == 0)
      if (host_page_size(HostPort, &PageSize) != KERN_SUCCESS)
        ERR(ResourceExhausted, "host_page_size failed to get page size (Mach API unavailable or resource exhausted)");

    u64   totalMem = 0;
    usize size     = sizeof(totalMem);

    // "hw.memsize" is the standard key for getting the total memory size from the system.
    if (sysctlbyname("hw.memsize", &totalMem, &size, nullptr, 0) == -1)
      ERR_FMT(ResourceExhausted, "sysctlbyname('hw.memsize') failed: {}", std::system_category().message(errno));

    vm_statistics64_data_t vmStats;
    mach_msg_type_number_t infoCount = sizeof(vmStats) / sizeof(natural_t);

    // Retrieve detailed virtual memory statistics from the Mach kernel.
    // The `reinterpret_cast` is required here to interface with the C-style
    // Mach API, which expects a generic `host_info64_t` pointer.
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
    if (host_statistics64(HostPort, HOST_VM_INFO64, reinterpret_cast<host_info64_t>(&vmStats), &infoCount) != KERN_SUCCESS)
      ERR(ResourceExhausted, "host_statistics64 failed to get memory statistics (Mach API unavailable or resource exhausted)");

    // Calculate "used" memory based on the statistics returned by host_statistics64.
    // - active_count: Memory that is actively being used by the process.
    // - wire_count: Memory that is wired to physical memory.
    u64 usedMem = (vmStats.active_count + vmStats.wire_count) * PageSize;

    return ResourceUsage(usedMem, totalMem);
  }

  fn GetNowPlaying() -> Result<MediaInfo> {
    return macOS::GetNowPlayingInfo();
  }

  fn GetOperatingSystem(CacheManager& cache) -> Result<OSInfo> {
    return cache.getOrSet<OSInfo>("macos_os_info", macOS::GetOSVersion);
  }

  fn GetDesktopEnvironment(CacheManager& /*cache*/) -> Result<String> {
    return "Aqua";
  }

  fn GetWindowManager(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("macos_wm", []() -> Result<String> {
      // Store names in lowercase to allow cheap case-insensitive compare via `strncasecmp`.
      constexpr Array<StringView, 5> knownWms = {
        "yabai",
        "chunkwm",
        "amethyst",
        "spectacle",
        "rectangle",
      };

      Array<i32, 3> request = { CTL_KERN, KERN_PROC, KERN_PROC_ALL };

      usize len = 0;

      if (sysctl(request.data(), request.size(), nullptr, &len, nullptr, 0) == -1)
        ERR(ResourceExhausted, "sysctl size query failed for KERN_PROC_ALL (process list unavailable or resource exhausted)");

      if (len == 0)
        ERR(NotFound, "sysctl for KERN_PROC_ALL returned zero length (no processes found, feature not present)");

      Vec<char> buf(len);

      if (sysctl(request.data(), request.size(), buf.data(), &len, nullptr, 0) == -1)
        ERR(ResourceExhausted, "sysctl data fetch failed for KERN_PROC_ALL (process list unavailable or resource exhausted)");

      if (len % sizeof(kinfo_proc) != 0)
        ERR_FMT(CorruptedData, "sysctl returned size {} which is not a multiple of kinfo_proc size {} (corrupt process list)", len, sizeof(kinfo_proc));

      usize count = len / sizeof(kinfo_proc);

      // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
      Span<const kinfo_proc> processes(reinterpret_cast<const kinfo_proc*>(buf.data()), count);

      for (const kinfo_proc& procInfo : processes) {
        const char* procNameC = procInfo.kp_proc.p_comm;
        const usize procLen   = std::strlen(procNameC);

        for (const StringView& wmName : knownWms)
          if (procLen == wmName.size() && strncasecmp(procNameC, wmName.data(), wmName.size()) == 0)
            return String(wmName);
      }

      return "Quartz";
    });
  }

  fn GetKernelVersion(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("macos_kernel", CachePolicy::neverExpire(), []() -> Result<String> {
      Array<char, 256> kernelVersion {};
      usize            kernelVersionLen = kernelVersion.size();

      if (sysctlbyname("kern.osrelease", kernelVersion.data(), &kernelVersionLen, nullptr, 0) == -1)
        ERR_FMT(ResourceExhausted, "sysctlbyname('kern.osrelease') failed: {}", std::system_category().message(errno));

      return String(kernelVersion.data());
    });
  }

  fn GetHost(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("macos_host", CachePolicy::neverExpire(), []() -> Result<String> {
      Array<char, 256> hwModel {};
      usize            hwModelLen = hwModel.size();

      if (sysctlbyname("hw.model", hwModel.data(), &hwModelLen, nullptr, 0) == -1)
        ERR_FMT(ResourceExhausted, "sysctlbyname('hw.model') failed: {}", std::system_category().message(errno));

      // taken from https://github.com/fastfetch-cli/fastfetch/blob/dev/src/detection/host/host_mac.c
      // shortened a lot of the entries to remove unnecessary info
      static const std::flat_map<StringView, StringView> MODEL_NAME_BY_HW_MODEL = {
        // MacBook Pro
        { "MacBookPro18,3",      "MacBook Pro (14-inch, 2021)" },
        { "MacBookPro18,4",      "MacBook Pro (14-inch, 2021)" },
        { "MacBookPro18,1",      "MacBook Pro (16-inch, 2021)" },
        { "MacBookPro18,2",      "MacBook Pro (16-inch, 2021)" },
        { "MacBookPro17,1",  "MacBook Pro (13-inch, M1, 2020)" },
        { "MacBookPro16,3",      "MacBook Pro (13-inch, 2020)" },
        { "MacBookPro16,2",      "MacBook Pro (13-inch, 2020)" },
        { "MacBookPro16,4",      "MacBook Pro (16-inch, 2019)" },
        { "MacBookPro16,1",      "MacBook Pro (16-inch, 2019)" },
        { "MacBookPro15,4",      "MacBook Pro (13-inch, 2019)" },
        { "MacBookPro15,3",      "MacBook Pro (15-inch, 2019)" },
        { "MacBookPro15,2", "MacBook Pro (13-inch, 2018/2019)" },
        { "MacBookPro15,1", "MacBook Pro (15-inch, 2018/2019)" },
        { "MacBookPro14,3",      "MacBook Pro (15-inch, 2017)" },
        { "MacBookPro14,2",      "MacBook Pro (13-inch, 2017)" },
        { "MacBookPro14,1",      "MacBook Pro (13-inch, 2017)" },
        { "MacBookPro13,3",      "MacBook Pro (15-inch, 2016)" },
        { "MacBookPro13,2",      "MacBook Pro (13-inch, 2016)" },
        { "MacBookPro13,1",      "MacBook Pro (13-inch, 2016)" },
        { "MacBookPro12,1",      "MacBook Pro (13-inch, 2015)" },
        { "MacBookPro11,4",      "MacBook Pro (15-inch, 2015)" },
        { "MacBookPro11,5",      "MacBook Pro (15-inch, 2015)" },
        { "MacBookPro11,2", "MacBook Pro (15-inch, 2013/2014)" },
        { "MacBookPro11,3", "MacBook Pro (15-inch, 2013/2014)" },
        { "MacBookPro11,1", "MacBook Pro (13-inch, 2013/2014)" },
        { "MacBookPro10,2", "MacBook Pro (13-inch, 2012/2013)" },
        { "MacBookPro10,1", "MacBook Pro (15-inch, 2012/2013)" },
        {  "MacBookPro9,2",      "MacBook Pro (13-inch, 2012)" },
        {  "MacBookPro9,1",      "MacBook Pro (15-inch, 2012)" },
        {  "MacBookPro8,3",      "MacBook Pro (17-inch, 2011)" },
        {  "MacBookPro8,2",      "MacBook Pro (15-inch, 2011)" },
        {  "MacBookPro8,1",      "MacBook Pro (13-inch, 2011)" },
        {  "MacBookPro7,1",      "MacBook Pro (13-inch, 2010)" },
        {  "MacBookPro6,2",      "MacBook Pro (15-inch, 2010)" },
        {  "MacBookPro6,1",      "MacBook Pro (17-inch, 2010)" },
        {  "MacBookPro5,5",      "MacBook Pro (13-inch, 2009)" },
        {  "MacBookPro5,3",      "MacBook Pro (15-inch, 2009)" },
        {  "MacBookPro5,2",      "MacBook Pro (17-inch, 2009)" },
        {  "MacBookPro5,1",      "MacBook Pro (15-inch, 2008)" },
        {  "MacBookPro4,1",   "MacBook Pro (17/15-inch, 2008)" },

        // MacBook Air
        { "MacBookAir10,1",           "MacBook Air (M1, 2020)" },
        {  "MacBookAir9,1",      "MacBook Air (13-inch, 2020)" },
        {  "MacBookAir8,2",      "MacBook Air (13-inch, 2019)" },
        {  "MacBookAir8,1",      "MacBook Air (13-inch, 2018)" },
        {  "MacBookAir7,2", "MacBook Air (13-inch, 2015/2017)" },
        {  "MacBookAir7,1",      "MacBook Air (11-inch, 2015)" },
        {  "MacBookAir6,2", "MacBook Air (13-inch, 2013/2014)" },
        {  "MacBookAir6,1", "MacBook Air (11-inch, 2013/2014)" },
        {  "MacBookAir5,2",      "MacBook Air (13-inch, 2012)" },
        {  "MacBookAir5,1",      "MacBook Air (11-inch, 2012)" },
        {  "MacBookAir4,2",      "MacBook Air (13-inch, 2011)" },
        {  "MacBookAir4,1",      "MacBook Air (11-inch, 2011)" },
        {  "MacBookAir3,2",      "MacBook Air (13-inch, 2010)" },
        {  "MacBookAir3,1",      "MacBook Air (11-inch, 2010)" },
        {  "MacBookAir2,1",               "MacBook Air (2009)" },

        // Mac mini
        {     "Macmini9,1",              "Mac mini (M1, 2020)" },
        {     "Macmini8,1",                  "Mac mini (2018)" },
        {     "Macmini7,1",                  "Mac mini (2014)" },
        {     "Macmini6,1",                  "Mac mini (2012)" },
        {     "Macmini6,2",                  "Mac mini (2012)" },
        {     "Macmini5,1",                  "Mac mini (2011)" },
        {     "Macmini5,2",                  "Mac mini (2011)" },
        {     "Macmini4,1",                  "Mac mini (2010)" },
        {     "Macmini3,1",                  "Mac mini (2009)" },

        // MacBook
        {    "MacBook10,1",          "MacBook (12-inch, 2017)" },
        {     "MacBook9,1",          "MacBook (12-inch, 2016)" },
        {     "MacBook8,1",          "MacBook (12-inch, 2015)" },
        {     "MacBook7,1",          "MacBook (13-inch, 2010)" },
        {     "MacBook6,1",          "MacBook (13-inch, 2009)" },
        {     "MacBook5,2",          "MacBook (13-inch, 2009)" },

        // Mac Pro
        {      "MacPro7,1",                   "Mac Pro (2019)" },
        {      "MacPro6,1",                   "Mac Pro (2013)" },
        {      "MacPro5,1",            "Mac Pro (2010 - 2012)" },
        {      "MacPro4,1",                   "Mac Pro (2009)" },

        // Mac (Generic)
        {        "Mac16,3",             "iMac (24-inch, 2024)" },
        {        "Mac16,2",             "iMac (24-inch, 2024)" },
        {        "Mac16,1",      "MacBook Pro (14-inch, 2024)" },
        {        "Mac16,6",      "MacBook Pro (14-inch, 2024)" },
        {        "Mac16,8",      "MacBook Pro (14-inch, 2024)" },
        {        "Mac16,7",      "MacBook Pro (16-inch, 2024)" },
        {        "Mac16,5",      "MacBook Pro (16-inch, 2024)" },
        {       "Mac16,15",                  "Mac mini (2024)" },
        {       "Mac16,10",                  "Mac mini (2024)" },
        {       "Mac15,13",  "MacBook Air (15-inch, M3, 2024)" },
        {        "Mac15,2",  "MacBook Air (13-inch, M3, 2024)" },
        {        "Mac15,3",  "MacBook Pro (14-inch, Nov 2023)" },
        {        "Mac15,4",             "iMac (24-inch, 2023)" },
        {        "Mac15,5",             "iMac (24-inch, 2023)" },
        {        "Mac15,6",  "MacBook Pro (14-inch, Nov 2023)" },
        {        "Mac15,8",  "MacBook Pro (14-inch, Nov 2023)" },
        {       "Mac15,10",  "MacBook Pro (14-inch, Nov 2023)" },
        {        "Mac15,7",  "MacBook Pro (16-inch, Nov 2023)" },
        {        "Mac15,9",  "MacBook Pro (16-inch, Nov 2023)" },
        {       "Mac15,11",  "MacBook Pro (16-inch, Nov 2023)" },
        {       "Mac14,15",  "MacBook Air (15-inch, M2, 2023)" },
        {       "Mac14,14",      "Mac Studio (M2 Ultra, 2023)" },
        {       "Mac14,13",        "Mac Studio (M2 Max, 2023)" },
        {        "Mac14,8",                   "Mac Pro (2023)" },
        {        "Mac14,6",      "MacBook Pro (16-inch, 2023)" },
        {       "Mac14,10",      "MacBook Pro (16-inch, 2023)" },
        {        "Mac14,5",      "MacBook Pro (14-inch, 2023)" },
        {        "Mac14,9",      "MacBook Pro (14-inch, 2023)" },
        {        "Mac14,3",              "Mac mini (M2, 2023)" },
        {       "Mac14,12",              "Mac mini (M2, 2023)" },
        {        "Mac14,7",  "MacBook Pro (13-inch, M2, 2022)" },
        {        "Mac14,2",           "MacBook Air (M2, 2022)" },
        {        "Mac13,1",        "Mac Studio (M1 Max, 2022)" },
        {        "Mac13,2",      "Mac Studio (M1 Ultra, 2022)" },

        // iMac
        {       "iMac21,1",         "iMac (24-inch, M1, 2021)" },
        {       "iMac21,2",         "iMac (24-inch, M1, 2021)" },
        {       "iMac20,1",             "iMac (27-inch, 2020)" },
        {       "iMac20,2",             "iMac (27-inch, 2020)" },
        {       "iMac19,1",             "iMac (27-inch, 2019)" },
        {       "iMac19,2",           "iMac (21.5-inch, 2019)" },
        {     "iMacPro1,1",                  "iMac Pro (2017)" },
        {       "iMac18,3",             "iMac (27-inch, 2017)" },
        {       "iMac18,2",           "iMac (21.5-inch, 2017)" },
        {       "iMac18,1",           "iMac (21.5-inch, 2017)" },
        {       "iMac17,1",             "iMac (27-inch, 2015)" },
        {       "iMac16,2",           "iMac (21.5-inch, 2015)" },
        {       "iMac16,1",           "iMac (21.5-inch, 2015)" },
        {       "iMac15,1",        "iMac (27-inch, 2014/2015)" },
        {       "iMac14,4",           "iMac (21.5-inch, 2014)" },
        {       "iMac14,2",             "iMac (27-inch, 2013)" },
        {       "iMac14,1",           "iMac (21.5-inch, 2013)" },
        {       "iMac13,2",             "iMac (27-inch, 2012)" },
        {       "iMac13,1",           "iMac (21.5-inch, 2012)" },
        {       "iMac12,2",             "iMac (27-inch, 2011)" },
        {       "iMac12,1",           "iMac (21.5-inch, 2011)" },
        {       "iMac11,3",             "iMac (27-inch, 2010)" },
        {       "iMac11,2",           "iMac (21.5-inch, 2010)" },
        {       "iMac10,1",        "iMac (27/21.5-inch, 2009)" },
        {        "iMac9,1",          "iMac (24/20-inch, 2009)" },
      };

      const auto iter = MODEL_NAME_BY_HW_MODEL.find(hwModel.data());

      if (iter == MODEL_NAME_BY_HW_MODEL.end())
        ERR_FMT(UnavailableFeature, "Unknown hardware model: {} (feature not present)", hwModel.data());

      return String(iter->second);
    });
  }

  fn GetCPUModel(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("macos_cpu_model", CachePolicy::neverExpire(), []() -> Result<String> {
      Array<char, 256> cpuModel {};
      usize            cpuModelLen = cpuModel.size();

      if (sysctlbyname("machdep.cpu.brand_string", cpuModel.data(), &cpuModelLen, nullptr, 0) == -1)
        ERR_FMT(ResourceExhausted, "sysctlbyname('machdep.cpu.brand_string') failed: {}", std::system_category().message(errno));

      return String(cpuModel.data());
    });
  }

  fn GetCPUCores(CacheManager& cache) -> Result<CPUCores> {
    return cache.getOrSet<CPUCores>("macos_cpu_cores", CachePolicy::neverExpire(), []() -> Result<CPUCores> {
      u32   physicalCores = 0;
      u32   logicalCores  = 0;
      usize size          = sizeof(u32);

      if (sysctlbyname("hw.physicalcpu", &physicalCores, &size, nullptr, 0) == -1)
        ERR_FMT(ResourceExhausted, "sysctlbyname('hw.physicalcpu') failed: {}", std::system_category().message(errno));

      size = sizeof(u32);

      if (sysctlbyname("hw.logicalcpu", &logicalCores, &size, nullptr, 0) == -1)
        ERR_FMT(ResourceExhausted, "sysctlbyname('hw.logicalcpu') failed: {}", std::system_category().message(errno));

      return CPUCores(physicalCores, logicalCores);
    });
  }

  fn GetGPUModel(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("macos_gpu", CachePolicy::neverExpire(), []() -> Result<String> {
      const Result<String> gpuModel = macOS::GetGPUModel();

      if (!gpuModel)
        ERR(UnavailableFeature, "macOS::GetGPUModel() failed: GPU model unavailable (no GPU present)");

      return *gpuModel;
    });
  }

  fn GetDiskUsage(CacheManager& /*cache*/) -> Result<ResourceUsage> {
    struct statvfs vfs;

    if (statvfs("/", &vfs) != 0)
      ERR_FMT(ResourceExhausted, "statvfs('/') failed: {}", std::system_category().message(errno));

    return ResourceUsage((vfs.f_blocks - vfs.f_bfree) * vfs.f_frsize, vfs.f_blocks * vfs.f_frsize);
  }

  fn GetShell(CacheManager& cache) -> Result<String> {
    return cache.getOrSet<String>("macos_shell", CachePolicy::tempDirectory(), []() -> Result<String> {
      if (const Result<String> shellPath = draconis::utils::env::GetEnv("SHELL")) {
        // clang-format off
        constexpr Array<Pair<StringView, StringView>, 8> shellMap {{
            { "bash", "Bash"      },
            { "zsh",  "Zsh"       },
            { "ksh",  "KornShell" },
            { "fish", "Fish"      },
            { "tcsh", "TCsh"      },
            { "csh",  "Csh"       },
            { "sh",   "Sh"        },
            { "nu",   "NuShell"   },
        }};
        // clang-format on

        for (const auto& [exe, name] : shellMap)
          if (shellPath->ends_with(exe))
            return String(name);

        return *shellPath;
      }

      ERR(ConfigurationError, "Could not find SHELL environment variable (SHELL not set in environment)");
    });
  }

  fn GetUptime() -> Result<std::chrono::seconds> {
    using namespace std::chrono;

    Array<i32, 2> mib = { CTL_KERN, KERN_BOOTTIME };

    struct timeval boottime;
    usize          len = sizeof(boottime);

    if (sysctl(mib.data(), mib.size(), &boottime, &len, nullptr, 0) == -1)
      ERR(ResourceExhausted, "sysctl(CTL_KERN, KERN_BOOTTIME) failed: system boot time unavailable or resource exhausted");

    const system_clock::time_point bootTimepoint = system_clock::from_time_t(boottime.tv_sec);

    const system_clock::time_point now = system_clock::now();

    return duration_cast<seconds>(now - bootTimepoint);
  }

  fn GetPrimaryOutput(CacheManager& cache) -> Result<DisplayInfo> {
    return cache.getOrSet<DisplayInfo>("macos_primary_output", CachePolicy::tempDirectory(), []() -> Result<DisplayInfo> {
      return getDisplayInfoById(CGMainDisplayID());
    });
  }

  fn GetOutputs(CacheManager& cache) -> Result<Vec<DisplayInfo>> {
    return cache.getOrSet<Vec<DisplayInfo>>("macos_outputs", CachePolicy::tempDirectory(), []() -> Result<Vec<DisplayInfo>> {
      u32 displayCount = 0;

      if (CGGetOnlineDisplayList(0, nullptr, &displayCount) != kCGErrorSuccess)
        ERR(UnavailableFeature, "CGGetOnlineDisplayList failed to get display count (CoreGraphics API unavailable or no displays)");

      if (displayCount == 0)
        ERR(UnavailableFeature, "No displays found (displayCount == 0, feature not present)");

      // Use a small stack buffer for the common case (≤ 16 displays) to avoid a
      // heap allocation on most systems.
      constexpr u32                                kSmallDisplayLimit = 16;
      Array<CGDirectDisplayID, kSmallDisplayLimit> stackDisplayIDs {};
      CGDirectDisplayID*                           displayIDs = stackDisplayIDs.data();
      Vec<CGDirectDisplayID>                       dynDisplayIDs; // falls back when more than 16

      if (displayCount > kSmallDisplayLimit) {
        dynDisplayIDs.resize(displayCount);
        displayIDs = dynDisplayIDs.data();
      }

      if (CGGetOnlineDisplayList(displayCount, displayIDs, &displayCount) != kCGErrorSuccess)
        ERR(UnavailableFeature, "CGGetOnlineDisplayList failed to get display list (CoreGraphics API unavailable or no displays)");

      const CGDirectDisplayID mainId = CGMainDisplayID();

      Vec<DisplayInfo> displays;
      displays.reserve(displayCount);

      const Span<const CGDirectDisplayID> ids(displayIDs, displayCount);

      for (const CGDirectDisplayID displayID : ids) {
        const usize width  = CGDisplayPixelsWide(displayID);
        const usize height = CGDisplayPixelsHigh(displayID);

        if (width == 0 || height == 0)
          continue;

        const bool isPrimary = (displayID == mainId);

        f64 refreshRate = 0.0;
        if (isPrimary) {
          if (CGDisplayModeRef currentMode = CGDisplayCopyDisplayMode(displayID)) {
            refreshRate = CGDisplayModeGetRefreshRate(currentMode);
            CGDisplayModeRelease(currentMode);
          }
        }

        displays.emplace_back(
          displayID,
          DisplayInfo::Resolution { .width = width, .height = height },
          refreshRate,
          isPrimary
        );
      }

      return displays;
    });
  }

  fn GetPrimaryNetworkInterface(CacheManager& cache) -> Result<NetworkInterface> {
    return cache.getOrSet<NetworkInterface>("macos_primary_network_interface", CachePolicy::tempDirectory(), []() -> Result<NetworkInterface> {
      // NOLINTBEGIN(cppcoreguidelines-pro-type-reinterpret-cast) – unavoidable when talking to C APIs.
      Array<i32, 6> mib = { CTL_NET, PF_ROUTE, 0, AF_INET, NET_RT_FLAGS, RTF_GATEWAY };
      usize         len = 0;

      if (sysctl(mib.data(), mib.size(), nullptr, &len, nullptr, 0) == -1)
        ERR(ResourceExhausted, "sysctl(CTL_NET, PF_ROUTE, ...) failed to get routing table size (network API unavailable or resource exhausted)");

      // Use a small stack buffer for the common case to avoid a heap allocation.
      constexpr usize           stackBufSize = 4096;
      Array<char, stackBufSize> stackBuf {};
      char*                     bufPtr = nullptr;
      Vec<char>                 dynBuf {};

      if (len <= stackBufSize)
        bufPtr = stackBuf.data();
      else {
        dynBuf.resize(len);
        bufPtr = dynBuf.data();
      }

      if (sysctl(mib.data(), mib.size(), bufPtr, &len, nullptr, 0) == -1)
        ERR(ResourceExhausted, "sysctl(CTL_NET, PF_ROUTE, ...) failed to get routing table dump (network API unavailable or resource exhausted)");

      // Locate the default route and remember its interface *index*.
      u32 primaryIfIndex = 0;
      for (usize offset = 0; offset < len;) {
        const auto* rtm   = reinterpret_cast<const rt_msghdr*>(std::next(bufPtr, static_cast<ptrdiff_t>(offset)));
        const auto* saddr = reinterpret_cast<const sockaddr*>(std::next(rtm));

        if (rtm->rtm_msglen == 0)
          break;

        if (saddr->sa_family == AF_INET && rtm->rtm_addrs & RTA_DST)
          if (reinterpret_cast<const sockaddr_in*>(saddr)->sin_addr.s_addr == 0) {
            primaryIfIndex = rtm->rtm_index;
            break;
          }

        offset += rtm->rtm_msglen;
      }

      if (primaryIfIndex == 0)
        ERR(UnavailableFeature, "Could not determine primary interface index from routing table (no default route found, feature not present)");

      ifaddrs* ifaddrList = nullptr;
      if (getifaddrs(&ifaddrList) == -1)
        ERR_FMT(ResourceExhausted, "getifaddrs() failed: {} (resource exhausted or API unavailable)", std::system_category().message(errno));

      UniquePointer<ifaddrs, decltype(&freeifaddrs)> ifaddrsDeleter(ifaddrList, &freeifaddrs);

      NetworkInterface primaryInterface;
      bool             foundDetails = false;

      for (ifaddrs* ifa = ifaddrList; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr)
          continue;

        // Match by interface *index* – cheaper than string compares.
        if (if_nametoindex(ifa->ifa_name) != primaryIfIndex)
          continue;

        foundDetails                = true;
        primaryInterface.name       = String(ifa->ifa_name);
        primaryInterface.isUp       = ifa->ifa_flags & IFF_UP;
        primaryInterface.isLoopback = ifa->ifa_flags & IFF_LOOPBACK;

        switch (ifa->ifa_addr->sa_family) {
          case AF_INET: {
            Array<char, NI_MAXHOST> host = {};
            if (getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in), host.data(), host.size(), nullptr, 0, NI_NUMERICHOST) == 0)
              primaryInterface.ipv4Address = String(host.data());
            break;
          }
          case AF_LINK: {
            auto* sdl = reinterpret_cast<sockaddr_dl*>(ifa->ifa_addr);
            if (sdl && sdl->sdl_alen == 6) {
              const auto*          macPtr = reinterpret_cast<const u8*>(LLADDR(sdl));
              const Span<const u8> macAddr(macPtr, sdl->sdl_alen);
              primaryInterface.macAddress = std::format(
                "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
                macAddr[0],
                macAddr[1],
                macAddr[2],
                macAddr[3],
                macAddr[4],
                macAddr[5]
              );
            }
            break;
          }
          default:
            break;
        }
      }

      if (!foundDetails)
        ERR_FMT(UnavailableFeature, "Found primary interface index '{}' but could not find its details via getifaddrs (feature not present)", primaryIfIndex);

      return primaryInterface;
      // NOLINTEND(cppcoreguidelines-pro-type-reinterpret-cast)
    });
  }

  fn GetNetworkInterfaces(CacheManager& cache) -> Result<Vec<NetworkInterface>> {
    return cache.getOrSet<Vec<NetworkInterface>>("macos_network_interfaces", CachePolicy::tempDirectory(), []() -> Result<Vec<NetworkInterface>> {
      // NOLINTBEGIN(cppcoreguidelines-pro-type-reinterpret-cast) - This requires a lot of casts and there's no good way to avoid them.
      ifaddrs* ifaddrList = nullptr;
      if (getifaddrs(&ifaddrList) == -1)
        ERR_FMT(ResourceExhausted, "getifaddrs() failed: {} (resource exhausted or API unavailable)", std::system_category().message(errno));

      UniquePointer<ifaddrs, decltype(&freeifaddrs)> ifaddrsDeleter(ifaddrList, &freeifaddrs);

      // Use a map to collect interface information since getifaddrs returns multiple entries per interface
      std::flat_map<String, NetworkInterface> interfaceMap;

      for (ifaddrs* ifa = ifaddrList; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr)
          continue;

        const String interfaceName = String(ifa->ifa_name);

        // Get or create the interface entry
        auto& interface = interfaceMap[interfaceName];
        interface.name  = interfaceName;

        // Set flags
        interface.isUp       = ifa->ifa_flags & IFF_UP;
        interface.isLoopback = ifa->ifa_flags & IFF_LOOPBACK;

        // Get IPv4 details
        if (ifa->ifa_addr->sa_family == AF_INET) {
          Array<char, NI_MAXHOST> host = {};
          if (getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in), host.data(), host.size(), nullptr, 0, NI_NUMERICHOST) == 0)
            interface.ipv4Address = String(host.data());
        } else if (ifa->ifa_addr->sa_family == AF_LINK) {
          auto* sdl = reinterpret_cast<sockaddr_dl*>(ifa->ifa_addr);

          if (sdl && sdl->sdl_alen == 6) {
            const auto*          macPtr = reinterpret_cast<const u8*>(LLADDR(sdl));
            const Span<const u8> macAddr(macPtr, sdl->sdl_alen);

            interface.macAddress = std::format(
              "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
              macAddr[0],
              macAddr[1],
              macAddr[2],
              macAddr[3],
              macAddr[4],
              macAddr[5]
            );
          }
        }
      }

      // Convert the map to a vector
      Vec<NetworkInterface> interfaces;
      interfaces.reserve(interfaceMap.size());

      for (const auto& pair : interfaceMap)
        interfaces.push_back(pair.second);

      if (interfaces.empty())
        ERR(UnavailableFeature, "No network interfaces found (getifaddrs returned empty list, feature not present)");

      return interfaces;
      // NOLINTEND(cppcoreguidelines-pro-type-reinterpret-cast)
    });
  }

  fn GetBatteryInfo(CacheManager& /*cache*/) -> Result<Battery> {
    using matchit::match, matchit::is, matchit::_;
    using enum Battery::Status;

    // This snapshot contains information about all power sources (e.g., AC Power, Battery).
    // It's a Core Foundation object that we must release.
    CFTypeRef powerSourcesInfo = IOPSCopyPowerSourcesInfo();

    if (powerSourcesInfo == nullptr)
      ERR(UnavailableFeature, "IOPSCopyPowerSourcesInfo() returned nullptr (IOKit unavailable or no power sources/feature not present)");

    // RAII to ensure the CF object is released.
    const UniquePointer<const Unit, decltype(&CFRelease)> powerSourcesInfoDeleter(powerSourcesInfo, &CFRelease);

    // The snapshot is an array of power sources.
    const auto* const powerSourcesList = static_cast<CFArrayRef>(powerSourcesInfo);
    const CFIndex     sourceCount      = CFArrayGetCount(powerSourcesList);

    for (CFIndex i = 0; i < sourceCount; ++i) {
      // Get the dictionary of properties for a single power source.
      CFDictionaryRef sourceDescription = IOPSGetPowerSourceDescription(powerSourcesInfo, CFArrayGetValueAtIndex(powerSourcesList, i));
      if (sourceDescription == nullptr)
        continue;

      // Check if this source is an internal battery.
      const auto* type = static_cast<const CFStringRef>(CFDictionaryGetValue(sourceDescription, CFSTR(kIOPSTypeKey)));

      if (type == nullptr || CFStringCompare(type, CFSTR(kIOPSInternalBatteryType), 0) != kCFCompareEqualTo)
        continue;

      u8 percentage = getNumericValue<u8>(sourceDescription, CFSTR(kIOPSCurrentCapacityKey)).value_or(0);

      CFTypeRef isChargingRef = CFDictionaryGetValue(sourceDescription, CFSTR(kIOPSIsChargingKey));
      bool      isCharging    = false; // Default to a safe value.

      if (isChargingRef != nullptr) {
        if (CFGetTypeID(isChargingRef) == CFBooleanGetTypeID()) {
          isCharging = CFBooleanGetValue(static_cast<CFBooleanRef>(isChargingRef));
        } else if (CFGetTypeID(isChargingRef) == CFNumberGetTypeID()) {
          i32 numericValue = 0;
          if (CFNumberGetValue(static_cast<CFNumberRef>(isChargingRef), kCFNumberIntType, &numericValue))
            isCharging = (numericValue != 0);
        }
      }

      Battery::Status status = match(isCharging)(
        is | (_ == true && percentage == 100) = Full,
        is | true                             = Charging,
        is | false                            = Discharging,
        is | _                                = Unknown
      );

      Option<std::chrono::seconds> timeRemaining = None;

      // Time to empty is given in minutes. A value of 0 means calculating, < 0 means unlimited/plugged in.
      if (Option<i32> timeMinutes = getNumericValue<i32>(sourceDescription, CFSTR(kIOPSTimeToEmptyKey)); timeMinutes && *timeMinutes > 0)
        timeRemaining = std::chrono::minutes(*timeMinutes);

      return Battery(status, percentage, timeRemaining);
    }

    // If the loop finishes without finding an internal battery.
    ERR(UnavailableFeature, "No internal battery found (no IOPSInternalBatteryType in power sources, feature not present)");
  }
} // namespace draconis::core::system

  #if DRAC_ENABLE_PACKAGECOUNT
namespace draconis::services::packages {
  namespace fs = std::filesystem;

  fn GetHomebrewCount(CacheManager& cache) -> Result<u64> {
    return cache.getOrSet<u64>("homebrew_total", [&]() -> Result<u64> {
      Array<fs::path, 2> cellarPaths {
        "/opt/homebrew/Cellar",
        "/usr/local/Cellar",
      };

      u64 count = 0;

      for (const fs::path& cellarPath : cellarPaths) {
        if (std::error_code errc; !fs::exists(cellarPath, errc) || errc) {
          if (errc && errc != std::errc::no_such_file_or_directory)
            ERR_FMT(ResourceExhausted, "fs::exists('{}') failed: {} (resource exhausted or API unavailable)", cellarPath.string(), errc.message());

          continue;
        }

        // Use the non-cached version to avoid nested cache calls
        Result dirCount = GetCountFromDirectoryNoCache("homebrew_" + cellarPath.filename().string(), cellarPath, None, true);

        if (!dirCount) {
          if (dirCount.error().code != NotFound)
            return dirCount;

          continue;
        }

        count += *dirCount;
      }

      if (count == 0)
        ERR(NotFound, "No Homebrew packages found in any Cellar directory");

      return count;
    });
  }

  fn GetMacPortsCount(CacheManager& cache) -> Result<u64> {
    return GetCountFromDb(cache, "macports", "/opt/local/var/macports/registry/registry.db", "SELECT COUNT(*) FROM ports WHERE state='installed';");
  }
} // namespace draconis::services::packages
  #endif

#endif
</file>

<file path="src/CLI/main.cpp">
#ifdef _WIN32
  #include <fcntl.h>
  #include <io.h>
  #include <windows.h>
#endif

#include <Drac++/Core/System.hpp>
#include <Drac++/Services/Packages.hpp>

#if DRAC_ENABLE_WEATHER
  #include <Drac++/Services/Weather.hpp>
#endif

#include <glaze/glaze.hpp>

#include <Drac++/Utils/ArgumentParser.hpp>
#include <Drac++/Utils/CacheManager.hpp>
#include <Drac++/Utils/Error.hpp>
#include <Drac++/Utils/Logging.hpp>
#include <Drac++/Utils/Types.hpp>

#include "Config/Config.hpp"
#include "Core/SystemInfo.hpp"
#include "UI/UI.hpp"

using namespace draconis::utils::types;
using namespace draconis::utils::logging;
using namespace draconis::core::system;
using namespace draconis::config;
using namespace draconis::ui;

namespace {
  fn WriteToConsole(const String& document) -> Unit {
#ifdef _WIN32
    if (
      HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
      hConsole != INVALID_HANDLE_VALUE
    )
      WriteConsoleA(hConsole, document.c_str(), static_cast<DWORD>(document.length()), nullptr, nullptr);
#else
    Println(document);
#endif
  }

  fn PrintDoctorReport(
#if DRAC_ENABLE_WEATHER
    const Result<Report>& weather,
#endif
    const SystemInfo& data
  ) -> Unit {
    using draconis::utils::error::DracError;

    Array<Option<Pair<String, DracError>>, 10 + DRAC_ENABLE_PACKAGECOUNT + DRAC_ENABLE_NOWPLAYING + DRAC_ENABLE_WEATHER>
      failures {};

    usize failureCount = 0;

#define DRAC_CHECK(expr, label) \
  if (!(expr))                  \
  failures.at(failureCount++) = { label, (expr).error() }

    DRAC_CHECK(data.date, "Date");
    DRAC_CHECK(data.host, "Host");
    DRAC_CHECK(data.kernelVersion, "KernelVersion");
    DRAC_CHECK(data.operatingSystem, "OperatingSystem");
    DRAC_CHECK(data.memInfo, "MemoryInfo");
    DRAC_CHECK(data.desktopEnv, "DesktopEnvironment");
    DRAC_CHECK(data.windowMgr, "WindowManager");
    DRAC_CHECK(data.diskUsage, "DiskUsage");
    DRAC_CHECK(data.shell, "Shell");
    DRAC_CHECK(data.uptime, "Uptime");

#if DRAC_ENABLE_PACKAGECOUNT
    DRAC_CHECK(data.packageCount, "PackageCount");
#endif

#if DRAC_ENABLE_NOWPLAYING
    DRAC_CHECK(data.nowPlaying, "NowPlaying");
#endif

#if DRAC_ENABLE_WEATHER
    DRAC_CHECK(weather, "Weather");
#endif

#undef DRAC_CHECK

    if (failureCount == 0)
      Println("All readouts were successful!");
    else {
      Println(
        "Out of {} readouts, {} failed.\n",
        failures.size(),
        failureCount
      );

      for (const Option<Pair<String, DracError>>& failure : failures)
        if (failure)
          Println(
            R"(Readout "{}" failed: {} ({}))",
            failure->first,
            failure->second.message,
            magic_enum::enum_name(failure->second.code)
          );
    }
  }

  fn PrintJsonOutput(
#if DRAC_ENABLE_WEATHER
    const Result<Report>& weather,
#endif
    const SystemInfo& data
  ) -> Unit {
    using draconis::core::system::JsonInfo;

    JsonInfo output;

#define DRAC_SET_OPTIONAL(field) \
  if (data.field)                \
  output.field = *data.field

    DRAC_SET_OPTIONAL(date);
    DRAC_SET_OPTIONAL(host);
    DRAC_SET_OPTIONAL(kernelVersion);
    DRAC_SET_OPTIONAL(operatingSystem);
    DRAC_SET_OPTIONAL(memInfo);
    DRAC_SET_OPTIONAL(desktopEnv);
    DRAC_SET_OPTIONAL(windowMgr);
    DRAC_SET_OPTIONAL(diskUsage);
    DRAC_SET_OPTIONAL(shell);
    DRAC_SET_OPTIONAL(cpuModel);
    DRAC_SET_OPTIONAL(cpuCores);
    DRAC_SET_OPTIONAL(gpuModel);

    if (data.uptime)
      output.uptimeSeconds = data.uptime->count();

#if DRAC_ENABLE_PACKAGECOUNT
    DRAC_SET_OPTIONAL(packageCount);
#endif

#if DRAC_ENABLE_NOWPLAYING
    DRAC_SET_OPTIONAL(nowPlaying);
#endif

#if DRAC_ENABLE_WEATHER
    if (weather)
      output.weather = *weather;
#endif

#undef DRAC_SET_OPTIONAL

    String jsonStr;

    glz::error_ctx errorContext = glz::write<glz::opts { .prettify = true }>(output, jsonStr);

    if (errorContext)
      WriteToConsole(std::format("Failed to write JSON output: {}", glz::format_error(errorContext, jsonStr)));
    else
      WriteToConsole(jsonStr);
  }
} // namespace

fn main(const i32 argc, CStr* argv[]) -> i32 try {
#ifdef _WIN32
  winrt::init_apartment();
#endif

  // clang-format off
  auto [
    doctorMode,
    clearCache,
    ignoreCacheRun,
    noAscii,
    jsonOutput
  ] = Tuple(false, false, false, false, false);
  // clang-format on

  {
    using draconis::utils::argparse::ArgumentParser;

    ArgumentParser parser(DRAC_VERSION);

    parser
      .addArguments("-V", "--verbose")
      .help("Enable verbose logging. Overrides --log-level.")
      .flag();

    parser
      .addArguments("-d", "--doctor")
      .help("Reports any failed readouts and their error messages.")
      .flag();

    parser
      .addArguments("-l", "--log-level")
      .help("Set the minimum log level.")
      .defaultValue(LogLevel::Info);

    parser
      .addArguments("--clear-cache")
      .help("Clears the cache. This will remove all cached data, including in-memory and on-disk copies.")
      .flag();

    parser
      .addArguments("--ignore-cache")
      .help("Ignore cache for this run (fetch fresh data without reading/writing on-disk cache).")
      .flag();

    parser
      .addArguments("--no-ascii")
      .help("Disable ASCII art display.")
      .flag();

    parser
      .addArguments("--json")
      .help("Output system information in JSON format. Overrides --no-ascii.")
      .flag();

    if (Result result = parser.parseArgs({ argv, static_cast<usize>(argc) }); !result) {
      error_at(result.error());
      return EXIT_FAILURE;
    }

    doctorMode     = parser.get<bool>("-d") || parser.get<bool>("--doctor");
    clearCache     = parser.get<bool>("--clear-cache");
    ignoreCacheRun = parser.get<bool>("--ignore-cache");
    noAscii        = parser.get<bool>("--no-ascii");
    jsonOutput     = parser.get<bool>("--json");

    SetRuntimeLogLevel(
      parser.get<bool>("-V") || parser.get<bool>("--verbose")
        ? LogLevel::Debug
        : parser.getEnum<LogLevel>("--log-level")
    );
  }

  using draconis::utils::cache::CacheManager, draconis::utils::cache::CachePolicy;

  CacheManager cache;

  if (ignoreCacheRun)
    CacheManager::ignoreCache = true;

  cache.setGlobalPolicy(CachePolicy::tempDirectory());

  if (clearCache) {
    const u8 removedCount = cache.invalidateAll(true);

    if (removedCount > 0)
      Println("Removed {} files.", removedCount);
    else
      Println("No cache files were found to clear.");

    return EXIT_SUCCESS;
  }

#ifndef NDEBUG
  if (Result<CPUCores> cpuCores = GetCPUCores(cache))
    debug_log("CPU cores: {} physical, {} logical", cpuCores->physical, cpuCores->logical);
  else
    debug_at(cpuCores.error());

  if (Result<NetworkInterface> networkInterface = GetPrimaryNetworkInterface(cache)) {
    debug_log("Network interface: {}", networkInterface->name);
    debug_log("Network interface IPv4 address: {}", networkInterface->ipv4Address.value_or("N/A"));
    debug_log("Network interface MAC address: {}", networkInterface->macAddress.value_or("N/A"));
    debug_log("Network interface is up: {}", networkInterface->isUp);
    debug_log("Network interface is loopback: {}", networkInterface->isLoopback);
  } else
    debug_at(networkInterface.error());

  if (Result<Battery> battery = GetBatteryInfo(cache)) {
    debug_log("Battery status: {}", magic_enum::enum_name(battery->status));

    debug_log("Battery percentage: {}%", battery->percentage.value_or(0));

    if (battery->timeRemaining.has_value())
      debug_log("Battery time remaining: {}", SecondsToFormattedDuration(battery->timeRemaining.value()));
    else
      debug_log("Battery time remaining: N/A");
  } else
    debug_at(battery.error());

  if (Result<DisplayInfo> primaryOutput = GetPrimaryOutput(cache)) {
    debug_log("Primary display ID: {}", primaryOutput->id);
    debug_log("Primary display resolution: {}x{}", primaryOutput->resolution.width, primaryOutput->resolution.height);
    debug_log("Primary display refresh rate: {:.2f}Hz", primaryOutput->refreshRate);
    debug_log("Primary display is primary: {}", primaryOutput->isPrimary);
  } else
    debug_at(primaryOutput.error());
#endif

  {
    const Config& config = Config::getInstance();
    SystemInfo    data(cache, config);

#if DRAC_ENABLE_WEATHER
    using enum draconis::utils::error::DracErrorCode;

    Result<Report> weatherReport;

    if (config.weather.enabled && config.weather.service == nullptr)
      weatherReport = Err({ Other, "Weather service is not configured" });
    else if (config.weather.enabled)
      weatherReport = config.weather.service->getWeatherInfo();
    else
      weatherReport = Err({ ApiUnavailable, "Weather is disabled" });
#endif

    if (doctorMode) {
      PrintDoctorReport(
#if DRAC_ENABLE_WEATHER
        weatherReport,
#endif
        data
      );

      return EXIT_SUCCESS;
    }

    if (jsonOutput)
      PrintJsonOutput(
#if DRAC_ENABLE_WEATHER
        weatherReport,
#endif
        data
      );
    else
      WriteToConsole(CreateUI(
        config,
        data,
#if DRAC_ENABLE_WEATHER
        weatherReport,
#endif
        noAscii
      ));
  }

  return EXIT_SUCCESS;
} catch (const Exception& e) {
  error_at(e);
  return EXIT_FAILURE;
}
</file>

</files>
